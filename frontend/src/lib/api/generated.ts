/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Software Distribution Platform API
 * Comprehensive API for software distribution
 * OpenAPI spec version: 1.0.0
 */
// @ts-nocheck
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';
import type {
  RequestHandlerOptions
} from 'msw';

import { apiClient } from './client';
/**
 * Serializer for abuse alerts (read‚Äëonly for admins).
 */
export interface AbuseAlert {
  readonly id: string;
  alert_type: AlertTypeEnum;
  /** @maxLength 255 */
  title: string;
  message: string;
  acknowledged?: boolean;
  /** @nullable */
  acknowledged_at?: string | null;
  readonly created_at: string;
}

/**
 * Serializer for abuse attempts (read‚Äëonly for admins).
Exposes only necessary fields; sensitive request data is excluded.
 */
export interface AbuseAttempt {
  readonly id: string;
  ip_address: string;
  user_agent?: string;
  attempt_type: AttemptTypeEnum;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  severity?: SeverityEnum;
  action_taken?: ActionTakenEnum;
  readonly created_at: string;
}

/**
 * * `ACTIVATE` - Activate
* `VALIDATE` - Validate
* `DEACTIVATE` - Deactivate
* `REACTIVATE` - Reactivate
* `VERIFY` - Verify
 */
export type ActionEnum = typeof ActionEnum[keyof typeof ActionEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActionEnum = {
  ACTIVATE: 'ACTIVATE',
  VALIDATE: 'VALIDATE',
  DEACTIVATE: 'DEACTIVATE',
  REACTIVATE: 'REACTIVATE',
  VERIFY: 'VERIFY',
} as const;

/**
 * * `NONE` - None
* `WARNED` - Warned
* `BLOCKED` - Blocked
* `REVOKED` - Revoked
* `BANNED` - Banned
* `REQUIRES_VERIFICATION` - Requires Verification
 */
export type ActionTakenEnum = typeof ActionTakenEnum[keyof typeof ActionTakenEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActionTakenEnum = {
  NONE: 'NONE',
  WARNED: 'WARNED',
  BLOCKED: 'BLOCKED',
  REVOKED: 'REVOKED',
  BANNED: 'BANNED',
  REQUIRES_VERIFICATION: 'REQUIRES_VERIFICATION',
} as const;

export interface ActivationCode {
  readonly id: string;
  software: string;
  readonly software_name: string;
  readonly software_slug: string;
  readonly software_app_code: string;
  /** @nullable */
  software_version?: string | null;
  /** @nullable */
  batch?: string | null;
  /** @nullable */
  readonly batch_name: string | null;
  readonly encrypted_code: string;
  readonly code_hash: string;
  /**
   * Formatted code for users (e.g., ABCD-EFGH-IJKL-MNOP)
   * @maxLength 50
   */
  human_code?: string;
  license_type?: LicenseType6d0Enum;
  status?: ActivationCodeStatusEnum;
  /** @nullable */
  user?: string | null;
  /** @nullable */
  readonly user_email: string | null;
  /** @nullable */
  generated_by?: string | null;
  /** @nullable */
  readonly generated_by_email: string | null;
  /**
   * Maximum number of devices that can activate this code
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_activations?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  activation_count?: number;
  /**
   * Maximum concurrent activations
   * @minimum -2147483648
   * @maximum 2147483647
   */
  concurrent_limit?: number;
  /**
   * @maxLength 64
   * @nullable
   */
  device_fingerprint?: string | null;
  /** @maxLength 255 */
  device_name?: string;
  /** Additional device information */
  device_info?: unknown;
  readonly created_at: string;
  /** @nullable */
  readonly activated_at: string | null;
  expires_at: string;
  /** @nullable */
  readonly last_used_at: string | null;
  /** @nullable */
  readonly revoked_at: string | null;
  /** @nullable */
  revoked_by?: string | null;
  /** @nullable */
  readonly revoked_by_email: string | null;
  revoked_reason?: string;
  notes?: string;
  /** Additional custom data */
  custom_data?: unknown;
  readonly is_valid: boolean;
  readonly is_expired: boolean;
  readonly is_revoked: boolean;
  readonly remaining_activations: number;
  /** @nullable */
  readonly days_until_expiry: number | null;
  readonly license_file: string;
}

export interface ActivationCodeRequest {
  software: string;
  /** @nullable */
  software_version?: string | null;
  /** @nullable */
  batch?: string | null;
  /**
   * Formatted code for users (e.g., ABCD-EFGH-IJKL-MNOP)
   * @minLength 1
   * @maxLength 50
   */
  human_code?: string;
  license_type?: LicenseType6d0Enum;
  status?: ActivationCodeStatusEnum;
  /** @nullable */
  user?: string | null;
  /** @nullable */
  generated_by?: string | null;
  /**
   * Maximum number of devices that can activate this code
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_activations?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  activation_count?: number;
  /**
   * Maximum concurrent activations
   * @minimum -2147483648
   * @maximum 2147483647
   */
  concurrent_limit?: number;
  /**
   * @maxLength 64
   * @nullable
   */
  device_fingerprint?: string | null;
  /** @maxLength 255 */
  device_name?: string;
  /** Additional device information */
  device_info?: unknown;
  expires_at: string;
  /** @nullable */
  revoked_by?: string | null;
  revoked_reason?: string;
  notes?: string;
  /** Additional custom data */
  custom_data?: unknown;
}

/**
 * * `GENERATED` - Generated
* `ACTIVATED` - Activated
* `REVOKED` - Revoked
* `EXPIRED` - Expired
* `SUSPENDED` - Suspended
 */
export type ActivationCodeStatusEnum = typeof ActivationCodeStatusEnum[keyof typeof ActivationCodeStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActivationCodeStatusEnum = {
  GENERATED: 'GENERATED',
  ACTIVATED: 'ACTIVATED',
  REVOKED: 'REVOKED',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED',
} as const;

export interface ActivationLog {
  readonly id: string;
  activation_code: string;
  readonly activation_code_human: string;
  readonly software_name: string;
  /** @maxLength 64 */
  device_fingerprint: string;
  /** @maxLength 255 */
  device_name?: string;
  device_info?: unknown;
  ip_address: string;
  user_agent?: string;
  /** @maxLength 255 */
  location?: string;
  action: ActionEnum;
  success?: boolean;
  error_message?: string;
  is_suspicious?: boolean;
  suspicion_reason?: string;
  readonly created_at: string;
}

export interface ActivationRequest {
  /** @maxLength 50 */
  activation_code: string;
  /** @pattern ^[-a-zA-Z0-9_]+$ */
  software_slug: string;
  device_fingerprint?: string;
  /** @maxLength 255 */
  device_name?: string;
  device_info?: unknown;
  force_activation?: boolean;
}

export interface ActivationRequestRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  activation_code: string;
  /**
   * @minLength 1
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  software_slug: string;
  device_fingerprint?: string;
  /** @maxLength 255 */
  device_name?: string;
  device_info?: unknown;
  force_activation?: boolean;
}

/**
 * Serializer for AdminActionLog model.
Preserves the original output fields using derived values.
 */
export interface AdminActionLog {
  readonly id: number;
  readonly admin_user: string;
  readonly action: string;
  /** If the target is a user, return their email. */
  readonly target_user: string;
  readonly target_model: string;
  /** @nullable */
  target_id?: string | null;
  details?: unknown;
  readonly status: AdminActionLogStatusEnum;
  readonly created_at: string;
}

/**
 * * `active` - Active
* `undone` - Undone
 */
export type AdminActionLogStatusEnum = typeof AdminActionLogStatusEnum[keyof typeof AdminActionLogStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminActionLogStatusEnum = {
  active: 'active',
  undone: 'undone',
} as const;

/**
 * Serializer for AdminProfile model.
Note: AdminProfile uses user as primary key, so we provide an 'id' field
that returns the user's UUID for backward compatibility.
 */
export interface AdminProfile {
  /** Return the associated user's ID as the admin profile ID. */
  readonly id: string;
  user: string;
  readonly user_email: string;
  /** @maxLength 100 */
  department?: string;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for AdminProfile model.
Note: AdminProfile uses user as primary key, so we provide an 'id' field
that returns the user's UUID for backward compatibility.
 */
export interface AdminProfileRequest {
  user: string;
  /** @maxLength 100 */
  department?: string;
}

/**
 * * `CRITICAL` - Critical
* `HIGH` - High
* `MEDIUM` - Medium
* `LOW` - Low
* `INFO` - Informational
 */
export type AlertTypeEnum = typeof AlertTypeEnum[keyof typeof AlertTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AlertTypeEnum = {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW',
  INFO: 'INFO',
} as const;

/**
 * * `ACTIVATION` - Activation
* `VALIDATION` - Validation
* `BRUTE_FORCE` - Brute Force
* `CODE_SHARING` - Code Sharing
* `DEVICE_MISMATCH` - Device Mismatch
* `GEO_VELOCITY` - Geographic Velocity
* `RATE_LIMIT` - Rate Limit
* `OTHER` - Other
 */
export type AttemptTypeEnum = typeof AttemptTypeEnum[keyof typeof AttemptTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AttemptTypeEnum = {
  ACTIVATION: 'ACTIVATION',
  VALIDATION: 'VALIDATION',
  BRUTE_FORCE: 'BRUTE_FORCE',
  CODE_SHARING: 'CODE_SHARING',
  DEVICE_MISMATCH: 'DEVICE_MISMATCH',
  GEO_VELOCITY: 'GEO_VELOCITY',
  RATE_LIMIT: 'RATE_LIMIT',
  OTHER: 'OTHER',
} as const;

/**
 * Serializer for software categories.
 */
export interface Category {
  readonly id: string;
  /** @maxLength 100 */
  name: string;
  /**
   * @maxLength 100
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  slug: string;
  description?: string;
  /** @nullable */
  parent?: string | null;
  readonly parent_name: string;
  /**
   * FontAwesome icon class
   * @maxLength 50
   */
  icon?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  is_active?: boolean;
  readonly software_count: number;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for software categories.
 */
export interface CategoryRequest {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 100
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  slug: string;
  description?: string;
  /** @nullable */
  parent?: string | null;
  /**
   * FontAwesome icon class
   * @maxLength 50
   */
  icon?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  is_active?: boolean;
}

/**
 * Serializer for password change.
Validates current password and ensures new passwords match.
 */
export interface ChangePasswordRequest {
  /** @minLength 1 */
  current_password: string;
  /** @minLength 1 */
  new_password: string;
  /** @minLength 1 */
  confirm_password: string;
}

/**
 * * `email` - Email
* `in_app` - In‚ÄëApp
* `push` - Push
 */
export type ChannelEnum = typeof ChannelEnum[keyof typeof ChannelEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ChannelEnum = {
  email: 'email',
  in_app: 'in_app',
  push: 'push',
} as const;

export interface CodeBatch {
  readonly id: string;
  software: string;
  readonly software_name: string;
  /** @maxLength 255 */
  name: string;
  description?: string;
  license_type: LicenseType6d0Enum;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  count: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_activations?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  expires_in_days?: number;
  /**
   * Prefix for generated codes
   * @maxLength 10
   */
  prefix?: string;
  is_used?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  used_count?: number;
  readonly unused_count: number;
  /** @nullable */
  generated_by?: string | null;
  readonly generated_by_email: string;
  readonly created_at: string;
}

export interface CodeBatchRequest {
  software: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  description?: string;
  license_type: LicenseType6d0Enum;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  count: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_activations?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  expires_in_days?: number;
  /**
   * Prefix for generated codes
   * @maxLength 10
   */
  prefix?: string;
  is_used?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  used_count?: number;
  /** @nullable */
  generated_by?: string | null;
}

/**
 * Serializer for code blacklist entries.
 */
export interface CodeBlacklist {
  readonly id: string;
  activation_code: string;
  reason: string;
  source?: CodeBlacklistSourceEnum;
  is_permanent?: boolean;
  /**
   * Leave blank for permanent ban
   * @nullable
   */
  expires_at?: string | null;
  is_active?: boolean;
  readonly created_at: string;
}

/**
 * Serializer for code blacklist entries.
 */
export interface CodeBlacklistRequest {
  activation_code: string;
  /** @minLength 1 */
  reason: string;
  source?: CodeBlacklistSourceEnum;
  is_permanent?: boolean;
  /**
   * Leave blank for permanent ban
   * @nullable
   */
  expires_at?: string | null;
  is_active?: boolean;
}

/**
 * * `MANUAL` - Manual
* `AUTO` - Automatic
* `USER_REPORT` - User Report
* `LAW_ENFORCEMENT` - Law Enforcement
 */
export type CodeBlacklistSourceEnum = typeof CodeBlacklistSourceEnum[keyof typeof CodeBlacklistSourceEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CodeBlacklistSourceEnum = {
  MANUAL: 'MANUAL',
  AUTO: 'AUTO',
  USER_REPORT: 'USER_REPORT',
  LAW_ENFORCEMENT: 'LAW_ENFORCEMENT',
} as const;

export interface CohortAggregate {
  readonly id: string;
  readonly cohort_date: string;
  readonly period: PeriodEnum;
  readonly period_number: number;
  readonly user_count: number;
  readonly retained_count: number;
  /**
   * Percentage (0.00 to 100.00)
   * @pattern ^-?\d{0,3}(?:\.\d{0,2})?$
   */
  readonly retention_rate: string;
  readonly created_at: string;
}

/**
 * Admin CRUD for coupons.
 */
export interface Coupon {
  readonly id: string;
  /** @maxLength 50 */
  code: string;
  description?: string;
  discount_type?: DiscountTypeEnum;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  discount_value: string;
  /**
   * Maximum discount amount (for percentage discounts)
   * @nullable
   * @pattern ^-?\d{0,8}(?:\.\d{0,2})?$
   */
  max_discount?: string | null;
  valid_from: string;
  valid_until: string;
  /**
   * Maximum number of times this coupon can be used
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  max_uses?: number | null;
  /**
   * Maximum number of times a single user can use this coupon
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_uses_per_user?: number;
  /**
   * Minimum purchase amount required
   * @pattern ^-?\d{0,8}(?:\.\d{0,2})?$
   */
  minimum_purchase?: string;
  is_active?: boolean;
  readonly times_used: number;
  readonly created_at: string;
  readonly updated_at: string;
  /** Leave empty to apply to all software */
  applicable_software?: string[];
}

/**
 * Admin CRUD for coupons.
 */
export interface CouponRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  code: string;
  description?: string;
  discount_type?: DiscountTypeEnum;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  discount_value: string;
  /**
   * Maximum discount amount (for percentage discounts)
   * @nullable
   * @pattern ^-?\d{0,8}(?:\.\d{0,2})?$
   */
  max_discount?: string | null;
  valid_from: string;
  valid_until: string;
  /**
   * Maximum number of times this coupon can be used
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  max_uses?: number | null;
  /**
   * Maximum number of times a single user can use this coupon
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_uses_per_user?: number;
  /**
   * Minimum purchase amount required
   * @pattern ^-?\d{0,8}(?:\.\d{0,2})?$
   */
  minimum_purchase?: string;
  is_active?: boolean;
  /** Leave empty to apply to all software */
  applicable_software?: string[];
}

export interface CustomTokenObtainPair {
  /** Device fingerprint for security validation */
  device_fingerprint?: string;
}

export interface CustomTokenObtainPairRequest {
  /** @minLength 1 */
  email: string;
  /** @minLength 1 */
  password: string;
  /** Device fingerprint for security validation */
  device_fingerprint?: string;
}

export interface DailyAggregate {
  readonly id: string;
  readonly date: string;
  readonly total_users: number;
  readonly active_users: number;
  readonly new_users: number;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  readonly total_sales: string;
  readonly total_orders: number;
  readonly licenses_activated: number;
  readonly licenses_expired: number;
  readonly total_usage_events: number;
  readonly abuse_attempts: number;
  readonly created_at: string;
  readonly updated_at: string;
}

export interface DeactivationRequest {
  activation_id: string;
  reason?: string;
  keep_license?: boolean;
}

export interface DeactivationRequestRequest {
  activation_id: string;
  reason?: string;
  keep_license?: boolean;
}

/**
 * * `PERCENTAGE` - Percentage
* `FIXED` - Fixed Amount
 */
export type DiscountTypeEnum = typeof DiscountTypeEnum[keyof typeof DiscountTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DiscountTypeEnum = {
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED',
} as const;

/**
 * * `MANUAL` - User Manual
* `GUIDE` - Installation Guide
* `API` - API Documentation
* `LICENSE` - License Agreement
* `RELEASE_NOTES` - Release Notes
* `OTHER` - Other
 */
export type DocumentTypeEnum = typeof DocumentTypeEnum[keyof typeof DocumentTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentTypeEnum = {
  MANUAL: 'MANUAL',
  GUIDE: 'GUIDE',
  API: 'API',
  LICENSE: 'LICENSE',
  RELEASE_NOTES: 'RELEASE_NOTES',
  OTHER: 'OTHER',
} as const;

/**
 * Serializer for emergency 2FA verification.
Expects a verification token and the MFA code (TOTP or backup code).
 */
export interface EmergencyTwoFactorVerify {
  verification_token: string;
  /**
   * TOTP code from authenticator app or 8‚Äëcharacter backup code
   * @minLength 6
   * @maxLength 8
   */
  mfa_code: string;
}

/**
 * Serializer for emergency 2FA verification.
Expects a verification token and the MFA code (TOTP or backup code).
 */
export interface EmergencyTwoFactorVerifyRequest {
  /** @minLength 1 */
  verification_token: string;
  /**
   * TOTP code from authenticator app or 8‚Äëcharacter backup code
   * @minLength 6
   * @maxLength 8
   */
  mfa_code: string;
}

/**
 * Serializer for ExportJob ‚Äì provides a secure file URL (signed S3 URL if using private storage,
otherwise a link to the authenticated download endpoint).
 */
export interface ExportJob {
  readonly id: string;
  export_type: ExportTypeEnum;
  readonly status: ExportJobStatusEnum;
  parameters?: unknown;
  /** @nullable */
  readonly file: string | null;
  /** Return a secure URL to download the file. */
  readonly file_url: string;
  readonly error_message: string;
  /** @nullable */
  readonly created_by: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  /** @nullable */
  readonly completed_at: string | null;
}

/**
 * Serializer for ExportJob ‚Äì provides a secure file URL (signed S3 URL if using private storage,
otherwise a link to the authenticated download endpoint).
 */
export interface ExportJobRequest {
  export_type: ExportTypeEnum;
  parameters?: unknown;
}

/**
 * * `pending` - Pending
* `processing` - Processing
* `completed` - Completed
* `failed` - Failed
 */
export type ExportJobStatusEnum = typeof ExportJobStatusEnum[keyof typeof ExportJobStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExportJobStatusEnum = {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

/**
 * * `daily_aggregates` - Daily Aggregates
* `users` - Users
* `payments` - Payments
* `licenses` - Licenses
 */
export type ExportTypeEnum = typeof ExportTypeEnum[keyof typeof ExportTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExportTypeEnum = {
  daily_aggregates: 'daily_aggregates',
  users: 'users',
  payments: 'payments',
  licenses: 'licenses',
} as const;

/**
 * Generic response serializer for placeholder endpoints.
 */
export interface GenericResponse {
  /** Status message */
  status: string;
}

/**
 * Generic response serializer for placeholder endpoints.
 */
export interface GenericResponseRequest {
  /**
   * Status message
   * @minLength 1
   */
  status: string;
}

/**
 * Serializer for IP blacklist entries.
 */
export interface IPBlacklist {
  readonly id: string;
  ip_address: string;
  /**
   * CIDR notation (e.g., 24 for /24). For a single IP, use 32 (IPv4) or 128 (IPv6).
   * @minimum 0
   * @maximum 32767
   * @nullable
   */
  subnet_mask?: number | null;
  /** Normalized CIDR string (e.g., '192.168.1.0/24'). Auto‚Äëgenerated. */
  readonly cidr: string;
  reason: string;
  source?: IPBlacklistSourceEnum;
  is_permanent?: boolean;
  /**
   * Leave blank for permanent ban
   * @nullable
   */
  expires_at?: string | null;
  is_active?: boolean;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for IP blacklist entries.
 */
export interface IPBlacklistRequest {
  /** @minLength 1 */
  ip_address: string;
  /**
   * CIDR notation (e.g., 24 for /24). For a single IP, use 32 (IPv4) or 128 (IPv6).
   * @minimum 0
   * @maximum 32767
   * @nullable
   */
  subnet_mask?: number | null;
  /** @minLength 1 */
  reason: string;
  source?: IPBlacklistSourceEnum;
  is_permanent?: boolean;
  /**
   * Leave blank for permanent ban
   * @nullable
   */
  expires_at?: string | null;
  is_active?: boolean;
}

/**
 * * `MANUAL` - Manual
* `AUTO` - Automatic
* `THREAT_INTEL` - Threat Intelligence
* `USER_REPORT` - User Report
 */
export type IPBlacklistSourceEnum = typeof IPBlacklistSourceEnum[keyof typeof IPBlacklistSourceEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IPBlacklistSourceEnum = {
  MANUAL: 'MANUAL',
  AUTO: 'AUTO',
  THREAT_INTEL: 'THREAT_INTEL',
  USER_REPORT: 'USER_REPORT',
} as const;

/**
 * * `LOGO` - Logo
* `SCREENSHOT` - Screenshot
* `BANNER` - Banner
* `ICON` - Icon
* `OTHER` - Other
 */
export type ImageTypeEnum = typeof ImageTypeEnum[keyof typeof ImageTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImageTypeEnum = {
  LOGO: 'LOGO',
  SCREENSHOT: 'SCREENSHOT',
  BANNER: 'BANNER',
  ICON: 'ICON',
  OTHER: 'OTHER',
} as const;

/**
 * * `month` - Monthly
* `year` - Yearly
* `lifetime` - Lifetime
 */
export type IntervalEnum = typeof IntervalEnum[keyof typeof IntervalEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IntervalEnum = {
  month: 'month',
  year: 'year',
  lifetime: 'lifetime',
} as const;

export type InvoiceMetadata = {[key: string]: unknown};

export interface Invoice {
  readonly id: string;
  readonly user: string;
  payment: string;
  readonly number: string;
  readonly status: InvoiceStatusEnum;
  /** @maxLength 3 */
  currency?: string;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  readonly amount: string;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  readonly tax: string;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  total: string;
  /** @nullable */
  readonly issued_at: string | null;
  /** @nullable */
  readonly paid_at: string | null;
  readonly due_at: string;
  /** @nullable */
  readonly pdf_file: string | null;
  readonly metadata: InvoiceMetadata;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * * `draft` - Draft
* `issued` - Issued
* `paid` - Paid
* `void` - Void
 */
export type InvoiceStatusEnum = typeof InvoiceStatusEnum[keyof typeof InvoiceStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InvoiceStatusEnum = {
  draft: 'draft',
  issued: 'issued',
  paid: 'paid',
  void: 'void',
} as const;

export interface LicenseFeature {
  readonly id: string;
  software: string;
  readonly software_name: string;
  /** @maxLength 100 */
  name: string;
  /**
   * Internal code for this feature
   * @maxLength 50
   */
  code: string;
  description?: string;
  available_in_trial?: boolean;
  available_in_standard?: boolean;
  available_in_premium?: boolean;
  available_in_enterprise?: boolean;
  requires_activation?: boolean;
  /**
   * Maximum usage count (null for unlimited)
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  max_usage?: number | null;
  is_active?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  readonly created_at: string;
  readonly updated_at: string;
}

export interface LicenseFeatureRequest {
  software: string;
  /**
   * @minLength 1
   * @maxLength 100
   */
  name: string;
  /**
   * Internal code for this feature
   * @minLength 1
   * @maxLength 50
   */
  code: string;
  description?: string;
  available_in_trial?: boolean;
  available_in_standard?: boolean;
  available_in_premium?: boolean;
  available_in_enterprise?: boolean;
  requires_activation?: boolean;
  /**
   * Maximum usage count (null for unlimited)
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  max_usage?: number | null;
  is_active?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
}

/**
 * * `TRIAL` - Trial
* `STANDARD` - Standard
* `PREMIUM` - Premium
* `ENTERPRISE` - Enterprise
* `LIFETIME` - Lifetime
 */
export type LicenseType6d0Enum = typeof LicenseType6d0Enum[keyof typeof LicenseType6d0Enum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LicenseType6d0Enum = {
  TRIAL: 'TRIAL',
  STANDARD: 'STANDARD',
  PREMIUM: 'PREMIUM',
  ENTERPRISE: 'ENTERPRISE',
  LIFETIME: 'LIFETIME',
} as const;

export interface LicenseUsage {
  readonly id: string;
  activation_code: string;
  readonly activation_code_human: string;
  feature: string;
  readonly feature_name: string;
  readonly feature_code: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  usage_count?: number;
  /** Additional usage data */
  usage_data?: unknown;
  /** @maxLength 64 */
  device_fingerprint: string;
  ip_address: string;
  readonly created_at: string;
  readonly updated_at: string;
}

export interface LicenseUsageRequest {
  activation_code: string;
  feature: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  usage_count?: number;
  /** Additional usage data */
  usage_data?: unknown;
  /**
   * @minLength 1
   * @maxLength 64
   */
  device_fingerprint: string;
  /** @minLength 1 */
  ip_address: string;
}

/**
 * Basic mirror information for public or internal use.
Excludes operational metrics (latency, failure count) for security.
 */
export interface Mirror {
  readonly id: string;
  readonly name: string;
  /** Base URL of the mirror, e.g., https://mirror1.example.com */
  readonly base_url: string;
  /** Geographic region, e.g., 'EU' */
  readonly region: string;
  /** Lower number = higher priority */
  readonly priority: number;
  /** Whether the mirror is currently reachable */
  readonly is_online: boolean;
}

/**
 * Serializer for Notification model.
All fields are read‚Äëonly by default to prevent client modification.
Includes user and context metadata for richer client integration.
 */
export interface Notification {
  readonly id: string;
  readonly user: string;
  readonly channel: ChannelEnum;
  readonly subject: string;
  readonly body: string;
  readonly html_body: string;
  readonly context: unknown;
  readonly status: NotificationStatusEnum;
  /** @nullable */
  readonly sent_at: string | null;
  /** @nullable */
  readonly opened_at: string | null;
  /** @nullable */
  readonly clicked_at: string | null;
  readonly created_at: string;
}

/**
 * * `pending` - Pending
* `sent` - Sent
* `failed` - Failed
 */
export type NotificationStatusEnum = typeof NotificationStatusEnum[keyof typeof NotificationStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotificationStatusEnum = {
  pending: 'pending',
  sent: 'sent',
  failed: 'failed',
} as const;

export interface PaginatedAbuseAlertList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: AbuseAlert[];
}

export interface PaginatedAbuseAttemptList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: AbuseAttempt[];
}

export interface PaginatedActivationCodeList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: ActivationCode[];
}

export interface PaginatedActivationLogList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: ActivationLog[];
}

export interface PaginatedAdminActionLogList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: AdminActionLog[];
}

export interface PaginatedAdminProfileList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: AdminProfile[];
}

export interface PaginatedCategoryList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Category[];
}

export interface PaginatedCodeBatchList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: CodeBatch[];
}

export interface PaginatedCodeBlacklistList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: CodeBlacklist[];
}

export interface PaginatedCouponList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Coupon[];
}

export interface PaginatedExportJobList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: ExportJob[];
}

export interface PaginatedIPBlacklistList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: IPBlacklist[];
}

export interface PaginatedInvoiceList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Invoice[];
}

export interface PaginatedLicenseFeatureList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: LicenseFeature[];
}

export interface PaginatedLicenseUsageList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: LicenseUsage[];
}

export interface PaginatedMirrorList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Mirror[];
}

export interface PaginatedNotificationList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Notification[];
}

export interface PaginatedPlanList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Plan[];
}

export interface PaginatedSecurityNotificationLogList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: SecurityNotificationLog[];
}

export interface PaginatedSoftwareDocumentList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: SoftwareDocument[];
}

export interface PaginatedSoftwareImageList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: SoftwareImage[];
}

export interface PaginatedSoftwareList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Software[];
}

export interface PaginatedSoftwareVersionList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: SoftwareVersion[];
}

export interface PaginatedSubscriptionList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Subscription[];
}

export interface PaginatedTransactionList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Transaction[];
}

export interface PaginatedUserList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: User[];
}

export interface PaginatedUserSessionList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: UserSession[];
}

export interface PasswordResetConfirm {
  token: string;
}

export interface PasswordResetConfirmRequest {
  /** @minLength 1 */
  token: string;
  /** @minLength 1 */
  new_password: string;
  /** @minLength 1 */
  confirm_password: string;
}

export interface PasswordResetRequest {
  email: string;
}

export interface PasswordResetRequestRequest {
  /** @minLength 1 */
  email: string;
}

export interface PatchedActivationCodeRequest {
  software?: string;
  /** @nullable */
  software_version?: string | null;
  /** @nullable */
  batch?: string | null;
  /**
   * Formatted code for users (e.g., ABCD-EFGH-IJKL-MNOP)
   * @minLength 1
   * @maxLength 50
   */
  human_code?: string;
  license_type?: LicenseType6d0Enum;
  status?: ActivationCodeStatusEnum;
  /** @nullable */
  user?: string | null;
  /** @nullable */
  generated_by?: string | null;
  /**
   * Maximum number of devices that can activate this code
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_activations?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  activation_count?: number;
  /**
   * Maximum concurrent activations
   * @minimum -2147483648
   * @maximum 2147483647
   */
  concurrent_limit?: number;
  /**
   * @maxLength 64
   * @nullable
   */
  device_fingerprint?: string | null;
  /** @maxLength 255 */
  device_name?: string;
  /** Additional device information */
  device_info?: unknown;
  expires_at?: string;
  /** @nullable */
  revoked_by?: string | null;
  revoked_reason?: string;
  notes?: string;
  /** Additional custom data */
  custom_data?: unknown;
}

/**
 * Serializer for AdminProfile model.
Note: AdminProfile uses user as primary key, so we provide an 'id' field
that returns the user's UUID for backward compatibility.
 */
export interface PatchedAdminProfileRequest {
  user?: string;
  /** @maxLength 100 */
  department?: string;
}

/**
 * Serializer for software categories.
 */
export interface PatchedCategoryRequest {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name?: string;
  /**
   * @minLength 1
   * @maxLength 100
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  slug?: string;
  description?: string;
  /** @nullable */
  parent?: string | null;
  /**
   * FontAwesome icon class
   * @maxLength 50
   */
  icon?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  is_active?: boolean;
}

export interface PatchedCodeBatchRequest {
  software?: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  description?: string;
  license_type?: LicenseType6d0Enum;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  count?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_activations?: number;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  expires_in_days?: number;
  /**
   * Prefix for generated codes
   * @maxLength 10
   */
  prefix?: string;
  is_used?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  used_count?: number;
  /** @nullable */
  generated_by?: string | null;
}

/**
 * Serializer for code blacklist entries.
 */
export interface PatchedCodeBlacklistRequest {
  activation_code?: string;
  /** @minLength 1 */
  reason?: string;
  source?: CodeBlacklistSourceEnum;
  is_permanent?: boolean;
  /**
   * Leave blank for permanent ban
   * @nullable
   */
  expires_at?: string | null;
  is_active?: boolean;
}

/**
 * Admin CRUD for coupons.
 */
export interface PatchedCouponRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  code?: string;
  description?: string;
  discount_type?: DiscountTypeEnum;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  discount_value?: string;
  /**
   * Maximum discount amount (for percentage discounts)
   * @nullable
   * @pattern ^-?\d{0,8}(?:\.\d{0,2})?$
   */
  max_discount?: string | null;
  valid_from?: string;
  valid_until?: string;
  /**
   * Maximum number of times this coupon can be used
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  max_uses?: number | null;
  /**
   * Maximum number of times a single user can use this coupon
   * @minimum -2147483648
   * @maximum 2147483647
   */
  max_uses_per_user?: number;
  /**
   * Minimum purchase amount required
   * @pattern ^-?\d{0,8}(?:\.\d{0,2})?$
   */
  minimum_purchase?: string;
  is_active?: boolean;
  /** Leave empty to apply to all software */
  applicable_software?: string[];
}

/**
 * Serializer for IP blacklist entries.
 */
export interface PatchedIPBlacklistRequest {
  /** @minLength 1 */
  ip_address?: string;
  /**
   * CIDR notation (e.g., 24 for /24). For a single IP, use 32 (IPv4) or 128 (IPv6).
   * @minimum 0
   * @maximum 32767
   * @nullable
   */
  subnet_mask?: number | null;
  /** @minLength 1 */
  reason?: string;
  source?: IPBlacklistSourceEnum;
  is_permanent?: boolean;
  /**
   * Leave blank for permanent ban
   * @nullable
   */
  expires_at?: string | null;
  is_active?: boolean;
}

export interface PatchedLicenseFeatureRequest {
  software?: string;
  /**
   * @minLength 1
   * @maxLength 100
   */
  name?: string;
  /**
   * Internal code for this feature
   * @minLength 1
   * @maxLength 50
   */
  code?: string;
  description?: string;
  available_in_trial?: boolean;
  available_in_standard?: boolean;
  available_in_premium?: boolean;
  available_in_enterprise?: boolean;
  requires_activation?: boolean;
  /**
   * Maximum usage count (null for unlimited)
   * @minimum -2147483648
   * @maximum 2147483647
   * @nullable
   */
  max_usage?: number | null;
  is_active?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
}

export interface PatchedLicenseUsageRequest {
  activation_code?: string;
  feature?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  usage_count?: number;
  /** Additional usage data */
  usage_data?: unknown;
  /**
   * @minLength 1
   * @maxLength 64
   */
  device_fingerprint?: string;
  /** @minLength 1 */
  ip_address?: string;
}

/**
 * Serializer for software documents.
 */
export interface PatchedSoftwareDocumentRequest {
  software?: string;
  document_type?: DocumentTypeEnum;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title?: string;
  description?: string;
  /**
   * @minLength 1
   * @maxLength 10
   */
  language?: string;
  /** @maxLength 50 */
  version?: string;
  is_active?: boolean;
}

/**
 * Serializer for software images.
 */
export interface PatchedSoftwareImageRequest {
  software?: string;
  image_type?: ImageTypeEnum;
  /** @maxLength 255 */
  alt_text?: string;
  /** @maxLength 255 */
  caption?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  is_active?: boolean;
}

/**
 * Serializer for software products.
Supports dynamic field exclusion via `fields` query parameter
to optimise list views. (Backward‚Äëcompatible: full serialization by default)
 */
export interface PatchedSoftwareRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /**
   * @minLength 1
   * @maxLength 255
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  slug?: string;
  /**
   * Unique code for this software (e.g., 'WINAPP001')
   * @minLength 1
   * @maxLength 10
   */
  app_code?: string;
  /** @nullable */
  category?: string | null;
  short_description?: string;
  full_description?: string;
  /** List of features */
  features?: unknown;
  /** System requirements */
  requirements?: unknown;
  /** List of tags for filtering */
  tags?: unknown;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  base_price?: string;
  /**
   * @minLength 1
   * @maxLength 3
   */
  currency?: string;
  license_type?: SoftwareLicenseTypeEnum;
  has_trial?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  trial_days?: number;
  /** Features available in trial version */
  trial_features?: unknown;
  is_active?: boolean;
  is_featured?: boolean;
  is_new?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  released_at?: string;
}

/**
 * Serializer for software versions.
 */
export interface PatchedSoftwareVersionRequest {
  software?: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  version_number?: string;
  /**
   * Internal version code (e.g., '1.0.0.1234')
   * @minLength 1
   * @maxLength 20
   */
  version_code?: string;
  /** @maxLength 100 */
  release_name?: string;
  release_notes?: string;
  changelog?: string;
  /** @pattern (?:exe|msi|dmg|deb|rpm|zip|tar\.gz|appimage)$ */
  binary_file?: Blob;
  /** @nullable */
  installer_file?: Blob | null;
  /** List of supported operating systems */
  supported_os?: unknown;
  /** Minimum system requirements */
  min_requirements?: unknown;
  /** Recommended system requirements */
  recommended_requirements?: unknown;
  is_active?: boolean;
  is_beta?: boolean;
  is_stable?: boolean;
  is_signed?: boolean;
  /**
   * @nullable
   * @pattern (?:sig|asc|sign)$
   */
  signature_file?: Blob | null;
  released_at?: string;
}

export interface PatchedSubscriptionRequest {
  /** @nullable */
  plan?: string | null;
  status?: SubscriptionStatusEnum;
  /** @nullable */
  ended_at?: string | null;
  cancel_at_period_end?: boolean;
  metadata?: unknown;
}

/**
 * Serializer for User model (used by UserViewSet).
 */
export interface PatchedUserRequest {
  /**
   * @minLength 1
   * @maxLength 254
   */
  email?: string;
  /** @maxLength 150 */
  first_name?: string;
  /** @maxLength 150 */
  last_name?: string;
  role?: RoleEnum;
  /** @maxLength 255 */
  company?: string;
  /** @maxLength 20 */
  phone?: string;
  is_active?: boolean;
}

/**
 * Placeholder for Payment operations.
 */
export interface PaymentPlaceholder {
  status: string;
}

/**
 * * `week` - Week
* `month` - Month
 */
export type PeriodEnum = typeof PeriodEnum[keyof typeof PeriodEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PeriodEnum = {
  week: 'week',
  month: 'month',
} as const;

export interface Plan {
  readonly id: string;
  /** @maxLength 100 */
  name: string;
  /**
   * @maxLength 50
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  code: string;
  description?: string;
  /** @pattern ^-?\d{0,10}(?:\.\d{0,2})?$ */
  price?: string;
  /** @maxLength 3 */
  currency?: string;
  interval: IntervalEnum;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  trial_days?: number;
  features?: unknown;
  is_active?: boolean;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  sort_order?: number;
  readonly created_at: string;
  readonly updated_at: string;
}

export interface PlanRequest {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 50
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  code: string;
  description?: string;
  /** @pattern ^-?\d{0,10}(?:\.\d{0,2})?$ */
  price?: string;
  /**
   * @minLength 1
   * @maxLength 3
   */
  currency?: string;
  interval: IntervalEnum;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  trial_days?: number;
  features?: unknown;
  is_active?: boolean;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  sort_order?: number;
}

export interface RevocationRequest {
  activation_id: string;
  reason: string;
  notify_user?: boolean;
}

export interface RevocationRequestRequest {
  activation_id: string;
  /** @minLength 1 */
  reason: string;
  notify_user?: boolean;
}

/**
 * * `USER` - User
* `ADMIN` - Admin
* `SUPER_ADMIN` - Super Admin
 */
export type RoleEnum = typeof RoleEnum[keyof typeof RoleEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RoleEnum = {
  USER: 'USER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN',
} as const;

/**
 * Serializer for security notification logs (read‚Äëonly for admins).
 */
export interface SecurityNotificationLog {
  readonly id: string;
  /**
   * SHA‚Äë256 fingerprint of the security event
   * @maxLength 64
   */
  event_hash: string;
  /** @nullable */
  user?: string | null;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  risk_level: number;
  ip_address: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  recipient_count?: number;
  readonly created_at: string;
}

/**
 * * `1` - Level 1
* `5` - Level 5
* `8` - Level 8
* `10` - Level 10
 */
export type SeverityEnum = typeof SeverityEnum[keyof typeof SeverityEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SeverityEnum = {
  NUMBER_1: 1,
  NUMBER_5: 5,
  NUMBER_8: 8,
  NUMBER_10: 10,
} as const;

/**
 * Serializer for software products.
Supports dynamic field exclusion via `fields` query parameter
to optimise list views. (Backward‚Äëcompatible: full serialization by default)
 */
export interface Software {
  readonly id: string;
  /** @maxLength 255 */
  name: string;
  /**
   * @maxLength 255
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  slug: string;
  /**
   * Unique code for this software (e.g., 'WINAPP001')
   * @maxLength 10
   */
  app_code: string;
  /** @nullable */
  category?: string | null;
  readonly category_name: string;
  short_description?: string;
  full_description?: string;
  /** List of features */
  features?: unknown;
  /** System requirements */
  requirements?: unknown;
  /** List of tags for filtering */
  tags?: unknown;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  base_price?: string;
  /** @maxLength 3 */
  currency?: string;
  license_type?: SoftwareLicenseTypeEnum;
  readonly pricing_tiers: string;
  has_trial?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  trial_days?: number;
  /** Features available in trial version */
  trial_features?: unknown;
  is_active?: boolean;
  is_featured?: boolean;
  is_new?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  readonly download_count: number;
  readonly average_rating: number;
  readonly review_count: number;
  readonly supported_os: string;
  readonly current_version: string;
  readonly versions: readonly SoftwareVersion[];
  readonly images: readonly SoftwareImage[];
  readonly documents: readonly SoftwareDocument[];
  released_at?: string;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for software documents.
 */
export interface SoftwareDocument {
  readonly id: string;
  software: string;
  document_type: DocumentTypeEnum;
  /** @maxLength 255 */
  title: string;
  readonly file_url: string;
  readonly file_size: string;
  readonly file_type: string;
  description?: string;
  /** @maxLength 10 */
  language?: string;
  /** @maxLength 50 */
  version: string;
  readonly download_count: number;
  is_active?: boolean;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for software documents.
 */
export interface SoftwareDocumentRequest {
  software: string;
  document_type: DocumentTypeEnum;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title: string;
  description?: string;
  /**
   * @minLength 1
   * @maxLength 10
   */
  language?: string;
  /** @maxLength 50 */
  version: string;
  is_active?: boolean;
}

/**
 * Serializer for software images.
 */
export interface SoftwareImage {
  readonly id: string;
  software: string;
  image_type: ImageTypeEnum;
  readonly image_url: string;
  readonly thumbnail_url: string;
  /** @maxLength 255 */
  alt_text?: string;
  /** @maxLength 255 */
  caption?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  is_active?: boolean;
  readonly created_at: string;
}

/**
 * Serializer for software images.
 */
export interface SoftwareImageRequest {
  software: string;
  image_type: ImageTypeEnum;
  /** @maxLength 255 */
  alt_text?: string;
  /** @maxLength 255 */
  caption?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  is_active?: boolean;
}

/**
 * * `PERPETUAL` - Perpetual
* `SUBSCRIPTION` - Subscription
* `TRIAL` - Trial
* `FLOATING` - Floating
* `CONCURRENT` - Concurrent
 */
export type SoftwareLicenseTypeEnum = typeof SoftwareLicenseTypeEnum[keyof typeof SoftwareLicenseTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SoftwareLicenseTypeEnum = {
  PERPETUAL: 'PERPETUAL',
  SUBSCRIPTION: 'SUBSCRIPTION',
  TRIAL: 'TRIAL',
  FLOATING: 'FLOATING',
  CONCURRENT: 'CONCURRENT',
} as const;

/**
 * Serializer for software products.
Supports dynamic field exclusion via `fields` query parameter
to optimise list views. (Backward‚Äëcompatible: full serialization by default)
 */
export interface SoftwareRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 255
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  slug: string;
  /**
   * Unique code for this software (e.g., 'WINAPP001')
   * @minLength 1
   * @maxLength 10
   */
  app_code: string;
  /** @nullable */
  category?: string | null;
  short_description?: string;
  full_description?: string;
  /** List of features */
  features?: unknown;
  /** System requirements */
  requirements?: unknown;
  /** List of tags for filtering */
  tags?: unknown;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  base_price?: string;
  /**
   * @minLength 1
   * @maxLength 3
   */
  currency?: string;
  license_type?: SoftwareLicenseTypeEnum;
  has_trial?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  trial_days?: number;
  /** Features available in trial version */
  trial_features?: unknown;
  is_active?: boolean;
  is_featured?: boolean;
  is_new?: boolean;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  display_order?: number;
  released_at?: string;
}

/**
 * Serializer for software versions.
 */
export interface SoftwareVersion {
  readonly id: string;
  software: string;
  /** @maxLength 50 */
  version_number: string;
  /**
   * Internal version code (e.g., '1.0.0.1234')
   * @maxLength 20
   */
  version_code: string;
  /** @maxLength 100 */
  release_name?: string;
  release_notes?: string;
  changelog?: string;
  /** @pattern (?:exe|msi|dmg|deb|rpm|zip|tar\.gz|appimage)$ */
  binary_file: string;
  readonly binary_size: number;
  readonly file_size_human: string;
  /** SHA-256 checksum of the binary */
  readonly binary_checksum: string;
  /** @nullable */
  installer_file?: string | null;
  readonly download_url: string;
  readonly download_count: number;
  /** List of supported operating systems */
  supported_os?: unknown;
  /** Minimum system requirements */
  min_requirements?: unknown;
  /** Recommended system requirements */
  recommended_requirements?: unknown;
  is_active?: boolean;
  is_beta?: boolean;
  is_stable?: boolean;
  is_signed?: boolean;
  /**
   * @nullable
   * @pattern (?:sig|asc|sign)$
   */
  signature_file?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  released_at?: string;
}

/**
 * Serializer for software versions.
 */
export interface SoftwareVersionRequest {
  software: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  version_number: string;
  /**
   * Internal version code (e.g., '1.0.0.1234')
   * @minLength 1
   * @maxLength 20
   */
  version_code: string;
  /** @maxLength 100 */
  release_name?: string;
  release_notes?: string;
  changelog?: string;
  /** @pattern (?:exe|msi|dmg|deb|rpm|zip|tar\.gz|appimage)$ */
  binary_file: Blob;
  /** @nullable */
  installer_file?: Blob | null;
  /** List of supported operating systems */
  supported_os?: unknown;
  /** Minimum system requirements */
  min_requirements?: unknown;
  /** Recommended system requirements */
  recommended_requirements?: unknown;
  is_active?: boolean;
  is_beta?: boolean;
  is_stable?: boolean;
  is_signed?: boolean;
  /**
   * @nullable
   * @pattern (?:sig|asc|sign)$
   */
  signature_file?: Blob | null;
  released_at?: string;
}

export interface Subscription {
  readonly id: string;
  readonly user: string;
  /** @nullable */
  plan?: string | null;
  readonly plan_detail: Plan;
  status?: SubscriptionStatusEnum;
  readonly started_at: string;
  /** @nullable */
  readonly current_period_start: string | null;
  /** @nullable */
  readonly current_period_end: string | null;
  /** @nullable */
  readonly canceled_at: string | null;
  /** @nullable */
  ended_at?: string | null;
  cancel_at_period_end?: boolean;
  /** @nullable */
  readonly gateway: string | null;
  /** @nullable */
  readonly gateway_subscription_id: string | null;
  metadata?: unknown;
  readonly created_at: string;
  readonly updated_at: string;
}

export interface SubscriptionRequest {
  /** @nullable */
  plan?: string | null;
  status?: SubscriptionStatusEnum;
  /** @nullable */
  ended_at?: string | null;
  cancel_at_period_end?: boolean;
  metadata?: unknown;
}

/**
 * * `ACTIVE` - Active
* `CANCELLED` - Cancelled
* `EXPIRED` - Expired
* `SUSPENDED` - Suspended
* `PENDING` - Pending
 */
export type SubscriptionStatusEnum = typeof SubscriptionStatusEnum[keyof typeof SubscriptionStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubscriptionStatusEnum = {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING',
} as const;

export interface TokenRefresh {
  readonly access: string;
  refresh: string;
}

export interface TokenRefreshRequest {
  /** @minLength 1 */
  refresh: string;
}

export interface TokenVerifyRequest {
  /** @minLength 1 */
  token: string;
}

/**
 * Serializer for user transaction history, including invoice details.
 */
export interface Transaction {
  readonly id: string;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  readonly amount: string;
  readonly currency: string;
  readonly status: TransactionStatusEnum;
  readonly created_at: string;
  readonly invoice_number: string;
  readonly invoice_id: string;
}

/**
 * * `PENDING` - Pending
* `PROCESSING` - Processing
* `COMPLETED` - Completed
* `FAILED` - Failed
* `REFUNDED` - Refunded
* `CANCELLED` - Cancelled
 */
export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionStatusEnum = {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED',
} as const;

/**
 * Serializer for User model (used by UserViewSet).
 */
export interface User {
  readonly id: string;
  /** @maxLength 254 */
  email: string;
  /** @maxLength 150 */
  first_name?: string;
  /** @maxLength 150 */
  last_name?: string;
  role?: RoleEnum;
  /** @maxLength 255 */
  company?: string;
  /** @maxLength 20 */
  phone?: string;
  is_active?: boolean;
  readonly date_joined: string;
  readonly updated_at: string;
  /** @nullable */
  readonly last_login: string | null;
}

export interface UserRegistration {
  /** @maxLength 254 */
  email: string;
  role?: RoleEnum;
  /** @maxLength 150 */
  first_name: string;
  /** @maxLength 150 */
  last_name: string;
  /** @maxLength 255 */
  company?: string;
  /** @maxLength 20 */
  phone?: string;
}

export interface UserRegistrationRequest {
  /**
   * @minLength 1
   * @maxLength 254
   */
  email: string;
  /** @minLength 1 */
  password: string;
  /** @minLength 1 */
  password2: string;
  role?: RoleEnum;
  /** @maxLength 150 */
  first_name: string;
  /** @maxLength 150 */
  last_name: string;
  /** @maxLength 255 */
  company?: string;
  /** @maxLength 20 */
  phone?: string;
}

/**
 * Serializer for User model (used by UserViewSet).
 */
export interface UserRequest {
  /**
   * @minLength 1
   * @maxLength 254
   */
  email: string;
  /** @maxLength 150 */
  first_name?: string;
  /** @maxLength 150 */
  last_name?: string;
  role?: RoleEnum;
  /** @maxLength 255 */
  company?: string;
  /** @maxLength 20 */
  phone?: string;
  is_active?: boolean;
}

/**
 * Serializer for user sessions.
 */
export interface UserSession {
  readonly id: number;
  readonly device_fingerprint: string;
  readonly device_type: string;
  readonly is_current: string;
  readonly ip_address: string;
  readonly location: string;
  readonly user_agent: string;
  readonly last_activity: string;
  readonly created_at: string;
  readonly is_active: boolean;
}

export interface ValidateActivation {
  activation_code: string;
  /** @pattern ^[-a-zA-Z0-9_]+$ */
  software_slug: string;
  device_fingerprint?: string;
  check_only?: boolean;
}

export interface ValidateActivationRequest {
  /** @minLength 1 */
  activation_code: string;
  /**
   * @minLength 1
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  software_slug: string;
  device_fingerprint?: string;
  check_only?: boolean;
}

export type CohortsListParams = {
cohort_date?: string;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * * `week` - Week
* `month` - Month
 */
period?: CohortsListPeriod;
period_number?: number;
};

export type CohortsListPeriod = typeof CohortsListPeriod[keyof typeof CohortsListPeriod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CohortsListPeriod = {
  month: 'month',
  week: 'week',
} as const;

export type DailyListParams = {
date?: string;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
};

export type ExportsListParams = {
/**
 * * `daily_aggregates` - Daily Aggregates
* `users` - Users
* `payments` - Payments
* `licenses` - Licenses
 */
export_type?: ExportsListExportType;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * * `pending` - Pending
* `processing` - Processing
* `completed` - Completed
* `failed` - Failed
 */
status?: ExportsListStatus;
};

export type ExportsListExportType = typeof ExportsListExportType[keyof typeof ExportsListExportType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExportsListExportType = {
  daily_aggregates: 'daily_aggregates',
  licenses: 'licenses',
  payments: 'payments',
  users: 'users',
} as const;

export type ExportsListStatus = typeof ExportsListStatus[keyof typeof ExportsListStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExportsListStatus = {
  completed: 'completed',
  failed: 'failed',
  pending: 'pending',
  processing: 'processing',
} as const;

export type ExportsDownloadRetrieve200 = {[key: string]: unknown};

export type ExportsDownloadRetrieve403 = {[key: string]: unknown};

export type ExportsDownloadRetrieve404 = {[key: string]: unknown};

export type ExportsDownloadRetrieve500 = {[key: string]: unknown};

export type V1AuthActionsListParams = {
/**
 * * `USER_CREATED` - User created
* `USER_UPDATED` - User updated
* `USER_DELETED` - User deleted
* `USER_BLOCKED` - User blocked
* `USER_UNBLOCKED` - User unblocked
* `LICENSE_GENERATED` - License generated
* `LICENSE_REVOKED` - License revoked
* `LICENSE_UPDATED` - License updated
* `PAYMENT_APPROVED` - Payment approved
* `PAYMENT_REJECTED` - Payment rejected
* `SOFTWARE_ADDED` - Software added
* `SOFTWARE_UPDATED` - Software updated
* `SOFTWARE_DELETED` - Software deleted
* `SETTINGS_UPDATED` - Settings updated
* `ACTION_UNDONE` - Action undone
* `MFA_USAGE` - MFA usage
 */
action_type?: V1AuthActionsListActionType;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
user?: string;
};

export type V1AuthActionsListActionType = typeof V1AuthActionsListActionType[keyof typeof V1AuthActionsListActionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1AuthActionsListActionType = {
  ACTION_UNDONE: 'ACTION_UNDONE',
  LICENSE_GENERATED: 'LICENSE_GENERATED',
  LICENSE_REVOKED: 'LICENSE_REVOKED',
  LICENSE_UPDATED: 'LICENSE_UPDATED',
  MFA_USAGE: 'MFA_USAGE',
  PAYMENT_APPROVED: 'PAYMENT_APPROVED',
  PAYMENT_REJECTED: 'PAYMENT_REJECTED',
  SETTINGS_UPDATED: 'SETTINGS_UPDATED',
  SOFTWARE_ADDED: 'SOFTWARE_ADDED',
  SOFTWARE_DELETED: 'SOFTWARE_DELETED',
  SOFTWARE_UPDATED: 'SOFTWARE_UPDATED',
  USER_BLOCKED: 'USER_BLOCKED',
  USER_CREATED: 'USER_CREATED',
  USER_DELETED: 'USER_DELETED',
  USER_UNBLOCKED: 'USER_UNBLOCKED',
  USER_UPDATED: 'USER_UPDATED',
} as const;

export type V1AuthAdminProfilesListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
user?: string;
};

export type V1AuthSessionsListParams = {
is_active?: boolean;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1AuthUsersListParams = {
is_active?: boolean;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * * `USER` - User
* `ADMIN` - Admin
* `SUPER_ADMIN` - Super Admin
 */
role?: V1AuthUsersListRole;
/**
 * A search term.
 */
search?: string;
};

export type V1AuthUsersListRole = typeof V1AuthUsersListRole[keyof typeof V1AuthUsersListRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1AuthUsersListRole = {
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN',
  USER: 'USER',
} as const;

export type V1LicensesActivationCodesListParams = {
generated_by?: string;
/**
 * * `TRIAL` - Trial
* `STANDARD` - Standard
* `PREMIUM` - Premium
* `ENTERPRISE` - Enterprise
* `LIFETIME` - Lifetime
 */
license_type?: V1LicensesActivationCodesListLicenseType;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
software?: string;
/**
 * * `GENERATED` - Generated
* `ACTIVATED` - Activated
* `REVOKED` - Revoked
* `EXPIRED` - Expired
* `SUSPENDED` - Suspended
 */
status?: V1LicensesActivationCodesListStatus;
user?: string;
};

export type V1LicensesActivationCodesListLicenseType = typeof V1LicensesActivationCodesListLicenseType[keyof typeof V1LicensesActivationCodesListLicenseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LicensesActivationCodesListLicenseType = {
  ENTERPRISE: 'ENTERPRISE',
  LIFETIME: 'LIFETIME',
  PREMIUM: 'PREMIUM',
  STANDARD: 'STANDARD',
  TRIAL: 'TRIAL',
} as const;

export type V1LicensesActivationCodesListStatus = typeof V1LicensesActivationCodesListStatus[keyof typeof V1LicensesActivationCodesListStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LicensesActivationCodesListStatus = {
  ACTIVATED: 'ACTIVATED',
  EXPIRED: 'EXPIRED',
  GENERATED: 'GENERATED',
  REVOKED: 'REVOKED',
  SUSPENDED: 'SUSPENDED',
} as const;

export type V1LicensesBatchesListParams = {
is_used?: boolean;
/**
 * * `TRIAL` - Trial
* `STANDARD` - Standard
* `PREMIUM` - Premium
* `ENTERPRISE` - Enterprise
* `LIFETIME` - Lifetime
 */
license_type?: V1LicensesBatchesListLicenseType;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
software?: string;
};

export type V1LicensesBatchesListLicenseType = typeof V1LicensesBatchesListLicenseType[keyof typeof V1LicensesBatchesListLicenseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LicensesBatchesListLicenseType = {
  ENTERPRISE: 'ENTERPRISE',
  LIFETIME: 'LIFETIME',
  PREMIUM: 'PREMIUM',
  STANDARD: 'STANDARD',
  TRIAL: 'TRIAL',
} as const;

export type V1LicensesFeaturesListParams = {
is_active?: boolean;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
software?: string;
};

export type V1LicensesLogsListParams = {
/**
 * * `ACTIVATE` - Activate
* `VALIDATE` - Validate
* `DEACTIVATE` - Deactivate
* `REACTIVATE` - Reactivate
* `VERIFY` - Verify
 */
action?: V1LicensesLogsListAction;
activation_code?: string;
is_suspicious?: boolean;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
success?: boolean;
};

export type V1LicensesLogsListAction = typeof V1LicensesLogsListAction[keyof typeof V1LicensesLogsListAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LicensesLogsListAction = {
  ACTIVATE: 'ACTIVATE',
  DEACTIVATE: 'DEACTIVATE',
  REACTIVATE: 'REACTIVATE',
  VALIDATE: 'VALIDATE',
  VERIFY: 'VERIFY',
} as const;

export type V1LicensesMyLicensesListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1LicensesUsageListParams = {
activation_code?: string;
device_fingerprint?: string;
feature?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type V1PaymentsCouponsListParams = {
/**
 * * `PERCENTAGE` - Percentage
* `FIXED` - Fixed Amount
 */
discount_type?: V1PaymentsCouponsListDiscountType;
is_active?: boolean;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1PaymentsCouponsListDiscountType = typeof V1PaymentsCouponsListDiscountType[keyof typeof V1PaymentsCouponsListDiscountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1PaymentsCouponsListDiscountType = {
  FIXED: 'FIXED',
  PERCENTAGE: 'PERCENTAGE',
} as const;

export type V1PaymentsInvoicesListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1PaymentsMyTransactionsListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1PaymentsPlansListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1PaymentsSubscriptionsListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsVersionsList2Params = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsCategoriesListParams = {
is_active?: boolean;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
parent?: string;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsDocumentsListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsFeaturedListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsImagesListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsNewReleasesListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsSoftwareListParams = {
/**
 * Category slug
 */
category?: string;
has_trial?: boolean;
is_active?: boolean;
is_featured?: boolean;
is_new?: boolean;
/**
 * * `PERPETUAL` - Perpetual
* `SUBSCRIPTION` - Subscription
* `TRIAL` - Trial
* `FLOATING` - Floating
* `CONCURRENT` - Concurrent
 */
license_type?: V1ProductsSoftwareListLicenseType;
max_price?: number;
min_price?: number;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * Filter by operating system (e.g., 'windows', 'linux', 'macos')
 */
os?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1ProductsSoftwareListLicenseType = typeof V1ProductsSoftwareListLicenseType[keyof typeof V1ProductsSoftwareListLicenseType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ProductsSoftwareListLicenseType = {
  CONCURRENT: 'CONCURRENT',
  FLOATING: 'FLOATING',
  PERPETUAL: 'PERPETUAL',
  SUBSCRIPTION: 'SUBSCRIPTION',
  TRIAL: 'TRIAL',
} as const;

export type V1ProductsVersionsListParams = {
is_active?: boolean;
is_beta?: boolean;
is_signed?: boolean;
is_stable?: boolean;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
software?: string;
};

export type V1abuseAttemptsListParams = {
ip_address?: string;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * Number of results to return per page.
 */
page_size?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1alertsListParams = {
acknowledged?: boolean;
/**
 * * `CRITICAL` - Critical
* `HIGH` - High
* `MEDIUM` - Medium
* `LOW` - Low
* `INFO` - Informational
 */
alert_type?: V1alertsListAlertType;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * Number of results to return per page.
 */
page_size?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1alertsListAlertType = typeof V1alertsListAlertType[keyof typeof V1alertsListAlertType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1alertsListAlertType = {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  INFO: 'INFO',
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
} as const;

export type V1codeBlacklistListParams = {
is_active?: boolean;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * Number of results to return per page.
 */
page_size?: number;
/**
 * A search term.
 */
search?: string;
/**
 * * `MANUAL` - Manual
* `AUTO` - Automatic
* `USER_REPORT` - User Report
* `LAW_ENFORCEMENT` - Law Enforcement
 */
source?: V1codeBlacklistListSource;
};

export type V1codeBlacklistListSource = typeof V1codeBlacklistListSource[keyof typeof V1codeBlacklistListSource];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1codeBlacklistListSource = {
  AUTO: 'AUTO',
  LAW_ENFORCEMENT: 'LAW_ENFORCEMENT',
  MANUAL: 'MANUAL',
  USER_REPORT: 'USER_REPORT',
} as const;

export type V1ipBlacklistListParams = {
ip_address?: string;
is_active?: boolean;
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * Number of results to return per page.
 */
page_size?: number;
/**
 * A search term.
 */
search?: string;
};

export type V1securityLogsListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * Number of results to return per page.
 */
page_size?: number;
risk_level?: number;
/**
 * A search term.
 */
search?: string;
user?: string;
};

export type DistributionMirrorsListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

export type ApiListParams = {
/**
 * Which field to use when ordering the results.
 */
ordering?: string;
/**
 * A page number within the paginated result set.
 */
page?: number;
/**
 * A search term.
 */
search?: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * List cohort aggregates, most recent first.
Supports filtering by cohort_date, period, and period_number.
 */
export const cohortsList = (
    params?: CohortsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<CohortAggregate[]>(
      {url: `http://localhost:8000/api/v1/analytics/cohorts/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCohortsListQueryKey = (params?: CohortsListParams,) => {
    return [
    `http://localhost:8000/api/v1/analytics/cohorts/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCohortsListQueryOptions = <TData = Awaited<ReturnType<typeof cohortsList>>, TError = unknown>(params?: CohortsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cohortsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCohortsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof cohortsList>>> = ({ signal }) => cohortsList(params, requestOptions, signal);

      

      

   // @ts-expect-error Orval v7.13.2 compatibility: DataTag<QueryKey, TData, TError> where TError is added for type safety
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof cohortsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CohortsListQueryResult = NonNullable<Awaited<ReturnType<typeof cohortsList>>>
export type CohortsListQueryError = unknown


export function useCohortsList<TData = Awaited<ReturnType<typeof cohortsList>>, TError = unknown>(
 params: undefined |  CohortsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof cohortsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof cohortsList>>,
          TError,
          Awaited<ReturnType<typeof cohortsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCohortsList<TData = Awaited<ReturnType<typeof cohortsList>>, TError = unknown>(
 params?: CohortsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cohortsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof cohortsList>>,
          TError,
          Awaited<ReturnType<typeof cohortsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCohortsList<TData = Awaited<ReturnType<typeof cohortsList>>, TError = unknown>(
 params?: CohortsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cohortsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCohortsList<TData = Awaited<ReturnType<typeof cohortsList>>, TError = unknown>(
 params?: CohortsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof cohortsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCohortsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List daily aggregates, most recent first.
Supports filtering by date range and ordering.
 */
export const dailyList = (
    params?: DailyListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<DailyAggregate[]>(
      {url: `http://localhost:8000/api/v1/analytics/daily/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getDailyListQueryKey = (params?: DailyListParams,) => {
    return [
    `http://localhost:8000/api/v1/analytics/daily/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getDailyListQueryOptions = <TData = Awaited<ReturnType<typeof dailyList>>, TError = unknown>(params?: DailyListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDailyListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyList>>> = ({ signal }) => dailyList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dailyList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DailyListQueryResult = NonNullable<Awaited<ReturnType<typeof dailyList>>>
export type DailyListQueryError = unknown


export function useDailyList<TData = Awaited<ReturnType<typeof dailyList>>, TError = unknown>(
 params: undefined |  DailyListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dailyList>>,
          TError,
          Awaited<ReturnType<typeof dailyList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyList<TData = Awaited<ReturnType<typeof dailyList>>, TError = unknown>(
 params?: DailyListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dailyList>>,
          TError,
          Awaited<ReturnType<typeof dailyList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyList<TData = Awaited<ReturnType<typeof dailyList>>, TError = unknown>(
 params?: DailyListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyList<TData = Awaited<ReturnType<typeof dailyList>>, TError = unknown>(
 params?: DailyListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDailyListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific day's aggregate.
Accepts primary key or date (via lookup_field customization).
 */
export const dailyRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<DailyAggregate>(
      {url: `http://localhost:8000/api/v1/analytics/daily/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getDailyRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/analytics/daily/${id}/`
    ] as const;
    }

    
export const getDailyRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof dailyRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDailyRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dailyRetrieve>>> = ({ signal }) => dailyRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dailyRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DailyRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof dailyRetrieve>>>
export type DailyRetrieveQueryError = unknown


export function useDailyRetrieve<TData = Awaited<ReturnType<typeof dailyRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dailyRetrieve>>,
          TError,
          Awaited<ReturnType<typeof dailyRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyRetrieve<TData = Awaited<ReturnType<typeof dailyRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dailyRetrieve>>,
          TError,
          Awaited<ReturnType<typeof dailyRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDailyRetrieve<TData = Awaited<ReturnType<typeof dailyRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDailyRetrieve<TData = Awaited<ReturnType<typeof dailyRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dailyRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDailyRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List all export jobs for the current user (admin sees all).
Also allows creating a new export job (POST).
 */
export const exportsList = (
    params?: ExportsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedExportJobList>(
      {url: `http://localhost:8000/api/v1/analytics/exports/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getExportsListQueryKey = (params?: ExportsListParams,) => {
    return [
    `http://localhost:8000/api/v1/analytics/exports/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getExportsListQueryOptions = <TData = Awaited<ReturnType<typeof exportsList>>, TError = unknown>(params?: ExportsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExportsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exportsList>>> = ({ signal }) => exportsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exportsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExportsListQueryResult = NonNullable<Awaited<ReturnType<typeof exportsList>>>
export type ExportsListQueryError = unknown


export function useExportsList<TData = Awaited<ReturnType<typeof exportsList>>, TError = unknown>(
 params: undefined |  ExportsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportsList>>,
          TError,
          Awaited<ReturnType<typeof exportsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportsList<TData = Awaited<ReturnType<typeof exportsList>>, TError = unknown>(
 params?: ExportsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportsList>>,
          TError,
          Awaited<ReturnType<typeof exportsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportsList<TData = Awaited<ReturnType<typeof exportsList>>, TError = unknown>(
 params?: ExportsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useExportsList<TData = Awaited<ReturnType<typeof exportsList>>, TError = unknown>(
 params?: ExportsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExportsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List all export jobs for the current user (admin sees all).
Also allows creating a new export job (POST).
 */
export const exportsCreate = (
    exportJobRequest: ExportJobRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ExportJob>(
      {url: `http://localhost:8000/api/v1/analytics/exports/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: exportJobRequest, signal
    },
      options);
    }
  


export const getExportsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof exportsCreate>>, TError,{data: ExportJobRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof exportsCreate>>, TError,{data: ExportJobRequest}, TContext> => {

const mutationKey = ['exportsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof exportsCreate>>, {data: ExportJobRequest}> = (props) => {
          const {data} = props ?? {};

          return  exportsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExportsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof exportsCreate>>>
    export type ExportsCreateMutationBody = ExportJobRequest
    export type ExportsCreateMutationError = unknown

    export const useExportsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof exportsCreate>>, TError,{data: ExportJobRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof exportsCreate>>,
        TError,
        {data: ExportJobRequest},
        TContext
      > => {

      const mutationOptions = getExportsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve details of a specific export job.
 */
export const exportsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ExportJob>(
      {url: `http://localhost:8000/api/v1/analytics/exports/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getExportsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/analytics/exports/${id}/`
    ] as const;
    }

    
export const getExportsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof exportsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExportsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exportsRetrieve>>> = ({ signal }) => exportsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exportsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof exportsRetrieve>>>
export type ExportsRetrieveQueryError = unknown


export function useExportsRetrieve<TData = Awaited<ReturnType<typeof exportsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof exportsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportsRetrieve<TData = Awaited<ReturnType<typeof exportsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof exportsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportsRetrieve<TData = Awaited<ReturnType<typeof exportsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useExportsRetrieve<TData = Awaited<ReturnType<typeof exportsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExportsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Securely download the exported file. Returns either the file (binary) or a JSON with a download URL when using S3.
 */
export const exportsDownloadRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ExportsDownloadRetrieve200>(
      {url: `http://localhost:8000/api/v1/analytics/exports/${id}/download/`, method: 'GET', signal
    },
      options);
    }
  



export const getExportsDownloadRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/analytics/exports/${id}/download/`
    ] as const;
    }

    
export const getExportsDownloadRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError = ExportsDownloadRetrieve403 | ExportsDownloadRetrieve404 | ExportsDownloadRetrieve500>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExportsDownloadRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof exportsDownloadRetrieve>>> = ({ signal }) => exportsDownloadRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExportsDownloadRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof exportsDownloadRetrieve>>>
export type ExportsDownloadRetrieveQueryError = ExportsDownloadRetrieve403 | ExportsDownloadRetrieve404 | ExportsDownloadRetrieve500


export function useExportsDownloadRetrieve<TData = Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError = ExportsDownloadRetrieve403 | ExportsDownloadRetrieve404 | ExportsDownloadRetrieve500>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof exportsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportsDownloadRetrieve<TData = Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError = ExportsDownloadRetrieve403 | ExportsDownloadRetrieve404 | ExportsDownloadRetrieve500>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof exportsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof exportsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExportsDownloadRetrieve<TData = Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError = ExportsDownloadRetrieve403 | ExportsDownloadRetrieve404 | ExportsDownloadRetrieve500>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useExportsDownloadRetrieve<TData = Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError = ExportsDownloadRetrieve403 | ExportsDownloadRetrieve404 | ExportsDownloadRetrieve500>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof exportsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExportsDownloadRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Regenerate emergency backup codes.
 */
export const v1Auth2faEmergencyRegenerateBackupCodesCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/2fa/emergency/regenerate-backup-codes/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1Auth2faEmergencyRegenerateBackupCodesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencyRegenerateBackupCodesCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencyRegenerateBackupCodesCreate>>, TError,void, TContext> => {

const mutationKey = ['v1Auth2faEmergencyRegenerateBackupCodesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1Auth2faEmergencyRegenerateBackupCodesCreate>>, void> = () => {
          

          return  v1Auth2faEmergencyRegenerateBackupCodesCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1Auth2faEmergencyRegenerateBackupCodesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1Auth2faEmergencyRegenerateBackupCodesCreate>>>
    
    export type V1Auth2faEmergencyRegenerateBackupCodesCreateMutationError = unknown

    export const useV1Auth2faEmergencyRegenerateBackupCodesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencyRegenerateBackupCodesCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1Auth2faEmergencyRegenerateBackupCodesCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1Auth2faEmergencyRegenerateBackupCodesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Setup emergency 2FA (TOTP) for the authenticated user.
- Now requires a verification step: after generating secret, user must
  provide a valid TOTP code before MFA is enabled.
- Backward‚Äëcompatible: POST with {'code': '123456'} after initial POST.
 */
export const v1Auth2faEmergencySetupRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/2fa/emergency/setup/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1Auth2faEmergencySetupRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/2fa/emergency/setup/`
    ] as const;
    }

    
export const getV1Auth2faEmergencySetupRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1Auth2faEmergencySetupRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>> = ({ signal }) => v1Auth2faEmergencySetupRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1Auth2faEmergencySetupRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>>
export type V1Auth2faEmergencySetupRetrieveQueryError = unknown


export function useV1Auth2faEmergencySetupRetrieve<TData = Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1Auth2faEmergencySetupRetrieve<TData = Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1Auth2faEmergencySetupRetrieve<TData = Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1Auth2faEmergencySetupRetrieve<TData = Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1Auth2faEmergencySetupRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Setup emergency 2FA (TOTP) for the authenticated user.
- Now requires a verification step: after generating secret, user must
  provide a valid TOTP code before MFA is enabled.
- Backward‚Äëcompatible: POST with {'code': '123456'} after initial POST.
 */
export const v1Auth2faEmergencySetupCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/2fa/emergency/setup/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1Auth2faEmergencySetupCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupCreate>>, TError,void, TContext> => {

const mutationKey = ['v1Auth2faEmergencySetupCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1Auth2faEmergencySetupCreate>>, void> = () => {
          

          return  v1Auth2faEmergencySetupCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1Auth2faEmergencySetupCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1Auth2faEmergencySetupCreate>>>
    
    export type V1Auth2faEmergencySetupCreateMutationError = unknown

    export const useV1Auth2faEmergencySetupCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1Auth2faEmergencySetupCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1Auth2faEmergencySetupCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Setup emergency 2FA (TOTP) for the authenticated user.
- Now requires a verification step: after generating secret, user must
  provide a valid TOTP code before MFA is enabled.
- Backward‚Äëcompatible: POST with {'code': '123456'} after initial POST.
 */
export const v1Auth2faEmergencySetupDestroy = (
    
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/2fa/emergency/setup/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1Auth2faEmergencySetupDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupDestroy>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupDestroy>>, TError,void, TContext> => {

const mutationKey = ['v1Auth2faEmergencySetupDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1Auth2faEmergencySetupDestroy>>, void> = () => {
          

          return  v1Auth2faEmergencySetupDestroy(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1Auth2faEmergencySetupDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1Auth2faEmergencySetupDestroy>>>
    
    export type V1Auth2faEmergencySetupDestroyMutationError = unknown

    export const useV1Auth2faEmergencySetupDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencySetupDestroy>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1Auth2faEmergencySetupDestroy>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1Auth2faEmergencySetupDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Verify emergency 2FA code for suspicious login attempts.
- Replay protection: verification_token is single‚Äëuse (jti cached).
- No sensitive data returned.
 */
export const v1Auth2faEmergencyVerifyCreate = (
    emergencyTwoFactorVerifyRequest: EmergencyTwoFactorVerifyRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<EmergencyTwoFactorVerify>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/2fa/emergency/verify/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: emergencyTwoFactorVerifyRequest, signal
    },
      options);
    }
  


export const getV1Auth2faEmergencyVerifyCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencyVerifyCreate>>, TError,{data: EmergencyTwoFactorVerifyRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencyVerifyCreate>>, TError,{data: EmergencyTwoFactorVerifyRequest}, TContext> => {

const mutationKey = ['v1Auth2faEmergencyVerifyCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1Auth2faEmergencyVerifyCreate>>, {data: EmergencyTwoFactorVerifyRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1Auth2faEmergencyVerifyCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1Auth2faEmergencyVerifyCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1Auth2faEmergencyVerifyCreate>>>
    export type V1Auth2faEmergencyVerifyCreateMutationBody = EmergencyTwoFactorVerifyRequest
    export type V1Auth2faEmergencyVerifyCreateMutationError = unknown

    export const useV1Auth2faEmergencyVerifyCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1Auth2faEmergencyVerifyCreate>>, TError,{data: EmergencyTwoFactorVerifyRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1Auth2faEmergencyVerifyCreate>>,
        TError,
        {data: EmergencyTwoFactorVerifyRequest},
        TContext
      > => {

      const mutationOptions = getV1Auth2faEmergencyVerifyCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List admin action logs
 */
export const v1AuthActionsList = (
    params?: V1AuthActionsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedAdminActionLogList>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/actions/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1AuthActionsListQueryKey = (params?: V1AuthActionsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/actions/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1AuthActionsListQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthActionsList>>, TError = unknown>(params?: V1AuthActionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthActionsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthActionsList>>> = ({ signal }) => v1AuthActionsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthActionsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthActionsList>>>
export type V1AuthActionsListQueryError = unknown


export function useV1AuthActionsList<TData = Awaited<ReturnType<typeof v1AuthActionsList>>, TError = unknown>(
 params: undefined |  V1AuthActionsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthActionsList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthActionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthActionsList<TData = Awaited<ReturnType<typeof v1AuthActionsList>>, TError = unknown>(
 params?: V1AuthActionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthActionsList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthActionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthActionsList<TData = Awaited<ReturnType<typeof v1AuthActionsList>>, TError = unknown>(
 params?: V1AuthActionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthActionsList<TData = Awaited<ReturnType<typeof v1AuthActionsList>>, TError = unknown>(
 params?: V1AuthActionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthActionsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve an action log entry
 */
export const v1AuthActionsRetrieve = (
    id: number,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<AdminActionLog>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/actions/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthActionsRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/actions/${id}/`
    ] as const;
    }

    
export const getV1AuthActionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthActionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>> = ({ signal }) => v1AuthActionsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthActionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>>
export type V1AuthActionsRetrieveQueryError = unknown


export function useV1AuthActionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthActionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthActionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthActionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthActionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthActionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthActionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthActionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthActionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthActionsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List all admin profiles
 */
export const v1AuthAdminProfilesList = (
    params?: V1AuthAdminProfilesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedAdminProfileList>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1AuthAdminProfilesListQueryKey = (params?: V1AuthAdminProfilesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1AuthAdminProfilesListQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError = unknown>(params?: V1AuthAdminProfilesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthAdminProfilesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>> = ({ signal }) => v1AuthAdminProfilesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthAdminProfilesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>>
export type V1AuthAdminProfilesListQueryError = unknown


export function useV1AuthAdminProfilesList<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError = unknown>(
 params: undefined |  V1AuthAdminProfilesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthAdminProfilesList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthAdminProfilesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthAdminProfilesList<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError = unknown>(
 params?: V1AuthAdminProfilesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthAdminProfilesList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthAdminProfilesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthAdminProfilesList<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError = unknown>(
 params?: V1AuthAdminProfilesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthAdminProfilesList<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError = unknown>(
 params?: V1AuthAdminProfilesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthAdminProfilesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create an admin profile
 */
export const v1AuthAdminProfilesCreate = (
    adminProfileRequest: AdminProfileRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<AdminProfile>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: adminProfileRequest, signal
    },
      options);
    }
  


export const getV1AuthAdminProfilesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesCreate>>, TError,{data: AdminProfileRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesCreate>>, TError,{data: AdminProfileRequest}, TContext> => {

const mutationKey = ['v1AuthAdminProfilesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthAdminProfilesCreate>>, {data: AdminProfileRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthAdminProfilesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthAdminProfilesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthAdminProfilesCreate>>>
    export type V1AuthAdminProfilesCreateMutationBody = AdminProfileRequest
    export type V1AuthAdminProfilesCreateMutationError = unknown

    export const useV1AuthAdminProfilesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesCreate>>, TError,{data: AdminProfileRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthAdminProfilesCreate>>,
        TError,
        {data: AdminProfileRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthAdminProfilesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve an admin profile
 */
export const v1AuthAdminProfilesRetrieve = (
    user: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<AdminProfile>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/${user}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthAdminProfilesRetrieveQueryKey = (user?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/${user}/`
    ] as const;
    }

    
export const getV1AuthAdminProfilesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError = unknown>(user: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthAdminProfilesRetrieveQueryKey(user);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>> = ({ signal }) => v1AuthAdminProfilesRetrieve(user, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(user), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthAdminProfilesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>>
export type V1AuthAdminProfilesRetrieveQueryError = unknown


export function useV1AuthAdminProfilesRetrieve<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError = unknown>(
 user: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthAdminProfilesRetrieve<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError = unknown>(
 user: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthAdminProfilesRetrieve<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError = unknown>(
 user: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthAdminProfilesRetrieve<TData = Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError = unknown>(
 user: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthAdminProfilesRetrieveQueryOptions(user,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an admin profile
 */
export const v1AuthAdminProfilesUpdate = (
    user: string,
    adminProfileRequest: AdminProfileRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<AdminProfile>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/${user}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: adminProfileRequest
    },
      options);
    }
  


export const getV1AuthAdminProfilesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesUpdate>>, TError,{user: string;data: AdminProfileRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesUpdate>>, TError,{user: string;data: AdminProfileRequest}, TContext> => {

const mutationKey = ['v1AuthAdminProfilesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthAdminProfilesUpdate>>, {user: string;data: AdminProfileRequest}> = (props) => {
          const {user,data} = props ?? {};

          return  v1AuthAdminProfilesUpdate(user,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthAdminProfilesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthAdminProfilesUpdate>>>
    export type V1AuthAdminProfilesUpdateMutationBody = AdminProfileRequest
    export type V1AuthAdminProfilesUpdateMutationError = unknown

    export const useV1AuthAdminProfilesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesUpdate>>, TError,{user: string;data: AdminProfileRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthAdminProfilesUpdate>>,
        TError,
        {user: string;data: AdminProfileRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthAdminProfilesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Partially update an admin profile
 */
export const v1AuthAdminProfilesPartialUpdate = (
    user: string,
    patchedAdminProfileRequest: PatchedAdminProfileRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<AdminProfile>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/${user}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAdminProfileRequest
    },
      options);
    }
  


export const getV1AuthAdminProfilesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesPartialUpdate>>, TError,{user: string;data: PatchedAdminProfileRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesPartialUpdate>>, TError,{user: string;data: PatchedAdminProfileRequest}, TContext> => {

const mutationKey = ['v1AuthAdminProfilesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthAdminProfilesPartialUpdate>>, {user: string;data: PatchedAdminProfileRequest}> = (props) => {
          const {user,data} = props ?? {};

          return  v1AuthAdminProfilesPartialUpdate(user,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthAdminProfilesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthAdminProfilesPartialUpdate>>>
    export type V1AuthAdminProfilesPartialUpdateMutationBody = PatchedAdminProfileRequest
    export type V1AuthAdminProfilesPartialUpdateMutationError = unknown

    export const useV1AuthAdminProfilesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesPartialUpdate>>, TError,{user: string;data: PatchedAdminProfileRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthAdminProfilesPartialUpdate>>,
        TError,
        {user: string;data: PatchedAdminProfileRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthAdminProfilesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete an admin profile
 */
export const v1AuthAdminProfilesDestroy = (
    user: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/admin-profiles/${user}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1AuthAdminProfilesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesDestroy>>, TError,{user: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesDestroy>>, TError,{user: string}, TContext> => {

const mutationKey = ['v1AuthAdminProfilesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthAdminProfilesDestroy>>, {user: string}> = (props) => {
          const {user} = props ?? {};

          return  v1AuthAdminProfilesDestroy(user,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthAdminProfilesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthAdminProfilesDestroy>>>
    
    export type V1AuthAdminProfilesDestroyMutationError = unknown

    export const useV1AuthAdminProfilesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthAdminProfilesDestroy>>, TError,{user: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthAdminProfilesDestroy>>,
        TError,
        {user: string},
        TContext
      > => {

      const mutationOptions = getV1AuthAdminProfilesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Change password for authenticated users.
 */
export const v1AuthChangePasswordCreate = (
    changePasswordRequest: ChangePasswordRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/change-password/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: changePasswordRequest, signal
    },
      options);
    }
  


export const getV1AuthChangePasswordCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthChangePasswordCreate>>, TError,{data: ChangePasswordRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthChangePasswordCreate>>, TError,{data: ChangePasswordRequest}, TContext> => {

const mutationKey = ['v1AuthChangePasswordCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthChangePasswordCreate>>, {data: ChangePasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthChangePasswordCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthChangePasswordCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthChangePasswordCreate>>>
    export type V1AuthChangePasswordCreateMutationBody = ChangePasswordRequest
    export type V1AuthChangePasswordCreateMutationError = unknown

    export const useV1AuthChangePasswordCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthChangePasswordCreate>>, TError,{data: ChangePasswordRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthChangePasswordCreate>>,
        TError,
        {data: ChangePasswordRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthChangePasswordCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Confirm device verification using token and code from email.
Completes the device change flow.
 */
export const v1AuthDeviceVerifyConfirmCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/device/verify/confirm/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1AuthDeviceVerifyConfirmCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthDeviceVerifyConfirmCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthDeviceVerifyConfirmCreate>>, TError,void, TContext> => {

const mutationKey = ['v1AuthDeviceVerifyConfirmCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthDeviceVerifyConfirmCreate>>, void> = () => {
          

          return  v1AuthDeviceVerifyConfirmCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthDeviceVerifyConfirmCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthDeviceVerifyConfirmCreate>>>
    
    export type V1AuthDeviceVerifyConfirmCreateMutationError = unknown

    export const useV1AuthDeviceVerifyConfirmCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthDeviceVerifyConfirmCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthDeviceVerifyConfirmCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1AuthDeviceVerifyConfirmCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Manage user's trusted devices and active sessions.
 */
export const v1AuthDevicesRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/devices/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthDevicesRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/devices/`
    ] as const;
    }

    
export const getV1AuthDevicesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthDevicesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>> = ({ signal }) => v1AuthDevicesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthDevicesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>>
export type V1AuthDevicesRetrieveQueryError = unknown


export function useV1AuthDevicesRetrieve<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthDevicesRetrieve<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthDevicesRetrieve<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthDevicesRetrieve<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthDevicesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Manage user's trusted devices and active sessions.
 */
export const v1AuthDevicesDestroy = (
    
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/devices/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1AuthDevicesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthDevicesDestroy>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthDevicesDestroy>>, TError,void, TContext> => {

const mutationKey = ['v1AuthDevicesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthDevicesDestroy>>, void> = () => {
          

          return  v1AuthDevicesDestroy(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthDevicesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthDevicesDestroy>>>
    
    export type V1AuthDevicesDestroyMutationError = unknown

    export const useV1AuthDevicesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthDevicesDestroy>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthDevicesDestroy>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1AuthDevicesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Manage user's trusted devices and active sessions.
 */
export const v1AuthDevicesRetrieve2 = (
    sessionId: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/devices/${sessionId}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthDevicesRetrieve2QueryKey = (sessionId?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/devices/${sessionId}/`
    ] as const;
    }

    
export const getV1AuthDevicesRetrieve2QueryOptions = <TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError = unknown>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthDevicesRetrieve2QueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>> = ({ signal }) => v1AuthDevicesRetrieve2(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthDevicesRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>>
export type V1AuthDevicesRetrieve2QueryError = unknown


export function useV1AuthDevicesRetrieve2<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError = unknown>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthDevicesRetrieve2<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError = unknown>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthDevicesRetrieve2<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError = unknown>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthDevicesRetrieve2<TData = Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError = unknown>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthDevicesRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthDevicesRetrieve2QueryOptions(sessionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Manage user's trusted devices and active sessions.
 */
export const v1AuthDevicesDestroy2 = (
    sessionId: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/devices/${sessionId}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1AuthDevicesDestroy2MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthDevicesDestroy2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthDevicesDestroy2>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['v1AuthDevicesDestroy2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthDevicesDestroy2>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  v1AuthDevicesDestroy2(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthDevicesDestroy2MutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthDevicesDestroy2>>>
    
    export type V1AuthDevicesDestroy2MutationError = unknown

    export const useV1AuthDevicesDestroy2 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthDevicesDestroy2>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthDevicesDestroy2>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getV1AuthDevicesDestroy2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Custom login view with device fingerprinting, security checks,
and risk‚Äëbased emergency 2FA. No longer returns risk reasons to client.
 */
export const v1AuthLoginCreate = (
    customTokenObtainPairRequest: CustomTokenObtainPairRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<CustomTokenObtainPair>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/login/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: customTokenObtainPairRequest, signal
    },
      options);
    }
  


export const getV1AuthLoginCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthLoginCreate>>, TError,{data: CustomTokenObtainPairRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthLoginCreate>>, TError,{data: CustomTokenObtainPairRequest}, TContext> => {

const mutationKey = ['v1AuthLoginCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthLoginCreate>>, {data: CustomTokenObtainPairRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthLoginCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthLoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthLoginCreate>>>
    export type V1AuthLoginCreateMutationBody = CustomTokenObtainPairRequest
    export type V1AuthLoginCreateMutationError = unknown

    export const useV1AuthLoginCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthLoginCreate>>, TError,{data: CustomTokenObtainPairRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthLoginCreate>>,
        TError,
        {data: CustomTokenObtainPairRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthLoginCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Logout view.
 */
export const v1AuthLogoutCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/logout/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1AuthLogoutCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthLogoutCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthLogoutCreate>>, TError,void, TContext> => {

const mutationKey = ['v1AuthLogoutCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthLogoutCreate>>, void> = () => {
          

          return  v1AuthLogoutCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthLogoutCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthLogoutCreate>>>
    
    export type V1AuthLogoutCreateMutationError = unknown

    export const useV1AuthLogoutCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthLogoutCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthLogoutCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1AuthLogoutCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Return the user's current notification preferences.
 */
export const v1AuthPreferencesRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/preferences/notifications/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthPreferencesRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/preferences/notifications/`
    ] as const;
    }

    
export const getV1AuthPreferencesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthPreferencesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>> = ({ signal }) => v1AuthPreferencesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthPreferencesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>>
export type V1AuthPreferencesRetrieveQueryError = unknown


export function useV1AuthPreferencesRetrieve<TData = Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthPreferencesRetrieve<TData = Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthPreferencesRetrieve<TData = Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthPreferencesRetrieve<TData = Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthPreferencesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthPreferencesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update notification preferences.
Merges incoming data with existing preferences, validates the combined result,
and saves if valid. Returns the updated preferences.
 */
export const v1AuthPreferencesCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/preferences/notifications/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1AuthPreferencesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthPreferencesCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthPreferencesCreate>>, TError,void, TContext> => {

const mutationKey = ['v1AuthPreferencesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthPreferencesCreate>>, void> = () => {
          

          return  v1AuthPreferencesCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthPreferencesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthPreferencesCreate>>>
    
    export type V1AuthPreferencesCreateMutationError = unknown

    export const useV1AuthPreferencesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthPreferencesCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthPreferencesCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1AuthPreferencesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * User registration endpoint.
 */
export const v1AuthRegisterCreate = (
    userRegistrationRequest: UserRegistrationRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<UserRegistration>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/register/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userRegistrationRequest, signal
    },
      options);
    }
  


export const getV1AuthRegisterCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthRegisterCreate>>, TError,{data: UserRegistrationRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthRegisterCreate>>, TError,{data: UserRegistrationRequest}, TContext> => {

const mutationKey = ['v1AuthRegisterCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthRegisterCreate>>, {data: UserRegistrationRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthRegisterCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthRegisterCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthRegisterCreate>>>
    export type V1AuthRegisterCreateMutationBody = UserRegistrationRequest
    export type V1AuthRegisterCreateMutationError = unknown

    export const useV1AuthRegisterCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthRegisterCreate>>, TError,{data: UserRegistrationRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthRegisterCreate>>,
        TError,
        {data: UserRegistrationRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthRegisterCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Password reset request.
 */
export const v1AuthResetPasswordCreate = (
    passwordResetRequestRequest: PasswordResetRequestRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PasswordResetRequest>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/reset-password/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordResetRequestRequest, signal
    },
      options);
    }
  


export const getV1AuthResetPasswordCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthResetPasswordCreate>>, TError,{data: PasswordResetRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthResetPasswordCreate>>, TError,{data: PasswordResetRequestRequest}, TContext> => {

const mutationKey = ['v1AuthResetPasswordCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthResetPasswordCreate>>, {data: PasswordResetRequestRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthResetPasswordCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthResetPasswordCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthResetPasswordCreate>>>
    export type V1AuthResetPasswordCreateMutationBody = PasswordResetRequestRequest
    export type V1AuthResetPasswordCreateMutationError = unknown

    export const useV1AuthResetPasswordCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthResetPasswordCreate>>, TError,{data: PasswordResetRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthResetPasswordCreate>>,
        TError,
        {data: PasswordResetRequestRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthResetPasswordCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Password reset confirm.
 */
export const v1AuthResetPasswordConfirmCreate = (
    passwordResetConfirmRequest: PasswordResetConfirmRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PasswordResetConfirm>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/reset-password/confirm/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordResetConfirmRequest, signal
    },
      options);
    }
  


export const getV1AuthResetPasswordConfirmCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthResetPasswordConfirmCreate>>, TError,{data: PasswordResetConfirmRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthResetPasswordConfirmCreate>>, TError,{data: PasswordResetConfirmRequest}, TContext> => {

const mutationKey = ['v1AuthResetPasswordConfirmCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthResetPasswordConfirmCreate>>, {data: PasswordResetConfirmRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthResetPasswordConfirmCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthResetPasswordConfirmCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthResetPasswordConfirmCreate>>>
    export type V1AuthResetPasswordConfirmCreateMutationBody = PasswordResetConfirmRequest
    export type V1AuthResetPasswordConfirmCreateMutationError = unknown

    export const useV1AuthResetPasswordConfirmCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthResetPasswordConfirmCreate>>, TError,{data: PasswordResetConfirmRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthResetPasswordConfirmCreate>>,
        TError,
        {data: PasswordResetConfirmRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthResetPasswordConfirmCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all user sessions
 */
export const v1AuthSessionsList = (
    params?: V1AuthSessionsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedUserSessionList>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/sessions/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1AuthSessionsListQueryKey = (params?: V1AuthSessionsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/sessions/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1AuthSessionsListQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthSessionsList>>, TError = unknown>(params?: V1AuthSessionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthSessionsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthSessionsList>>> = ({ signal }) => v1AuthSessionsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthSessionsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthSessionsList>>>
export type V1AuthSessionsListQueryError = unknown


export function useV1AuthSessionsList<TData = Awaited<ReturnType<typeof v1AuthSessionsList>>, TError = unknown>(
 params: undefined |  V1AuthSessionsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthSessionsList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthSessionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthSessionsList<TData = Awaited<ReturnType<typeof v1AuthSessionsList>>, TError = unknown>(
 params?: V1AuthSessionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthSessionsList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthSessionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthSessionsList<TData = Awaited<ReturnType<typeof v1AuthSessionsList>>, TError = unknown>(
 params?: V1AuthSessionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthSessionsList<TData = Awaited<ReturnType<typeof v1AuthSessionsList>>, TError = unknown>(
 params?: V1AuthSessionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthSessionsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a session
 */
export const v1AuthSessionsRetrieve = (
    id: number,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<UserSession>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/sessions/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthSessionsRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/sessions/${id}/`
    ] as const;
    }

    
export const getV1AuthSessionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthSessionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>> = ({ signal }) => v1AuthSessionsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthSessionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>>
export type V1AuthSessionsRetrieveQueryError = unknown


export function useV1AuthSessionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthSessionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthSessionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthSessionsRetrieve<TData = Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthSessionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthSessionsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Revoke a specific session.
 */
export const v1AuthSessionsRevokeCreate = (
    id: number,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<UserSession>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/sessions/${id}/revoke/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1AuthSessionsRevokeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthSessionsRevokeCreate>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthSessionsRevokeCreate>>, TError,{id: number}, TContext> => {

const mutationKey = ['v1AuthSessionsRevokeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthSessionsRevokeCreate>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  v1AuthSessionsRevokeCreate(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthSessionsRevokeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthSessionsRevokeCreate>>>
    
    export type V1AuthSessionsRevokeCreateMutationError = unknown

    export const useV1AuthSessionsRevokeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthSessionsRevokeCreate>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthSessionsRevokeCreate>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getV1AuthSessionsRevokeCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Token refresh with user info.
 */
export const v1AuthTokenRefreshCreate = (
    tokenRefreshRequest: TokenRefreshRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<TokenRefresh>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/token/refresh/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRefreshRequest, signal
    },
      options);
    }
  


export const getV1AuthTokenRefreshCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthTokenRefreshCreate>>, TError,{data: TokenRefreshRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthTokenRefreshCreate>>, TError,{data: TokenRefreshRequest}, TContext> => {

const mutationKey = ['v1AuthTokenRefreshCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthTokenRefreshCreate>>, {data: TokenRefreshRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthTokenRefreshCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthTokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthTokenRefreshCreate>>>
    export type V1AuthTokenRefreshCreateMutationBody = TokenRefreshRequest
    export type V1AuthTokenRefreshCreateMutationError = unknown

    export const useV1AuthTokenRefreshCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthTokenRefreshCreate>>, TError,{data: TokenRefreshRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthTokenRefreshCreate>>,
        TError,
        {data: TokenRefreshRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Takes a token and indicates if it is valid.  This view provides no
information about a token's fitness for a particular use.
 */
export const v1AuthTokenVerifyCreate = (
    tokenVerifyRequest: TokenVerifyRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/token/verify/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenVerifyRequest, signal
    },
      options);
    }
  


export const getV1AuthTokenVerifyCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthTokenVerifyCreate>>, TError,{data: TokenVerifyRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthTokenVerifyCreate>>, TError,{data: TokenVerifyRequest}, TContext> => {

const mutationKey = ['v1AuthTokenVerifyCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthTokenVerifyCreate>>, {data: TokenVerifyRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthTokenVerifyCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthTokenVerifyCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthTokenVerifyCreate>>>
    export type V1AuthTokenVerifyCreateMutationBody = TokenVerifyRequest
    export type V1AuthTokenVerifyCreateMutationError = unknown

    export const useV1AuthTokenVerifyCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthTokenVerifyCreate>>, TError,{data: TokenVerifyRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthTokenVerifyCreate>>,
        TError,
        {data: TokenVerifyRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthTokenVerifyCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Unsubscribe user from marketing emails using a signed token.
The token is generated by the `get_unsubscribe_token` method on the User model
and is expected as a single combined 'token' parameter containing uid and token
separated by a slash.
 */
export const v1AuthUnsubscribeCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/unsubscribe/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1AuthUnsubscribeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUnsubscribeCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthUnsubscribeCreate>>, TError,void, TContext> => {

const mutationKey = ['v1AuthUnsubscribeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthUnsubscribeCreate>>, void> = () => {
          

          return  v1AuthUnsubscribeCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthUnsubscribeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthUnsubscribeCreate>>>
    
    export type V1AuthUnsubscribeCreateMutationError = unknown

    export const useV1AuthUnsubscribeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUnsubscribeCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthUnsubscribeCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1AuthUnsubscribeCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List all users
 */
export const v1AuthUsersList = (
    params?: V1AuthUsersListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedUserList>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/users/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1AuthUsersListQueryKey = (params?: V1AuthUsersListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/users/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1AuthUsersListQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthUsersList>>, TError = unknown>(params?: V1AuthUsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthUsersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthUsersList>>> = ({ signal }) => v1AuthUsersList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthUsersListQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthUsersList>>>
export type V1AuthUsersListQueryError = unknown


export function useV1AuthUsersList<TData = Awaited<ReturnType<typeof v1AuthUsersList>>, TError = unknown>(
 params: undefined |  V1AuthUsersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthUsersList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthUsersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthUsersList<TData = Awaited<ReturnType<typeof v1AuthUsersList>>, TError = unknown>(
 params?: V1AuthUsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthUsersList>>,
          TError,
          Awaited<ReturnType<typeof v1AuthUsersList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthUsersList<TData = Awaited<ReturnType<typeof v1AuthUsersList>>, TError = unknown>(
 params?: V1AuthUsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthUsersList<TData = Awaited<ReturnType<typeof v1AuthUsersList>>, TError = unknown>(
 params?: V1AuthUsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthUsersListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new user
 */
export const v1AuthUsersCreate = (
    userRequest: UserRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<User>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/users/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userRequest, signal
    },
      options);
    }
  


export const getV1AuthUsersCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersCreate>>, TError,{data: UserRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersCreate>>, TError,{data: UserRequest}, TContext> => {

const mutationKey = ['v1AuthUsersCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthUsersCreate>>, {data: UserRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1AuthUsersCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthUsersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthUsersCreate>>>
    export type V1AuthUsersCreateMutationBody = UserRequest
    export type V1AuthUsersCreateMutationError = unknown

    export const useV1AuthUsersCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersCreate>>, TError,{data: UserRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthUsersCreate>>,
        TError,
        {data: UserRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthUsersCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a specific user
 */
export const v1AuthUsersRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<User>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/users/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthUsersRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/users/${id}/`
    ] as const;
    }

    
export const getV1AuthUsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthUsersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>> = ({ signal }) => v1AuthUsersRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthUsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>>
export type V1AuthUsersRetrieveQueryError = unknown


export function useV1AuthUsersRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthUsersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthUsersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthUsersRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthUsersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthUsersRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthUsersRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthUsersRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthUsersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update a user
 */
export const v1AuthUsersUpdate = (
    id: string,
    userRequest: UserRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<User>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/users/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userRequest
    },
      options);
    }
  


export const getV1AuthUsersUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersUpdate>>, TError,{id: string;data: UserRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersUpdate>>, TError,{id: string;data: UserRequest}, TContext> => {

const mutationKey = ['v1AuthUsersUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthUsersUpdate>>, {id: string;data: UserRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1AuthUsersUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthUsersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthUsersUpdate>>>
    export type V1AuthUsersUpdateMutationBody = UserRequest
    export type V1AuthUsersUpdateMutationError = unknown

    export const useV1AuthUsersUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersUpdate>>, TError,{id: string;data: UserRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthUsersUpdate>>,
        TError,
        {id: string;data: UserRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthUsersUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Partially update a user
 */
export const v1AuthUsersPartialUpdate = (
    id: string,
    patchedUserRequest: PatchedUserRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<User>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/users/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedUserRequest
    },
      options);
    }
  


export const getV1AuthUsersPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersPartialUpdate>>, TError,{id: string;data: PatchedUserRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersPartialUpdate>>, TError,{id: string;data: PatchedUserRequest}, TContext> => {

const mutationKey = ['v1AuthUsersPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthUsersPartialUpdate>>, {id: string;data: PatchedUserRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1AuthUsersPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthUsersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthUsersPartialUpdate>>>
    export type V1AuthUsersPartialUpdateMutationBody = PatchedUserRequest
    export type V1AuthUsersPartialUpdateMutationError = unknown

    export const useV1AuthUsersPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersPartialUpdate>>, TError,{id: string;data: PatchedUserRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthUsersPartialUpdate>>,
        TError,
        {id: string;data: PatchedUserRequest},
        TContext
      > => {

      const mutationOptions = getV1AuthUsersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a user
 */
export const v1AuthUsersDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/users/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1AuthUsersDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1AuthUsersDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1AuthUsersDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1AuthUsersDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1AuthUsersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1AuthUsersDestroy>>>
    
    export type V1AuthUsersDestroyMutationError = unknown

    export const useV1AuthUsersDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1AuthUsersDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1AuthUsersDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1AuthUsersDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Return the current authenticated user's data.

This prevents requests to `/users/me/` being interpreted as a lookup
for a user with primary key "me" (which causes errors because the PK
is a UUID). Non-disruptive: simply returns the same representation
as retrieving the user's own object.
 */
export const v1AuthUsersMeRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<User>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/users/me/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthUsersMeRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/users/me/`
    ] as const;
    }

    
export const getV1AuthUsersMeRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthUsersMeRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>> = ({ signal }) => v1AuthUsersMeRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthUsersMeRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>>
export type V1AuthUsersMeRetrieveQueryError = unknown


export function useV1AuthUsersMeRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthUsersMeRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthUsersMeRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthUsersMeRetrieve<TData = Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthUsersMeRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthUsersMeRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Verify email using token from verification email.
 */
export const v1AuthVerifyEmailRetrieve = (
    token: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/auth/verify-email/${token}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1AuthVerifyEmailRetrieveQueryKey = (token?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/auth/verify-email/${token}/`
    ] as const;
    }

    
export const getV1AuthVerifyEmailRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError = unknown>(token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1AuthVerifyEmailRetrieveQueryKey(token);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>> = ({ signal }) => v1AuthVerifyEmailRetrieve(token, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(token), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1AuthVerifyEmailRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>>
export type V1AuthVerifyEmailRetrieveQueryError = unknown


export function useV1AuthVerifyEmailRetrieve<TData = Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError = unknown>(
 token: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthVerifyEmailRetrieve<TData = Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError = unknown>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1AuthVerifyEmailRetrieve<TData = Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError = unknown>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1AuthVerifyEmailRetrieve<TData = Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError = unknown>(
 token: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1AuthVerifyEmailRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1AuthVerifyEmailRetrieveQueryOptions(token,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Public endpoint listing all active software with basic info.
Cached for 5 minutes to reduce database load.
 */
export const v1CatalogRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/catalog/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1CatalogRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/catalog/`
    ] as const;
    }

    
export const getV1CatalogRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1CatalogRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1CatalogRetrieve>>> = ({ signal }) => v1CatalogRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1CatalogRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1CatalogRetrieve>>>
export type V1CatalogRetrieveQueryError = unknown


export function useV1CatalogRetrieve<TData = Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1CatalogRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1CatalogRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1CatalogRetrieve<TData = Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1CatalogRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1CatalogRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1CatalogRetrieve<TData = Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1CatalogRetrieve<TData = Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1CatalogRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1CatalogRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Detailed analytics including user growth, revenue trends, and cohort retention.
 */
export const v1analyticsRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/analytics/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1analyticsRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/analytics/`
    ] as const;
    }

    
export const getV1analyticsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1analyticsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1analyticsRetrieve>>> = ({ signal }) => v1analyticsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1analyticsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1analyticsRetrieve>>>
export type V1analyticsRetrieveQueryError = unknown


export function useV1analyticsRetrieve<TData = Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1analyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1analyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1analyticsRetrieve<TData = Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1analyticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1analyticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1analyticsRetrieve<TData = Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1analyticsRetrieve<TData = Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1analyticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1analyticsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * License usage statistics: activations, usage events, popular features, etc.
 */
export const v1licenseUsageRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/license-usage/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1licenseUsageRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/license-usage/`
    ] as const;
    }

    
export const getV1licenseUsageRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1licenseUsageRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>> = ({ signal }) => v1licenseUsageRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1licenseUsageRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>>
export type V1licenseUsageRetrieveQueryError = unknown


export function useV1licenseUsageRetrieve<TData = Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1licenseUsageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1licenseUsageRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1licenseUsageRetrieve<TData = Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1licenseUsageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1licenseUsageRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1licenseUsageRetrieve<TData = Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1licenseUsageRetrieve<TData = Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1licenseUsageRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1licenseUsageRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * High‚Äëlevel dashboard overview with key metrics and recent trends.
 */
export const v1overviewRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/overview/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1overviewRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/overview/`
    ] as const;
    }

    
export const getV1overviewRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1overviewRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1overviewRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1overviewRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1overviewRetrieve>>> = ({ signal }) => v1overviewRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1overviewRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1overviewRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1overviewRetrieve>>>
export type V1overviewRetrieveQueryError = unknown


export function useV1overviewRetrieve<TData = Awaited<ReturnType<typeof v1overviewRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1overviewRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1overviewRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1overviewRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1overviewRetrieve<TData = Awaited<ReturnType<typeof v1overviewRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1overviewRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1overviewRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1overviewRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1overviewRetrieve<TData = Awaited<ReturnType<typeof v1overviewRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1overviewRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1overviewRetrieve<TData = Awaited<ReturnType<typeof v1overviewRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1overviewRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1overviewRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Generate aggregated reports based on query parameters.
Supports type=sales|users|licenses and date range from=YYYY-MM-DD to=YYYY-MM-DD.
 */
export const v1reportsRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/reports/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1reportsRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/reports/`
    ] as const;
    }

    
export const getV1reportsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1reportsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1reportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1reportsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1reportsRetrieve>>> = ({ signal }) => v1reportsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1reportsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1reportsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1reportsRetrieve>>>
export type V1reportsRetrieveQueryError = unknown


export function useV1reportsRetrieve<TData = Awaited<ReturnType<typeof v1reportsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1reportsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1reportsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1reportsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1reportsRetrieve<TData = Awaited<ReturnType<typeof v1reportsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1reportsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1reportsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1reportsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1reportsRetrieve<TData = Awaited<ReturnType<typeof v1reportsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1reportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1reportsRetrieve<TData = Awaited<ReturnType<typeof v1reportsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1reportsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1reportsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Sales‚Äëfocused metrics: revenue, MRR, ARPU, top customers, etc.
 */
export const v1salesRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/sales/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1salesRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/sales/`
    ] as const;
    }

    
export const getV1salesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1salesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1salesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1salesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1salesRetrieve>>> = ({ signal }) => v1salesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1salesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1salesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1salesRetrieve>>>
export type V1salesRetrieveQueryError = unknown


export function useV1salesRetrieve<TData = Awaited<ReturnType<typeof v1salesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1salesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1salesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1salesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1salesRetrieve<TData = Awaited<ReturnType<typeof v1salesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1salesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1salesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1salesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1salesRetrieve<TData = Awaited<ReturnType<typeof v1salesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1salesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1salesRetrieve<TData = Awaited<ReturnType<typeof v1salesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1salesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1salesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a comprehensive set of statistics for the admin dashboard.
Data is precomputed in a snapshot and cached for 5 minutes.

Cache is managed manually to avoid cross‚Äëuser contamination and to
align with the snapshot update schedule.
 */
export const v1statsRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/stats/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1statsRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/stats/`
    ] as const;
    }

    
export const getV1statsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1statsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1statsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1statsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1statsRetrieve>>> = ({ signal }) => v1statsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1statsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1statsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1statsRetrieve>>>
export type V1statsRetrieveQueryError = unknown


export function useV1statsRetrieve<TData = Awaited<ReturnType<typeof v1statsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1statsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1statsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1statsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1statsRetrieve<TData = Awaited<ReturnType<typeof v1statsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1statsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1statsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1statsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1statsRetrieve<TData = Awaited<ReturnType<typeof v1statsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1statsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1statsRetrieve<TData = Awaited<ReturnType<typeof v1statsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1statsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1statsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * System health metrics: Celery queue sizes, cache stats, error logs, etc.
For now returns placeholder data; can be extended with real monitoring integrations.
 */
export const v1systemMonitoringRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/system-monitoring/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1systemMonitoringRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/system-monitoring/`
    ] as const;
    }

    
export const getV1systemMonitoringRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1systemMonitoringRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>> = ({ signal }) => v1systemMonitoringRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1systemMonitoringRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>>
export type V1systemMonitoringRetrieveQueryError = unknown


export function useV1systemMonitoringRetrieve<TData = Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1systemMonitoringRetrieve<TData = Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1systemMonitoringRetrieve<TData = Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1systemMonitoringRetrieve<TData = Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1systemMonitoringRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1systemMonitoringRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Recent user activity: logins, license activations, deactivations, revocations.
 */
export const v1userActivityRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/dashboard/user-activity/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1userActivityRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/dashboard/user-activity/`
    ] as const;
    }

    
export const getV1userActivityRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1userActivityRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1userActivityRetrieve>>> = ({ signal }) => v1userActivityRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1userActivityRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1userActivityRetrieve>>>
export type V1userActivityRetrieveQueryError = unknown


export function useV1userActivityRetrieve<TData = Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1userActivityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1userActivityRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1userActivityRetrieve<TData = Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1userActivityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1userActivityRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1userActivityRetrieve<TData = Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1userActivityRetrieve<TData = Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1userActivityRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1userActivityRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Activate a license for the current user.
 */
export const v1LicensesActivateCreate = (
    activationRequestRequest: ActivationRequestRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationRequest>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: activationRequestRequest, signal
    },
      options);
    }
  


export const getV1LicensesActivateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivateCreate>>, TError,{data: ActivationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivateCreate>>, TError,{data: ActivationRequestRequest}, TContext> => {

const mutationKey = ['v1LicensesActivateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesActivateCreate>>, {data: ActivationRequestRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesActivateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesActivateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivateCreate>>>
    export type V1LicensesActivateCreateMutationBody = ActivationRequestRequest
    export type V1LicensesActivateCreateMutationError = unknown

    export const useV1LicensesActivateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivateCreate>>, TError,{data: ActivationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesActivateCreate>>,
        TError,
        {data: ActivationRequestRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesActivateCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for activation codes.
Users can view their own codes; admins can manage all.
 */
export const v1LicensesActivationCodesList = (
    params?: V1LicensesActivationCodesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedActivationCodeList>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1LicensesActivationCodesListQueryKey = (params?: V1LicensesActivationCodesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1LicensesActivationCodesListQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError = unknown>(params?: V1LicensesActivationCodesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesActivationCodesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>> = ({ signal }) => v1LicensesActivationCodesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesActivationCodesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>>
export type V1LicensesActivationCodesListQueryError = unknown


export function useV1LicensesActivationCodesList<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError = unknown>(
 params: undefined |  V1LicensesActivationCodesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesList<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError = unknown>(
 params?: V1LicensesActivationCodesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesList<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError = unknown>(
 params?: V1LicensesActivationCodesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesActivationCodesList<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError = unknown>(
 params?: V1LicensesActivationCodesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesActivationCodesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for activation codes.
Users can view their own codes; admins can manage all.
 */
export const v1LicensesActivationCodesCreate = (
    activationCodeRequest: ActivationCodeRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: activationCodeRequest, signal
    },
      options);
    }
  


export const getV1LicensesActivationCodesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesCreate>>, TError,{data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesCreate>>, TError,{data: ActivationCodeRequest}, TContext> => {

const mutationKey = ['v1LicensesActivationCodesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesCreate>>, {data: ActivationCodeRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesActivationCodesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesActivationCodesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesCreate>>>
    export type V1LicensesActivationCodesCreateMutationBody = ActivationCodeRequest
    export type V1LicensesActivationCodesCreateMutationError = unknown

    export const useV1LicensesActivationCodesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesCreate>>, TError,{data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesActivationCodesCreate>>,
        TError,
        {data: ActivationCodeRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesActivationCodesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for activation codes.
Users can view their own codes; admins can manage all.
 */
export const v1LicensesActivationCodesRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesActivationCodesRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/`
    ] as const;
    }

    
export const getV1LicensesActivationCodesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesActivationCodesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>> = ({ signal }) => v1LicensesActivationCodesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesActivationCodesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>>
export type V1LicensesActivationCodesRetrieveQueryError = unknown


export function useV1LicensesActivationCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesActivationCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesActivationCodesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for activation codes.
Users can view their own codes; admins can manage all.
 */
export const v1LicensesActivationCodesUpdate = (
    id: string,
    activationCodeRequest: ActivationCodeRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: activationCodeRequest
    },
      options);
    }
  


export const getV1LicensesActivationCodesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesUpdate>>, TError,{id: string;data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesUpdate>>, TError,{id: string;data: ActivationCodeRequest}, TContext> => {

const mutationKey = ['v1LicensesActivationCodesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesUpdate>>, {id: string;data: ActivationCodeRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesActivationCodesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesActivationCodesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesUpdate>>>
    export type V1LicensesActivationCodesUpdateMutationBody = ActivationCodeRequest
    export type V1LicensesActivationCodesUpdateMutationError = unknown

    export const useV1LicensesActivationCodesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesUpdate>>, TError,{id: string;data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesActivationCodesUpdate>>,
        TError,
        {id: string;data: ActivationCodeRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesActivationCodesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for activation codes.
Users can view their own codes; admins can manage all.
 */
export const v1LicensesActivationCodesPartialUpdate = (
    id: string,
    patchedActivationCodeRequest: PatchedActivationCodeRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedActivationCodeRequest
    },
      options);
    }
  


export const getV1LicensesActivationCodesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesPartialUpdate>>, TError,{id: string;data: PatchedActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesPartialUpdate>>, TError,{id: string;data: PatchedActivationCodeRequest}, TContext> => {

const mutationKey = ['v1LicensesActivationCodesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesPartialUpdate>>, {id: string;data: PatchedActivationCodeRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesActivationCodesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesActivationCodesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesPartialUpdate>>>
    export type V1LicensesActivationCodesPartialUpdateMutationBody = PatchedActivationCodeRequest
    export type V1LicensesActivationCodesPartialUpdateMutationError = unknown

    export const useV1LicensesActivationCodesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesPartialUpdate>>, TError,{id: string;data: PatchedActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesActivationCodesPartialUpdate>>,
        TError,
        {id: string;data: PatchedActivationCodeRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesActivationCodesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for activation codes.
Users can view their own codes; admins can manage all.
 */
export const v1LicensesActivationCodesDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1LicensesActivationCodesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1LicensesActivationCodesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1LicensesActivationCodesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesActivationCodesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesDestroy>>>
    
    export type V1LicensesActivationCodesDestroyMutationError = unknown

    export const useV1LicensesActivationCodesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesActivationCodesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1LicensesActivationCodesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Activate this code on a specific device.
 */
export const v1LicensesActivationCodesActivateDeviceCreate = (
    id: string,
    activationCodeRequest: ActivationCodeRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/activate_device/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: activationCodeRequest, signal
    },
      options);
    }
  


export const getV1LicensesActivationCodesActivateDeviceCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesActivateDeviceCreate>>, TError,{id: string;data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesActivateDeviceCreate>>, TError,{id: string;data: ActivationCodeRequest}, TContext> => {

const mutationKey = ['v1LicensesActivationCodesActivateDeviceCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesActivateDeviceCreate>>, {id: string;data: ActivationCodeRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesActivationCodesActivateDeviceCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesActivationCodesActivateDeviceCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesActivateDeviceCreate>>>
    export type V1LicensesActivationCodesActivateDeviceCreateMutationBody = ActivationCodeRequest
    export type V1LicensesActivationCodesActivateDeviceCreateMutationError = unknown

    export const useV1LicensesActivationCodesActivateDeviceCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesActivateDeviceCreate>>, TError,{id: string;data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesActivationCodesActivateDeviceCreate>>,
        TError,
        {id: string;data: ActivationCodeRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesActivationCodesActivateDeviceCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Deactivate this code from the current device.
 */
export const v1LicensesActivationCodesDeactivateDeviceCreate = (
    id: string,
    activationCodeRequest: ActivationCodeRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/deactivate_device/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: activationCodeRequest, signal
    },
      options);
    }
  


export const getV1LicensesActivationCodesDeactivateDeviceCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesDeactivateDeviceCreate>>, TError,{id: string;data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesDeactivateDeviceCreate>>, TError,{id: string;data: ActivationCodeRequest}, TContext> => {

const mutationKey = ['v1LicensesActivationCodesDeactivateDeviceCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesDeactivateDeviceCreate>>, {id: string;data: ActivationCodeRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesActivationCodesDeactivateDeviceCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesActivationCodesDeactivateDeviceCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesDeactivateDeviceCreate>>>
    export type V1LicensesActivationCodesDeactivateDeviceCreateMutationBody = ActivationCodeRequest
    export type V1LicensesActivationCodesDeactivateDeviceCreateMutationError = unknown

    export const useV1LicensesActivationCodesDeactivateDeviceCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesDeactivateDeviceCreate>>, TError,{id: string;data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesActivationCodesDeactivateDeviceCreate>>,
        TError,
        {id: string;data: ActivationCodeRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesActivationCodesDeactivateDeviceCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get encrypted license file for this activation code.
 */
export const v1LicensesActivationCodesLicenseFileRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/license_file/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesActivationCodesLicenseFileRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/${id}/license_file/`
    ] as const;
    }

    
export const getV1LicensesActivationCodesLicenseFileRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesActivationCodesLicenseFileRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>> = ({ signal }) => v1LicensesActivationCodesLicenseFileRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesActivationCodesLicenseFileRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>>
export type V1LicensesActivationCodesLicenseFileRetrieveQueryError = unknown


export function useV1LicensesActivationCodesLicenseFileRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesLicenseFileRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesLicenseFileRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesActivationCodesLicenseFileRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesLicenseFileRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesActivationCodesLicenseFileRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get current user's licenses with software details.
 */
export const v1LicensesActivationCodesMyLicensesRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/my_licenses/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesActivationCodesMyLicensesRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/activation-codes/my_licenses/`
    ] as const;
    }

    
export const getV1LicensesActivationCodesMyLicensesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesActivationCodesMyLicensesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>> = ({ signal }) => v1LicensesActivationCodesMyLicensesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesActivationCodesMyLicensesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>>
export type V1LicensesActivationCodesMyLicensesRetrieveQueryError = unknown


export function useV1LicensesActivationCodesMyLicensesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesMyLicensesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesActivationCodesMyLicensesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesActivationCodesMyLicensesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesActivationCodesMyLicensesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesActivationCodesMyLicensesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for code batches (admin only).
 */
export const v1LicensesBatchesList = (
    params?: V1LicensesBatchesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedCodeBatchList>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/batches/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1LicensesBatchesListQueryKey = (params?: V1LicensesBatchesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/batches/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1LicensesBatchesListQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError = unknown>(params?: V1LicensesBatchesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesBatchesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesBatchesList>>> = ({ signal }) => v1LicensesBatchesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesBatchesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesBatchesList>>>
export type V1LicensesBatchesListQueryError = unknown


export function useV1LicensesBatchesList<TData = Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError = unknown>(
 params: undefined |  V1LicensesBatchesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesBatchesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesBatchesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesBatchesList<TData = Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError = unknown>(
 params?: V1LicensesBatchesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesBatchesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesBatchesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesBatchesList<TData = Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError = unknown>(
 params?: V1LicensesBatchesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesBatchesList<TData = Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError = unknown>(
 params?: V1LicensesBatchesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesBatchesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for code batches (admin only).
 */
export const v1LicensesBatchesCreate = (
    codeBatchRequest: CodeBatchRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<CodeBatch>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/batches/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: codeBatchRequest, signal
    },
      options);
    }
  


export const getV1LicensesBatchesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesCreate>>, TError,{data: CodeBatchRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesCreate>>, TError,{data: CodeBatchRequest}, TContext> => {

const mutationKey = ['v1LicensesBatchesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesBatchesCreate>>, {data: CodeBatchRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesBatchesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesBatchesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesBatchesCreate>>>
    export type V1LicensesBatchesCreateMutationBody = CodeBatchRequest
    export type V1LicensesBatchesCreateMutationError = unknown

    export const useV1LicensesBatchesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesCreate>>, TError,{data: CodeBatchRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesBatchesCreate>>,
        TError,
        {data: CodeBatchRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesBatchesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for code batches (admin only).
 */
export const v1LicensesBatchesRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<CodeBatch>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/batches/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesBatchesRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/batches/${id}/`
    ] as const;
    }

    
export const getV1LicensesBatchesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesBatchesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>> = ({ signal }) => v1LicensesBatchesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesBatchesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>>
export type V1LicensesBatchesRetrieveQueryError = unknown


export function useV1LicensesBatchesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesBatchesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesBatchesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesBatchesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesBatchesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for code batches (admin only).
 */
export const v1LicensesBatchesUpdate = (
    id: string,
    codeBatchRequest: CodeBatchRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<CodeBatch>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/batches/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: codeBatchRequest
    },
      options);
    }
  


export const getV1LicensesBatchesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesUpdate>>, TError,{id: string;data: CodeBatchRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesUpdate>>, TError,{id: string;data: CodeBatchRequest}, TContext> => {

const mutationKey = ['v1LicensesBatchesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesBatchesUpdate>>, {id: string;data: CodeBatchRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesBatchesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesBatchesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesBatchesUpdate>>>
    export type V1LicensesBatchesUpdateMutationBody = CodeBatchRequest
    export type V1LicensesBatchesUpdateMutationError = unknown

    export const useV1LicensesBatchesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesUpdate>>, TError,{id: string;data: CodeBatchRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesBatchesUpdate>>,
        TError,
        {id: string;data: CodeBatchRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesBatchesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for code batches (admin only).
 */
export const v1LicensesBatchesPartialUpdate = (
    id: string,
    patchedCodeBatchRequest: PatchedCodeBatchRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<CodeBatch>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/batches/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCodeBatchRequest
    },
      options);
    }
  


export const getV1LicensesBatchesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesPartialUpdate>>, TError,{id: string;data: PatchedCodeBatchRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesPartialUpdate>>, TError,{id: string;data: PatchedCodeBatchRequest}, TContext> => {

const mutationKey = ['v1LicensesBatchesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesBatchesPartialUpdate>>, {id: string;data: PatchedCodeBatchRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesBatchesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesBatchesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesBatchesPartialUpdate>>>
    export type V1LicensesBatchesPartialUpdateMutationBody = PatchedCodeBatchRequest
    export type V1LicensesBatchesPartialUpdateMutationError = unknown

    export const useV1LicensesBatchesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesPartialUpdate>>, TError,{id: string;data: PatchedCodeBatchRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesBatchesPartialUpdate>>,
        TError,
        {id: string;data: PatchedCodeBatchRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesBatchesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for code batches (admin only).
 */
export const v1LicensesBatchesDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/batches/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1LicensesBatchesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1LicensesBatchesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesBatchesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1LicensesBatchesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesBatchesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesBatchesDestroy>>>
    
    export type V1LicensesBatchesDestroyMutationError = unknown

    export const useV1LicensesBatchesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesBatchesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesBatchesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1LicensesBatchesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for code batches (admin only).
 */
export const v1LicensesBatchesCodesRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<CodeBatch>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/batches/${id}/codes/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesBatchesCodesRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/batches/${id}/codes/`
    ] as const;
    }

    
export const getV1LicensesBatchesCodesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesBatchesCodesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>> = ({ signal }) => v1LicensesBatchesCodesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesBatchesCodesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>>
export type V1LicensesBatchesCodesRetrieveQueryError = unknown


export function useV1LicensesBatchesCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesBatchesCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesBatchesCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesBatchesCodesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesBatchesCodesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesBatchesCodesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Check for software updates for user's licenses.
 */
export const v1LicensesCheckUpdatesRetrieve = (
    softwareSlug: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/check-updates/${softwareSlug}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesCheckUpdatesRetrieveQueryKey = (softwareSlug?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/check-updates/${softwareSlug}/`
    ] as const;
    }

    
export const getV1LicensesCheckUpdatesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError = unknown>(softwareSlug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesCheckUpdatesRetrieveQueryKey(softwareSlug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>> = ({ signal }) => v1LicensesCheckUpdatesRetrieve(softwareSlug, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(softwareSlug), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesCheckUpdatesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>>
export type V1LicensesCheckUpdatesRetrieveQueryError = unknown


export function useV1LicensesCheckUpdatesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError = unknown>(
 softwareSlug: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesCheckUpdatesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError = unknown>(
 softwareSlug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesCheckUpdatesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError = unknown>(
 softwareSlug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesCheckUpdatesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError = unknown>(
 softwareSlug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesCheckUpdatesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesCheckUpdatesRetrieveQueryOptions(softwareSlug,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Deactivate a license from the current device.
 */
export const v1LicensesDeactivateCreate = (
    deactivationRequestRequest: DeactivationRequestRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<DeactivationRequest>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/deactivate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: deactivationRequestRequest, signal
    },
      options);
    }
  


export const getV1LicensesDeactivateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesDeactivateCreate>>, TError,{data: DeactivationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesDeactivateCreate>>, TError,{data: DeactivationRequestRequest}, TContext> => {

const mutationKey = ['v1LicensesDeactivateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesDeactivateCreate>>, {data: DeactivationRequestRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesDeactivateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesDeactivateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesDeactivateCreate>>>
    export type V1LicensesDeactivateCreateMutationBody = DeactivationRequestRequest
    export type V1LicensesDeactivateCreateMutationError = unknown

    export const useV1LicensesDeactivateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesDeactivateCreate>>, TError,{data: DeactivationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesDeactivateCreate>>,
        TError,
        {data: DeactivationRequestRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesDeactivateCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license features (read‚Äëonly for users).
 */
export const v1LicensesFeaturesList = (
    params?: V1LicensesFeaturesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedLicenseFeatureList>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/features/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1LicensesFeaturesListQueryKey = (params?: V1LicensesFeaturesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/features/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1LicensesFeaturesListQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError = unknown>(params?: V1LicensesFeaturesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesFeaturesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesFeaturesList>>> = ({ signal }) => v1LicensesFeaturesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesFeaturesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesFeaturesList>>>
export type V1LicensesFeaturesListQueryError = unknown


export function useV1LicensesFeaturesList<TData = Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError = unknown>(
 params: undefined |  V1LicensesFeaturesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesFeaturesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesFeaturesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesFeaturesList<TData = Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError = unknown>(
 params?: V1LicensesFeaturesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesFeaturesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesFeaturesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesFeaturesList<TData = Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError = unknown>(
 params?: V1LicensesFeaturesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesFeaturesList<TData = Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError = unknown>(
 params?: V1LicensesFeaturesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesFeaturesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for license features (read‚Äëonly for users).
 */
export const v1LicensesFeaturesCreate = (
    licenseFeatureRequest: LicenseFeatureRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<LicenseFeature>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/features/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: licenseFeatureRequest, signal
    },
      options);
    }
  


export const getV1LicensesFeaturesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesCreate>>, TError,{data: LicenseFeatureRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesCreate>>, TError,{data: LicenseFeatureRequest}, TContext> => {

const mutationKey = ['v1LicensesFeaturesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesFeaturesCreate>>, {data: LicenseFeatureRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesFeaturesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesFeaturesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesFeaturesCreate>>>
    export type V1LicensesFeaturesCreateMutationBody = LicenseFeatureRequest
    export type V1LicensesFeaturesCreateMutationError = unknown

    export const useV1LicensesFeaturesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesCreate>>, TError,{data: LicenseFeatureRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesFeaturesCreate>>,
        TError,
        {data: LicenseFeatureRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesFeaturesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license features (read‚Äëonly for users).
 */
export const v1LicensesFeaturesRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<LicenseFeature>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/features/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesFeaturesRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/features/${id}/`
    ] as const;
    }

    
export const getV1LicensesFeaturesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesFeaturesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>> = ({ signal }) => v1LicensesFeaturesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesFeaturesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>>
export type V1LicensesFeaturesRetrieveQueryError = unknown


export function useV1LicensesFeaturesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesFeaturesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesFeaturesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesFeaturesRetrieve<TData = Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesFeaturesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesFeaturesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for license features (read‚Äëonly for users).
 */
export const v1LicensesFeaturesUpdate = (
    id: string,
    licenseFeatureRequest: LicenseFeatureRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<LicenseFeature>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/features/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: licenseFeatureRequest
    },
      options);
    }
  


export const getV1LicensesFeaturesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesUpdate>>, TError,{id: string;data: LicenseFeatureRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesUpdate>>, TError,{id: string;data: LicenseFeatureRequest}, TContext> => {

const mutationKey = ['v1LicensesFeaturesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesFeaturesUpdate>>, {id: string;data: LicenseFeatureRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesFeaturesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesFeaturesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesFeaturesUpdate>>>
    export type V1LicensesFeaturesUpdateMutationBody = LicenseFeatureRequest
    export type V1LicensesFeaturesUpdateMutationError = unknown

    export const useV1LicensesFeaturesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesUpdate>>, TError,{id: string;data: LicenseFeatureRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesFeaturesUpdate>>,
        TError,
        {id: string;data: LicenseFeatureRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesFeaturesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license features (read‚Äëonly for users).
 */
export const v1LicensesFeaturesPartialUpdate = (
    id: string,
    patchedLicenseFeatureRequest: PatchedLicenseFeatureRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<LicenseFeature>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/features/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedLicenseFeatureRequest
    },
      options);
    }
  


export const getV1LicensesFeaturesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesPartialUpdate>>, TError,{id: string;data: PatchedLicenseFeatureRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesPartialUpdate>>, TError,{id: string;data: PatchedLicenseFeatureRequest}, TContext> => {

const mutationKey = ['v1LicensesFeaturesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesFeaturesPartialUpdate>>, {id: string;data: PatchedLicenseFeatureRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesFeaturesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesFeaturesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesFeaturesPartialUpdate>>>
    export type V1LicensesFeaturesPartialUpdateMutationBody = PatchedLicenseFeatureRequest
    export type V1LicensesFeaturesPartialUpdateMutationError = unknown

    export const useV1LicensesFeaturesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesPartialUpdate>>, TError,{id: string;data: PatchedLicenseFeatureRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesFeaturesPartialUpdate>>,
        TError,
        {id: string;data: PatchedLicenseFeatureRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesFeaturesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license features (read‚Äëonly for users).
 */
export const v1LicensesFeaturesDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/features/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1LicensesFeaturesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1LicensesFeaturesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesFeaturesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1LicensesFeaturesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesFeaturesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesFeaturesDestroy>>>
    
    export type V1LicensesFeaturesDestroyMutationError = unknown

    export const useV1LicensesFeaturesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesFeaturesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesFeaturesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1LicensesFeaturesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Generate new activation codes (admin only).
 */
export const v1LicensesGenerateCreate = (
    activationCodeRequest: ActivationCodeRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationCode>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/generate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: activationCodeRequest, signal
    },
      options);
    }
  


export const getV1LicensesGenerateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesGenerateCreate>>, TError,{data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesGenerateCreate>>, TError,{data: ActivationCodeRequest}, TContext> => {

const mutationKey = ['v1LicensesGenerateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesGenerateCreate>>, {data: ActivationCodeRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesGenerateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesGenerateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesGenerateCreate>>>
    export type V1LicensesGenerateCreateMutationBody = ActivationCodeRequest
    export type V1LicensesGenerateCreateMutationError = unknown

    export const useV1LicensesGenerateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesGenerateCreate>>, TError,{data: ActivationCodeRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesGenerateCreate>>,
        TError,
        {data: ActivationCodeRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesGenerateCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for activation logs (users see own, admins see all).
 */
export const v1LicensesLogsList = (
    params?: V1LicensesLogsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedActivationLogList>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/logs/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1LicensesLogsListQueryKey = (params?: V1LicensesLogsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/logs/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1LicensesLogsListQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesLogsList>>, TError = unknown>(params?: V1LicensesLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesLogsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesLogsList>>> = ({ signal }) => v1LicensesLogsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesLogsList>>>
export type V1LicensesLogsListQueryError = unknown


export function useV1LicensesLogsList<TData = Awaited<ReturnType<typeof v1LicensesLogsList>>, TError = unknown>(
 params: undefined |  V1LicensesLogsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesLogsList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesLogsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesLogsList<TData = Awaited<ReturnType<typeof v1LicensesLogsList>>, TError = unknown>(
 params?: V1LicensesLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesLogsList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesLogsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesLogsList<TData = Awaited<ReturnType<typeof v1LicensesLogsList>>, TError = unknown>(
 params?: V1LicensesLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesLogsList<TData = Awaited<ReturnType<typeof v1LicensesLogsList>>, TError = unknown>(
 params?: V1LicensesLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesLogsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for activation logs (users see own, admins see all).
 */
export const v1LicensesLogsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ActivationLog>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/logs/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesLogsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/logs/${id}/`
    ] as const;
    }

    
export const getV1LicensesLogsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesLogsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>> = ({ signal }) => v1LicensesLogsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesLogsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>>
export type V1LicensesLogsRetrieveQueryError = unknown


export function useV1LicensesLogsRetrieve<TData = Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesLogsRetrieve<TData = Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesLogsRetrieve<TData = Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesLogsRetrieve<TData = Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesLogsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesLogsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all licenses for the current user.
 */
export const v1LicensesMyLicensesList = (
    params?: V1LicensesMyLicensesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedActivationCodeList>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/my-licenses/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1LicensesMyLicensesListQueryKey = (params?: V1LicensesMyLicensesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/my-licenses/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1LicensesMyLicensesListQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError = unknown>(params?: V1LicensesMyLicensesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesMyLicensesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>> = ({ signal }) => v1LicensesMyLicensesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesMyLicensesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>>
export type V1LicensesMyLicensesListQueryError = unknown


export function useV1LicensesMyLicensesList<TData = Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError = unknown>(
 params: undefined |  V1LicensesMyLicensesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesMyLicensesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesMyLicensesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesMyLicensesList<TData = Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError = unknown>(
 params?: V1LicensesMyLicensesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesMyLicensesList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesMyLicensesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesMyLicensesList<TData = Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError = unknown>(
 params?: V1LicensesMyLicensesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesMyLicensesList<TData = Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError = unknown>(
 params?: V1LicensesMyLicensesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesMyLicensesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesMyLicensesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Revoke a license (admin only).
 */
export const v1LicensesRevokeCreate = (
    revocationRequestRequest: RevocationRequestRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<RevocationRequest>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/revoke/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: revocationRequestRequest, signal
    },
      options);
    }
  


export const getV1LicensesRevokeCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesRevokeCreate>>, TError,{data: RevocationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesRevokeCreate>>, TError,{data: RevocationRequestRequest}, TContext> => {

const mutationKey = ['v1LicensesRevokeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesRevokeCreate>>, {data: RevocationRequestRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesRevokeCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesRevokeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesRevokeCreate>>>
    export type V1LicensesRevokeCreateMutationBody = RevocationRequestRequest
    export type V1LicensesRevokeCreateMutationError = unknown

    export const useV1LicensesRevokeCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesRevokeCreate>>, TError,{data: RevocationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesRevokeCreate>>,
        TError,
        {data: RevocationRequestRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesRevokeCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Revoke a license (admin only).
 */
export const v1LicensesRevokeCreate2 = (
    codeId: string,
    revocationRequestRequest: RevocationRequestRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<RevocationRequest>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/revoke/${codeId}/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: revocationRequestRequest, signal
    },
      options);
    }
  


export const getV1LicensesRevokeCreate2MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesRevokeCreate2>>, TError,{codeId: string;data: RevocationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesRevokeCreate2>>, TError,{codeId: string;data: RevocationRequestRequest}, TContext> => {

const mutationKey = ['v1LicensesRevokeCreate2'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesRevokeCreate2>>, {codeId: string;data: RevocationRequestRequest}> = (props) => {
          const {codeId,data} = props ?? {};

          return  v1LicensesRevokeCreate2(codeId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesRevokeCreate2MutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesRevokeCreate2>>>
    export type V1LicensesRevokeCreate2MutationBody = RevocationRequestRequest
    export type V1LicensesRevokeCreate2MutationError = unknown

    export const useV1LicensesRevokeCreate2 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesRevokeCreate2>>, TError,{codeId: string;data: RevocationRequestRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesRevokeCreate2>>,
        TError,
        {codeId: string;data: RevocationRequestRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesRevokeCreate2MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license usage tracking.
 */
export const v1LicensesUsageList = (
    params?: V1LicensesUsageListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedLicenseUsageList>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/usage/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1LicensesUsageListQueryKey = (params?: V1LicensesUsageListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/usage/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1LicensesUsageListQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesUsageList>>, TError = unknown>(params?: V1LicensesUsageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesUsageListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesUsageList>>> = ({ signal }) => v1LicensesUsageList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesUsageListQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesUsageList>>>
export type V1LicensesUsageListQueryError = unknown


export function useV1LicensesUsageList<TData = Awaited<ReturnType<typeof v1LicensesUsageList>>, TError = unknown>(
 params: undefined |  V1LicensesUsageListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesUsageList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesUsageList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesUsageList<TData = Awaited<ReturnType<typeof v1LicensesUsageList>>, TError = unknown>(
 params?: V1LicensesUsageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesUsageList>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesUsageList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesUsageList<TData = Awaited<ReturnType<typeof v1LicensesUsageList>>, TError = unknown>(
 params?: V1LicensesUsageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesUsageList<TData = Awaited<ReturnType<typeof v1LicensesUsageList>>, TError = unknown>(
 params?: V1LicensesUsageListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesUsageListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for license usage tracking.
 */
export const v1LicensesUsageCreate = (
    licenseUsageRequest: LicenseUsageRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<LicenseUsage>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/usage/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: licenseUsageRequest, signal
    },
      options);
    }
  


export const getV1LicensesUsageCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageCreate>>, TError,{data: LicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageCreate>>, TError,{data: LicenseUsageRequest}, TContext> => {

const mutationKey = ['v1LicensesUsageCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesUsageCreate>>, {data: LicenseUsageRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesUsageCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesUsageCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesUsageCreate>>>
    export type V1LicensesUsageCreateMutationBody = LicenseUsageRequest
    export type V1LicensesUsageCreateMutationError = unknown

    export const useV1LicensesUsageCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageCreate>>, TError,{data: LicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesUsageCreate>>,
        TError,
        {data: LicenseUsageRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesUsageCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license usage tracking.
 */
export const v1LicensesUsageRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<LicenseUsage>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/usage/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1LicensesUsageRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/licenses/usage/${id}/`
    ] as const;
    }

    
export const getV1LicensesUsageRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1LicensesUsageRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>> = ({ signal }) => v1LicensesUsageRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1LicensesUsageRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>>
export type V1LicensesUsageRetrieveQueryError = unknown


export function useV1LicensesUsageRetrieve<TData = Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesUsageRetrieve<TData = Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1LicensesUsageRetrieve<TData = Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1LicensesUsageRetrieve<TData = Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1LicensesUsageRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1LicensesUsageRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for license usage tracking.
 */
export const v1LicensesUsageUpdate = (
    id: string,
    licenseUsageRequest: LicenseUsageRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<LicenseUsage>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/usage/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: licenseUsageRequest
    },
      options);
    }
  


export const getV1LicensesUsageUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageUpdate>>, TError,{id: string;data: LicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageUpdate>>, TError,{id: string;data: LicenseUsageRequest}, TContext> => {

const mutationKey = ['v1LicensesUsageUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesUsageUpdate>>, {id: string;data: LicenseUsageRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesUsageUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesUsageUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesUsageUpdate>>>
    export type V1LicensesUsageUpdateMutationBody = LicenseUsageRequest
    export type V1LicensesUsageUpdateMutationError = unknown

    export const useV1LicensesUsageUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageUpdate>>, TError,{id: string;data: LicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesUsageUpdate>>,
        TError,
        {id: string;data: LicenseUsageRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesUsageUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license usage tracking.
 */
export const v1LicensesUsagePartialUpdate = (
    id: string,
    patchedLicenseUsageRequest: PatchedLicenseUsageRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<LicenseUsage>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/usage/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedLicenseUsageRequest
    },
      options);
    }
  


export const getV1LicensesUsagePartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsagePartialUpdate>>, TError,{id: string;data: PatchedLicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsagePartialUpdate>>, TError,{id: string;data: PatchedLicenseUsageRequest}, TContext> => {

const mutationKey = ['v1LicensesUsagePartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesUsagePartialUpdate>>, {id: string;data: PatchedLicenseUsageRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1LicensesUsagePartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesUsagePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesUsagePartialUpdate>>>
    export type V1LicensesUsagePartialUpdateMutationBody = PatchedLicenseUsageRequest
    export type V1LicensesUsagePartialUpdateMutationError = unknown

    export const useV1LicensesUsagePartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsagePartialUpdate>>, TError,{id: string;data: PatchedLicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesUsagePartialUpdate>>,
        TError,
        {id: string;data: PatchedLicenseUsageRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesUsagePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license usage tracking.
 */
export const v1LicensesUsageDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/usage/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1LicensesUsageDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1LicensesUsageDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesUsageDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1LicensesUsageDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesUsageDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesUsageDestroy>>>
    
    export type V1LicensesUsageDestroyMutationError = unknown

    export const useV1LicensesUsageDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesUsageDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1LicensesUsageDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for license usage tracking.
 */
export const v1LicensesUsageLogUsageCreate = (
    licenseUsageRequest: LicenseUsageRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<LicenseUsage>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/usage/log_usage/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: licenseUsageRequest, signal
    },
      options);
    }
  


export const getV1LicensesUsageLogUsageCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageLogUsageCreate>>, TError,{data: LicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageLogUsageCreate>>, TError,{data: LicenseUsageRequest}, TContext> => {

const mutationKey = ['v1LicensesUsageLogUsageCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesUsageLogUsageCreate>>, {data: LicenseUsageRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesUsageLogUsageCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesUsageLogUsageCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesUsageLogUsageCreate>>>
    export type V1LicensesUsageLogUsageCreateMutationBody = LicenseUsageRequest
    export type V1LicensesUsageLogUsageCreateMutationError = unknown

    export const useV1LicensesUsageLogUsageCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesUsageLogUsageCreate>>, TError,{data: LicenseUsageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesUsageLogUsageCreate>>,
        TError,
        {data: LicenseUsageRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesUsageLogUsageCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Validate activation code without activating (public).
 */
export const v1LicensesValidateCreate = (
    validateActivationRequest: ValidateActivationRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<ValidateActivation>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/validate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: validateActivationRequest, signal
    },
      options);
    }
  


export const getV1LicensesValidateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesValidateCreate>>, TError,{data: ValidateActivationRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesValidateCreate>>, TError,{data: ValidateActivationRequest}, TContext> => {

const mutationKey = ['v1LicensesValidateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesValidateCreate>>, {data: ValidateActivationRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1LicensesValidateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesValidateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesValidateCreate>>>
    export type V1LicensesValidateCreateMutationBody = ValidateActivationRequest
    export type V1LicensesValidateCreateMutationError = unknown

    export const useV1LicensesValidateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesValidateCreate>>, TError,{data: ValidateActivationRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesValidateCreate>>,
        TError,
        {data: ValidateActivationRequest},
        TContext
      > => {

      const mutationOptions = getV1LicensesValidateCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Validate offline license file.
 */
export const v1LicensesValidateOfflineCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/licenses/validate-offline/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1LicensesValidateOfflineCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesValidateOfflineCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1LicensesValidateOfflineCreate>>, TError,void, TContext> => {

const mutationKey = ['v1LicensesValidateOfflineCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1LicensesValidateOfflineCreate>>, void> = () => {
          

          return  v1LicensesValidateOfflineCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1LicensesValidateOfflineCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1LicensesValidateOfflineCreate>>>
    
    export type V1LicensesValidateOfflineCreateMutationError = unknown

    export const useV1LicensesValidateOfflineCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1LicensesValidateOfflineCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1LicensesValidateOfflineCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1LicensesValidateOfflineCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for coupons. Admin only.
 */
export const v1PaymentsCouponsList = (
    params?: V1PaymentsCouponsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedCouponList>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/coupons/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1PaymentsCouponsListQueryKey = (params?: V1PaymentsCouponsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/coupons/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1PaymentsCouponsListQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError = unknown>(params?: V1PaymentsCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsCouponsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsCouponsList>>> = ({ signal }) => v1PaymentsCouponsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsCouponsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsCouponsList>>>
export type V1PaymentsCouponsListQueryError = unknown


export function useV1PaymentsCouponsList<TData = Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError = unknown>(
 params: undefined |  V1PaymentsCouponsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsCouponsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsCouponsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsCouponsList<TData = Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError = unknown>(
 params?: V1PaymentsCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsCouponsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsCouponsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsCouponsList<TData = Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError = unknown>(
 params?: V1PaymentsCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsCouponsList<TData = Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError = unknown>(
 params?: V1PaymentsCouponsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsCouponsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for coupons. Admin only.
 */
export const v1PaymentsCouponsCreate = (
    couponRequest: CouponRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Coupon>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/coupons/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: couponRequest, signal
    },
      options);
    }
  


export const getV1PaymentsCouponsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsCreate>>, TError,{data: CouponRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsCreate>>, TError,{data: CouponRequest}, TContext> => {

const mutationKey = ['v1PaymentsCouponsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsCouponsCreate>>, {data: CouponRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1PaymentsCouponsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsCouponsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsCouponsCreate>>>
    export type V1PaymentsCouponsCreateMutationBody = CouponRequest
    export type V1PaymentsCouponsCreateMutationError = unknown

    export const useV1PaymentsCouponsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsCreate>>, TError,{data: CouponRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsCouponsCreate>>,
        TError,
        {data: CouponRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsCouponsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for coupons. Admin only.
 */
export const v1PaymentsCouponsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Coupon>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/coupons/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1PaymentsCouponsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/coupons/${id}/`
    ] as const;
    }

    
export const getV1PaymentsCouponsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsCouponsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>> = ({ signal }) => v1PaymentsCouponsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsCouponsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>>
export type V1PaymentsCouponsRetrieveQueryError = unknown


export function useV1PaymentsCouponsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsCouponsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsCouponsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsCouponsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsCouponsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsCouponsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for coupons. Admin only.
 */
export const v1PaymentsCouponsUpdate = (
    id: string,
    couponRequest: CouponRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Coupon>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/coupons/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: couponRequest
    },
      options);
    }
  


export const getV1PaymentsCouponsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsUpdate>>, TError,{id: string;data: CouponRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsUpdate>>, TError,{id: string;data: CouponRequest}, TContext> => {

const mutationKey = ['v1PaymentsCouponsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsCouponsUpdate>>, {id: string;data: CouponRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1PaymentsCouponsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsCouponsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsCouponsUpdate>>>
    export type V1PaymentsCouponsUpdateMutationBody = CouponRequest
    export type V1PaymentsCouponsUpdateMutationError = unknown

    export const useV1PaymentsCouponsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsUpdate>>, TError,{id: string;data: CouponRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsCouponsUpdate>>,
        TError,
        {id: string;data: CouponRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsCouponsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for coupons. Admin only.
 */
export const v1PaymentsCouponsPartialUpdate = (
    id: string,
    patchedCouponRequest: PatchedCouponRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Coupon>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/coupons/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCouponRequest
    },
      options);
    }
  


export const getV1PaymentsCouponsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsPartialUpdate>>, TError,{id: string;data: PatchedCouponRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsPartialUpdate>>, TError,{id: string;data: PatchedCouponRequest}, TContext> => {

const mutationKey = ['v1PaymentsCouponsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsCouponsPartialUpdate>>, {id: string;data: PatchedCouponRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1PaymentsCouponsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsCouponsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsCouponsPartialUpdate>>>
    export type V1PaymentsCouponsPartialUpdateMutationBody = PatchedCouponRequest
    export type V1PaymentsCouponsPartialUpdateMutationError = unknown

    export const useV1PaymentsCouponsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsPartialUpdate>>, TError,{id: string;data: PatchedCouponRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsCouponsPartialUpdate>>,
        TError,
        {id: string;data: PatchedCouponRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsCouponsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for coupons. Admin only.
 */
export const v1PaymentsCouponsDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/coupons/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1PaymentsCouponsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1PaymentsCouponsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsCouponsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1PaymentsCouponsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsCouponsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsCouponsDestroy>>>
    
    export type V1PaymentsCouponsDestroyMutationError = unknown

    export const useV1PaymentsCouponsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCouponsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsCouponsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1PaymentsCouponsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Placeholder for generic payment creation.
Will be replaced with actual gateway integration.
 */
export const v1PaymentsCreatePaymentCreate = (
    genericResponseRequest: GenericResponseRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<GenericResponse>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/create-payment/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: genericResponseRequest, signal
    },
      options);
    }
  


export const getV1PaymentsCreatePaymentCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCreatePaymentCreate>>, TError,{data: GenericResponseRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCreatePaymentCreate>>, TError,{data: GenericResponseRequest}, TContext> => {

const mutationKey = ['v1PaymentsCreatePaymentCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsCreatePaymentCreate>>, {data: GenericResponseRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1PaymentsCreatePaymentCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsCreatePaymentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsCreatePaymentCreate>>>
    export type V1PaymentsCreatePaymentCreateMutationBody = GenericResponseRequest
    export type V1PaymentsCreatePaymentCreateMutationError = unknown

    export const useV1PaymentsCreatePaymentCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsCreatePaymentCreate>>, TError,{data: GenericResponseRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsCreatePaymentCreate>>,
        TError,
        {data: GenericResponseRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsCreatePaymentCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read‚Äëonly invoices. Users can view their own; admins view all.
PDF download added as a custom action.
 */
export const v1PaymentsInvoicesList = (
    params?: V1PaymentsInvoicesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedInvoiceList>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/invoices/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1PaymentsInvoicesListQueryKey = (params?: V1PaymentsInvoicesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/invoices/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1PaymentsInvoicesListQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError = unknown>(params?: V1PaymentsInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsInvoicesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>> = ({ signal }) => v1PaymentsInvoicesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsInvoicesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>>
export type V1PaymentsInvoicesListQueryError = unknown


export function useV1PaymentsInvoicesList<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError = unknown>(
 params: undefined |  V1PaymentsInvoicesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsInvoicesList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsInvoicesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsInvoicesList<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError = unknown>(
 params?: V1PaymentsInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsInvoicesList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsInvoicesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsInvoicesList<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError = unknown>(
 params?: V1PaymentsInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsInvoicesList<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError = unknown>(
 params?: V1PaymentsInvoicesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsInvoicesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Read‚Äëonly invoices. Users can view their own; admins view all.
PDF download added as a custom action.
 */
export const v1PaymentsInvoicesRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Invoice>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/invoices/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1PaymentsInvoicesRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/invoices/${id}/`
    ] as const;
    }

    
export const getV1PaymentsInvoicesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsInvoicesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>> = ({ signal }) => v1PaymentsInvoicesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsInvoicesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>>
export type V1PaymentsInvoicesRetrieveQueryError = unknown


export function useV1PaymentsInvoicesRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsInvoicesRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsInvoicesRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsInvoicesRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsInvoicesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Serve the invoice PDF securely.
 */
export const v1PaymentsInvoicesDownloadRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Invoice>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/invoices/${id}/download/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1PaymentsInvoicesDownloadRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/invoices/${id}/download/`
    ] as const;
    }

    
export const getV1PaymentsInvoicesDownloadRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsInvoicesDownloadRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>> = ({ signal }) => v1PaymentsInvoicesDownloadRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsInvoicesDownloadRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>>
export type V1PaymentsInvoicesDownloadRetrieveQueryError = unknown


export function useV1PaymentsInvoicesDownloadRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsInvoicesDownloadRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsInvoicesDownloadRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsInvoicesDownloadRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsInvoicesDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsInvoicesDownloadRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List all payments and invoices for the authenticated user.
Pagination is handled automatically via DRF settings.
 */
export const v1PaymentsMyTransactionsList = (
    params?: V1PaymentsMyTransactionsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedTransactionList>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/my-transactions/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1PaymentsMyTransactionsListQueryKey = (params?: V1PaymentsMyTransactionsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/my-transactions/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1PaymentsMyTransactionsListQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError = unknown>(params?: V1PaymentsMyTransactionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsMyTransactionsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>> = ({ signal }) => v1PaymentsMyTransactionsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsMyTransactionsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>>
export type V1PaymentsMyTransactionsListQueryError = unknown


export function useV1PaymentsMyTransactionsList<TData = Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError = unknown>(
 params: undefined |  V1PaymentsMyTransactionsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsMyTransactionsList<TData = Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError = unknown>(
 params?: V1PaymentsMyTransactionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsMyTransactionsList<TData = Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError = unknown>(
 params?: V1PaymentsMyTransactionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsMyTransactionsList<TData = Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError = unknown>(
 params?: V1PaymentsMyTransactionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsMyTransactionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsMyTransactionsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Placeholder for Payment CRUD operations.
Replace with actual implementation when ready.
 */
export const v1PaymentsPaymentsList = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaymentPlaceholder[]>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/payments/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1PaymentsPaymentsListQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/payments/`
    ] as const;
    }

    
export const getV1PaymentsPaymentsListQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsPaymentsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>> = ({ signal }) => v1PaymentsPaymentsList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsPaymentsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>>
export type V1PaymentsPaymentsListQueryError = unknown


export function useV1PaymentsPaymentsList<TData = Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsPaymentsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsPaymentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsPaymentsList<TData = Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsPaymentsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsPaymentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsPaymentsList<TData = Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsPaymentsList<TData = Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPaymentsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsPaymentsListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List and retrieve available subscription plans.
(New view, added without disruption)
 */
export const v1PaymentsPlansList = (
    params?: V1PaymentsPlansListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedPlanList>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/plans/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1PaymentsPlansListQueryKey = (params?: V1PaymentsPlansListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/plans/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1PaymentsPlansListQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError = unknown>(params?: V1PaymentsPlansListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsPlansListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsPlansList>>> = ({ signal }) => v1PaymentsPlansList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsPlansListQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsPlansList>>>
export type V1PaymentsPlansListQueryError = unknown


export function useV1PaymentsPlansList<TData = Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError = unknown>(
 params: undefined |  V1PaymentsPlansListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsPlansList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsPlansList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsPlansList<TData = Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError = unknown>(
 params?: V1PaymentsPlansListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsPlansList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsPlansList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsPlansList<TData = Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError = unknown>(
 params?: V1PaymentsPlansListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsPlansList<TData = Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError = unknown>(
 params?: V1PaymentsPlansListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsPlansListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List and retrieve available subscription plans.
(New view, added without disruption)
 */
export const v1PaymentsPlansRetrieve = (
    code: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Plan>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/plans/${code}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1PaymentsPlansRetrieveQueryKey = (code?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/plans/${code}/`
    ] as const;
    }

    
export const getV1PaymentsPlansRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError = unknown>(code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsPlansRetrieveQueryKey(code);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>> = ({ signal }) => v1PaymentsPlansRetrieve(code, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(code), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsPlansRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>>
export type V1PaymentsPlansRetrieveQueryError = unknown


export function useV1PaymentsPlansRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError = unknown>(
 code: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsPlansRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError = unknown>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsPlansRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError = unknown>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsPlansRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError = unknown>(
 code: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsPlansRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsPlansRetrieveQueryOptions(code,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for subscriptions. Only admins can list all; users can view their own.
Creation is disabled via serializer validation; use webhooks.
 */
export const v1PaymentsSubscriptionsList = (
    params?: V1PaymentsSubscriptionsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSubscriptionList>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1PaymentsSubscriptionsListQueryKey = (params?: V1PaymentsSubscriptionsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/subscriptions/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1PaymentsSubscriptionsListQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError = unknown>(params?: V1PaymentsSubscriptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsSubscriptionsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>> = ({ signal }) => v1PaymentsSubscriptionsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsSubscriptionsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>>
export type V1PaymentsSubscriptionsListQueryError = unknown


export function useV1PaymentsSubscriptionsList<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError = unknown>(
 params: undefined |  V1PaymentsSubscriptionsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsSubscriptionsList<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError = unknown>(
 params?: V1PaymentsSubscriptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsSubscriptionsList<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError = unknown>(
 params?: V1PaymentsSubscriptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsSubscriptionsList<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError = unknown>(
 params?: V1PaymentsSubscriptionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsSubscriptionsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for subscriptions. Only admins can list all; users can view their own.
Creation is disabled via serializer validation; use webhooks.
 */
export const v1PaymentsSubscriptionsCreate = (
    subscriptionRequest: SubscriptionRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Subscription>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: subscriptionRequest, signal
    },
      options);
    }
  


export const getV1PaymentsSubscriptionsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCreate>>, TError,{data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCreate>>, TError,{data: SubscriptionRequest}, TContext> => {

const mutationKey = ['v1PaymentsSubscriptionsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCreate>>, {data: SubscriptionRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1PaymentsSubscriptionsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsSubscriptionsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCreate>>>
    export type V1PaymentsSubscriptionsCreateMutationBody = SubscriptionRequest
    export type V1PaymentsSubscriptionsCreateMutationError = unknown

    export const useV1PaymentsSubscriptionsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCreate>>, TError,{data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsSubscriptionsCreate>>,
        TError,
        {data: SubscriptionRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsSubscriptionsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for subscriptions. Only admins can list all; users can view their own.
Creation is disabled via serializer validation; use webhooks.
 */
export const v1PaymentsSubscriptionsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Subscription>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1PaymentsSubscriptionsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/payments/subscriptions/${id}/`
    ] as const;
    }

    
export const getV1PaymentsSubscriptionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1PaymentsSubscriptionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>> = ({ signal }) => v1PaymentsSubscriptionsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1PaymentsSubscriptionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>>
export type V1PaymentsSubscriptionsRetrieveQueryError = unknown


export function useV1PaymentsSubscriptionsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsSubscriptionsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1PaymentsSubscriptionsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1PaymentsSubscriptionsRetrieve<TData = Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1PaymentsSubscriptionsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for subscriptions. Only admins can list all; users can view their own.
Creation is disabled via serializer validation; use webhooks.
 */
export const v1PaymentsSubscriptionsUpdate = (
    id: string,
    subscriptionRequest: SubscriptionRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Subscription>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: subscriptionRequest
    },
      options);
    }
  


export const getV1PaymentsSubscriptionsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsUpdate>>, TError,{id: string;data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsUpdate>>, TError,{id: string;data: SubscriptionRequest}, TContext> => {

const mutationKey = ['v1PaymentsSubscriptionsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsUpdate>>, {id: string;data: SubscriptionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1PaymentsSubscriptionsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsSubscriptionsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsUpdate>>>
    export type V1PaymentsSubscriptionsUpdateMutationBody = SubscriptionRequest
    export type V1PaymentsSubscriptionsUpdateMutationError = unknown

    export const useV1PaymentsSubscriptionsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsUpdate>>, TError,{id: string;data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsSubscriptionsUpdate>>,
        TError,
        {id: string;data: SubscriptionRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsSubscriptionsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for subscriptions. Only admins can list all; users can view their own.
Creation is disabled via serializer validation; use webhooks.
 */
export const v1PaymentsSubscriptionsPartialUpdate = (
    id: string,
    patchedSubscriptionRequest: PatchedSubscriptionRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Subscription>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedSubscriptionRequest
    },
      options);
    }
  


export const getV1PaymentsSubscriptionsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsPartialUpdate>>, TError,{id: string;data: PatchedSubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsPartialUpdate>>, TError,{id: string;data: PatchedSubscriptionRequest}, TContext> => {

const mutationKey = ['v1PaymentsSubscriptionsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsPartialUpdate>>, {id: string;data: PatchedSubscriptionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1PaymentsSubscriptionsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsSubscriptionsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsPartialUpdate>>>
    export type V1PaymentsSubscriptionsPartialUpdateMutationBody = PatchedSubscriptionRequest
    export type V1PaymentsSubscriptionsPartialUpdateMutationError = unknown

    export const useV1PaymentsSubscriptionsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsPartialUpdate>>, TError,{id: string;data: PatchedSubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsSubscriptionsPartialUpdate>>,
        TError,
        {id: string;data: PatchedSubscriptionRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsSubscriptionsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for subscriptions. Only admins can list all; users can view their own.
Creation is disabled via serializer validation; use webhooks.
 */
export const v1PaymentsSubscriptionsDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1PaymentsSubscriptionsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1PaymentsSubscriptionsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1PaymentsSubscriptionsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsSubscriptionsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsDestroy>>>
    
    export type V1PaymentsSubscriptionsDestroyMutationError = unknown

    export const useV1PaymentsSubscriptionsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsSubscriptionsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1PaymentsSubscriptionsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Cancel a subscription.
- If `immediate=true` is passed, cancel immediately (ends now).
- Otherwise, sets `cancel_at_period_end=true` (cancels at end of current period).
Only the subscription owner or an admin can cancel.
 */
export const v1PaymentsSubscriptionsCancelCreate = (
    id: string,
    subscriptionRequest: SubscriptionRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Subscription>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/${id}/cancel/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: subscriptionRequest, signal
    },
      options);
    }
  


export const getV1PaymentsSubscriptionsCancelCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCancelCreate>>, TError,{id: string;data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCancelCreate>>, TError,{id: string;data: SubscriptionRequest}, TContext> => {

const mutationKey = ['v1PaymentsSubscriptionsCancelCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCancelCreate>>, {id: string;data: SubscriptionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1PaymentsSubscriptionsCancelCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsSubscriptionsCancelCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCancelCreate>>>
    export type V1PaymentsSubscriptionsCancelCreateMutationBody = SubscriptionRequest
    export type V1PaymentsSubscriptionsCancelCreateMutationError = unknown

    export const useV1PaymentsSubscriptionsCancelCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsCancelCreate>>, TError,{id: string;data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsSubscriptionsCancelCreate>>,
        TError,
        {id: string;data: SubscriptionRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsSubscriptionsCancelCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Endpoint for payment gateway webhooks to create/update subscriptions.
Implement idempotency key handling and signature verification.
 */
export const v1PaymentsSubscriptionsWebhookCreate = (
    subscriptionRequest: SubscriptionRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Subscription>(
      {url: `http://localhost:8000/api/v1/api/v1/payments/subscriptions/webhook/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: subscriptionRequest, signal
    },
      options);
    }
  


export const getV1PaymentsSubscriptionsWebhookCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsWebhookCreate>>, TError,{data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsWebhookCreate>>, TError,{data: SubscriptionRequest}, TContext> => {

const mutationKey = ['v1PaymentsSubscriptionsWebhookCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1PaymentsSubscriptionsWebhookCreate>>, {data: SubscriptionRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1PaymentsSubscriptionsWebhookCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1PaymentsSubscriptionsWebhookCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1PaymentsSubscriptionsWebhookCreate>>>
    export type V1PaymentsSubscriptionsWebhookCreateMutationBody = SubscriptionRequest
    export type V1PaymentsSubscriptionsWebhookCreateMutationError = unknown

    export const useV1PaymentsSubscriptionsWebhookCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1PaymentsSubscriptionsWebhookCreate>>, TError,{data: SubscriptionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1PaymentsSubscriptionsWebhookCreate>>,
        TError,
        {data: SubscriptionRequest},
        TContext
      > => {

      const mutationOptions = getV1PaymentsSubscriptionsWebhookCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Download software with security checks.
Supports signed, time‚Äëlimited tokens (recommended) and falls back
to the legacy hash‚Äëbased token for backward compatibility.
 */
export const v1ProductsDownloadRetrieve = (
    slug: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/${slug}/download/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsDownloadRetrieveQueryKey = (slug?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/${slug}/download/`
    ] as const;
    }

    
export const getV1ProductsDownloadRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError = unknown>(slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsDownloadRetrieveQueryKey(slug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>> = ({ signal }) => v1ProductsDownloadRetrieve(slug, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsDownloadRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>>
export type V1ProductsDownloadRetrieveQueryError = unknown


export function useV1ProductsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError = unknown>(
 slug: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsDownloadRetrieveQueryOptions(slug,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Download software with security checks.
Supports signed, time‚Äëlimited tokens (recommended) and falls back
to the legacy hash‚Äëbased token for backward compatibility.
 */
export const v1ProductsDownloadRetrieve2 = (
    slug: string,
    versionId: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/${slug}/download/${versionId}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsDownloadRetrieve2QueryKey = (slug?: string,
    versionId?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/${slug}/download/${versionId}/`
    ] as const;
    }

    
export const getV1ProductsDownloadRetrieve2QueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError = unknown>(slug: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsDownloadRetrieve2QueryKey(slug,versionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>> = ({ signal }) => v1ProductsDownloadRetrieve2(slug,versionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slug && versionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsDownloadRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>>
export type V1ProductsDownloadRetrieve2QueryError = unknown


export function useV1ProductsDownloadRetrieve2<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError = unknown>(
 slug: string,
    versionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDownloadRetrieve2<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError = unknown>(
 slug: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDownloadRetrieve2<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError = unknown>(
 slug: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsDownloadRetrieve2<TData = Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError = unknown>(
 slug: string,
    versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDownloadRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsDownloadRetrieve2QueryOptions(slug,versionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all versions for a software (public).
 */
export const v1ProductsVersionsList2 = (
    slug: string,
    params?: V1ProductsVersionsList2Params,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSoftwareVersionList>(
      {url: `http://localhost:8000/api/v1/api/v1/products/${slug}/versions/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsVersionsList2QueryKey = (slug?: string,
    params?: V1ProductsVersionsList2Params,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/${slug}/versions/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsVersionsList2QueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError = unknown>(slug: string,
    params?: V1ProductsVersionsList2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsVersionsList2QueryKey(slug,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsVersionsList2>>> = ({ signal }) => v1ProductsVersionsList2(slug,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsVersionsList2QueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsList2>>>
export type V1ProductsVersionsList2QueryError = unknown


export function useV1ProductsVersionsList2<TData = Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError = unknown>(
 slug: string,
    params: undefined |  V1ProductsVersionsList2Params, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsVersionsList2>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsVersionsList2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsVersionsList2<TData = Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError = unknown>(
 slug: string,
    params?: V1ProductsVersionsList2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsVersionsList2>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsVersionsList2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsVersionsList2<TData = Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError = unknown>(
 slug: string,
    params?: V1ProductsVersionsList2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsVersionsList2<TData = Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError = unknown>(
 slug: string,
    params?: V1ProductsVersionsList2Params, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsVersionsList2QueryOptions(slug,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software categories.
 */
export const v1ProductsCategoriesList = (
    params?: V1ProductsCategoriesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedCategoryList>(
      {url: `http://localhost:8000/api/v1/api/v1/products/categories/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsCategoriesListQueryKey = (params?: V1ProductsCategoriesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/categories/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsCategoriesListQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError = unknown>(params?: V1ProductsCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsCategoriesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsCategoriesList>>> = ({ signal }) => v1ProductsCategoriesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsCategoriesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsCategoriesList>>>
export type V1ProductsCategoriesListQueryError = unknown


export function useV1ProductsCategoriesList<TData = Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError = unknown>(
 params: undefined |  V1ProductsCategoriesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsCategoriesList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsCategoriesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsCategoriesList<TData = Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError = unknown>(
 params?: V1ProductsCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsCategoriesList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsCategoriesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsCategoriesList<TData = Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError = unknown>(
 params?: V1ProductsCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsCategoriesList<TData = Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError = unknown>(
 params?: V1ProductsCategoriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsCategoriesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software categories.
 */
export const v1ProductsCategoriesCreate = (
    categoryRequest: CategoryRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Category>(
      {url: `http://localhost:8000/api/v1/api/v1/products/categories/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: categoryRequest, signal
    },
      options);
    }
  


export const getV1ProductsCategoriesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesCreate>>, TError,{data: CategoryRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesCreate>>, TError,{data: CategoryRequest}, TContext> => {

const mutationKey = ['v1ProductsCategoriesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsCategoriesCreate>>, {data: CategoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1ProductsCategoriesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsCategoriesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsCategoriesCreate>>>
    export type V1ProductsCategoriesCreateMutationBody = CategoryRequest
    export type V1ProductsCategoriesCreateMutationError = unknown

    export const useV1ProductsCategoriesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesCreate>>, TError,{data: CategoryRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsCategoriesCreate>>,
        TError,
        {data: CategoryRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsCategoriesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software categories.
 */
export const v1ProductsCategoriesRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Category>(
      {url: `http://localhost:8000/api/v1/api/v1/products/categories/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsCategoriesRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/categories/${id}/`
    ] as const;
    }

    
export const getV1ProductsCategoriesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsCategoriesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>> = ({ signal }) => v1ProductsCategoriesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsCategoriesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>>
export type V1ProductsCategoriesRetrieveQueryError = unknown


export function useV1ProductsCategoriesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsCategoriesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsCategoriesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsCategoriesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsCategoriesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsCategoriesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software categories.
 */
export const v1ProductsCategoriesUpdate = (
    id: string,
    categoryRequest: CategoryRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Category>(
      {url: `http://localhost:8000/api/v1/api/v1/products/categories/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: categoryRequest
    },
      options);
    }
  


export const getV1ProductsCategoriesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesUpdate>>, TError,{id: string;data: CategoryRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesUpdate>>, TError,{id: string;data: CategoryRequest}, TContext> => {

const mutationKey = ['v1ProductsCategoriesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsCategoriesUpdate>>, {id: string;data: CategoryRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsCategoriesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsCategoriesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsCategoriesUpdate>>>
    export type V1ProductsCategoriesUpdateMutationBody = CategoryRequest
    export type V1ProductsCategoriesUpdateMutationError = unknown

    export const useV1ProductsCategoriesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesUpdate>>, TError,{id: string;data: CategoryRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsCategoriesUpdate>>,
        TError,
        {id: string;data: CategoryRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsCategoriesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software categories.
 */
export const v1ProductsCategoriesPartialUpdate = (
    id: string,
    patchedCategoryRequest: PatchedCategoryRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Category>(
      {url: `http://localhost:8000/api/v1/api/v1/products/categories/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCategoryRequest
    },
      options);
    }
  


export const getV1ProductsCategoriesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesPartialUpdate>>, TError,{id: string;data: PatchedCategoryRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesPartialUpdate>>, TError,{id: string;data: PatchedCategoryRequest}, TContext> => {

const mutationKey = ['v1ProductsCategoriesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsCategoriesPartialUpdate>>, {id: string;data: PatchedCategoryRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsCategoriesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsCategoriesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsCategoriesPartialUpdate>>>
    export type V1ProductsCategoriesPartialUpdateMutationBody = PatchedCategoryRequest
    export type V1ProductsCategoriesPartialUpdateMutationError = unknown

    export const useV1ProductsCategoriesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesPartialUpdate>>, TError,{id: string;data: PatchedCategoryRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsCategoriesPartialUpdate>>,
        TError,
        {id: string;data: PatchedCategoryRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsCategoriesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software categories.
 */
export const v1ProductsCategoriesDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/categories/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1ProductsCategoriesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1ProductsCategoriesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsCategoriesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1ProductsCategoriesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsCategoriesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsCategoriesDestroy>>>
    
    export type V1ProductsCategoriesDestroyMutationError = unknown

    export const useV1ProductsCategoriesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsCategoriesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsCategoriesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1ProductsCategoriesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software documents.
 */
export const v1ProductsDocumentsList = (
    params?: V1ProductsDocumentsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSoftwareDocumentList>(
      {url: `http://localhost:8000/api/v1/api/v1/products/documents/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsDocumentsListQueryKey = (params?: V1ProductsDocumentsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/documents/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsDocumentsListQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError = unknown>(params?: V1ProductsDocumentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsDocumentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsDocumentsList>>> = ({ signal }) => v1ProductsDocumentsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsDocumentsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDocumentsList>>>
export type V1ProductsDocumentsListQueryError = unknown


export function useV1ProductsDocumentsList<TData = Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError = unknown>(
 params: undefined |  V1ProductsDocumentsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDocumentsList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDocumentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDocumentsList<TData = Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError = unknown>(
 params?: V1ProductsDocumentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDocumentsList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDocumentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDocumentsList<TData = Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError = unknown>(
 params?: V1ProductsDocumentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsDocumentsList<TData = Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError = unknown>(
 params?: V1ProductsDocumentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsDocumentsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software documents.
 */
export const v1ProductsDocumentsCreate = (
    softwareDocumentRequest: SoftwareDocumentRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareDocument>(
      {url: `http://localhost:8000/api/v1/api/v1/products/documents/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareDocumentRequest, signal
    },
      options);
    }
  


export const getV1ProductsDocumentsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsCreate>>, TError,{data: SoftwareDocumentRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsCreate>>, TError,{data: SoftwareDocumentRequest}, TContext> => {

const mutationKey = ['v1ProductsDocumentsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsDocumentsCreate>>, {data: SoftwareDocumentRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1ProductsDocumentsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsDocumentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDocumentsCreate>>>
    export type V1ProductsDocumentsCreateMutationBody = SoftwareDocumentRequest
    export type V1ProductsDocumentsCreateMutationError = unknown

    export const useV1ProductsDocumentsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsCreate>>, TError,{data: SoftwareDocumentRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsDocumentsCreate>>,
        TError,
        {data: SoftwareDocumentRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsDocumentsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software documents.
 */
export const v1ProductsDocumentsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareDocument>(
      {url: `http://localhost:8000/api/v1/api/v1/products/documents/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsDocumentsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/documents/${id}/`
    ] as const;
    }

    
export const getV1ProductsDocumentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsDocumentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>> = ({ signal }) => v1ProductsDocumentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsDocumentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>>
export type V1ProductsDocumentsRetrieveQueryError = unknown


export function useV1ProductsDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsDocumentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software documents.
 */
export const v1ProductsDocumentsUpdate = (
    id: string,
    softwareDocumentRequest: SoftwareDocumentRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<SoftwareDocument>(
      {url: `http://localhost:8000/api/v1/api/v1/products/documents/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: softwareDocumentRequest
    },
      options);
    }
  


export const getV1ProductsDocumentsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsUpdate>>, TError,{id: string;data: SoftwareDocumentRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsUpdate>>, TError,{id: string;data: SoftwareDocumentRequest}, TContext> => {

const mutationKey = ['v1ProductsDocumentsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsDocumentsUpdate>>, {id: string;data: SoftwareDocumentRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsDocumentsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsDocumentsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDocumentsUpdate>>>
    export type V1ProductsDocumentsUpdateMutationBody = SoftwareDocumentRequest
    export type V1ProductsDocumentsUpdateMutationError = unknown

    export const useV1ProductsDocumentsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsUpdate>>, TError,{id: string;data: SoftwareDocumentRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsDocumentsUpdate>>,
        TError,
        {id: string;data: SoftwareDocumentRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsDocumentsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software documents.
 */
export const v1ProductsDocumentsPartialUpdate = (
    id: string,
    patchedSoftwareDocumentRequest: PatchedSoftwareDocumentRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<SoftwareDocument>(
      {url: `http://localhost:8000/api/v1/api/v1/products/documents/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedSoftwareDocumentRequest
    },
      options);
    }
  


export const getV1ProductsDocumentsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsPartialUpdate>>, TError,{id: string;data: PatchedSoftwareDocumentRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsPartialUpdate>>, TError,{id: string;data: PatchedSoftwareDocumentRequest}, TContext> => {

const mutationKey = ['v1ProductsDocumentsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsDocumentsPartialUpdate>>, {id: string;data: PatchedSoftwareDocumentRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsDocumentsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsDocumentsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDocumentsPartialUpdate>>>
    export type V1ProductsDocumentsPartialUpdateMutationBody = PatchedSoftwareDocumentRequest
    export type V1ProductsDocumentsPartialUpdateMutationError = unknown

    export const useV1ProductsDocumentsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsPartialUpdate>>, TError,{id: string;data: PatchedSoftwareDocumentRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsDocumentsPartialUpdate>>,
        TError,
        {id: string;data: PatchedSoftwareDocumentRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsDocumentsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software documents.
 */
export const v1ProductsDocumentsDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/documents/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1ProductsDocumentsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1ProductsDocumentsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsDocumentsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1ProductsDocumentsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsDocumentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDocumentsDestroy>>>
    
    export type V1ProductsDocumentsDestroyMutationError = unknown

    export const useV1ProductsDocumentsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsDocumentsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1ProductsDocumentsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software documents.
 */
export const v1ProductsDocumentsDownloadRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareDocument>(
      {url: `http://localhost:8000/api/v1/api/v1/products/documents/${id}/download/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsDocumentsDownloadRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/documents/${id}/download/`
    ] as const;
    }

    
export const getV1ProductsDocumentsDownloadRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsDocumentsDownloadRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>> = ({ signal }) => v1ProductsDocumentsDownloadRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsDocumentsDownloadRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>>
export type V1ProductsDocumentsDownloadRetrieveQueryError = unknown


export function useV1ProductsDocumentsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDocumentsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsDocumentsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsDocumentsDownloadRetrieve<TData = Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsDocumentsDownloadRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsDocumentsDownloadRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get featured software.
 */
export const v1ProductsFeaturedList = (
    params?: V1ProductsFeaturedListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software[]>(
      {url: `http://localhost:8000/api/v1/api/v1/products/featured/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsFeaturedListQueryKey = (params?: V1ProductsFeaturedListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/featured/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsFeaturedListQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError = unknown>(params?: V1ProductsFeaturedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsFeaturedListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsFeaturedList>>> = ({ signal }) => v1ProductsFeaturedList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsFeaturedListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsFeaturedList>>>
export type V1ProductsFeaturedListQueryError = unknown


export function useV1ProductsFeaturedList<TData = Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError = unknown>(
 params: undefined |  V1ProductsFeaturedListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsFeaturedList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsFeaturedList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsFeaturedList<TData = Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError = unknown>(
 params?: V1ProductsFeaturedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsFeaturedList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsFeaturedList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsFeaturedList<TData = Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError = unknown>(
 params?: V1ProductsFeaturedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsFeaturedList<TData = Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError = unknown>(
 params?: V1ProductsFeaturedListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsFeaturedList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsFeaturedListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software images.
 */
export const v1ProductsImagesList = (
    params?: V1ProductsImagesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSoftwareImageList>(
      {url: `http://localhost:8000/api/v1/api/v1/products/images/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsImagesListQueryKey = (params?: V1ProductsImagesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/images/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsImagesListQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsImagesList>>, TError = unknown>(params?: V1ProductsImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsImagesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsImagesList>>> = ({ signal }) => v1ProductsImagesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsImagesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsImagesList>>>
export type V1ProductsImagesListQueryError = unknown


export function useV1ProductsImagesList<TData = Awaited<ReturnType<typeof v1ProductsImagesList>>, TError = unknown>(
 params: undefined |  V1ProductsImagesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsImagesList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsImagesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsImagesList<TData = Awaited<ReturnType<typeof v1ProductsImagesList>>, TError = unknown>(
 params?: V1ProductsImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsImagesList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsImagesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsImagesList<TData = Awaited<ReturnType<typeof v1ProductsImagesList>>, TError = unknown>(
 params?: V1ProductsImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsImagesList<TData = Awaited<ReturnType<typeof v1ProductsImagesList>>, TError = unknown>(
 params?: V1ProductsImagesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsImagesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software images.
 */
export const v1ProductsImagesCreate = (
    softwareImageRequest: SoftwareImageRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareImage>(
      {url: `http://localhost:8000/api/v1/api/v1/products/images/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareImageRequest, signal
    },
      options);
    }
  


export const getV1ProductsImagesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesCreate>>, TError,{data: SoftwareImageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesCreate>>, TError,{data: SoftwareImageRequest}, TContext> => {

const mutationKey = ['v1ProductsImagesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsImagesCreate>>, {data: SoftwareImageRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1ProductsImagesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsImagesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsImagesCreate>>>
    export type V1ProductsImagesCreateMutationBody = SoftwareImageRequest
    export type V1ProductsImagesCreateMutationError = unknown

    export const useV1ProductsImagesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesCreate>>, TError,{data: SoftwareImageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsImagesCreate>>,
        TError,
        {data: SoftwareImageRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsImagesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software images.
 */
export const v1ProductsImagesRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareImage>(
      {url: `http://localhost:8000/api/v1/api/v1/products/images/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsImagesRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/images/${id}/`
    ] as const;
    }

    
export const getV1ProductsImagesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsImagesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>> = ({ signal }) => v1ProductsImagesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsImagesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>>
export type V1ProductsImagesRetrieveQueryError = unknown


export function useV1ProductsImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsImagesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software images.
 */
export const v1ProductsImagesUpdate = (
    id: string,
    softwareImageRequest: SoftwareImageRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<SoftwareImage>(
      {url: `http://localhost:8000/api/v1/api/v1/products/images/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: softwareImageRequest
    },
      options);
    }
  


export const getV1ProductsImagesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesUpdate>>, TError,{id: string;data: SoftwareImageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesUpdate>>, TError,{id: string;data: SoftwareImageRequest}, TContext> => {

const mutationKey = ['v1ProductsImagesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsImagesUpdate>>, {id: string;data: SoftwareImageRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsImagesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsImagesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsImagesUpdate>>>
    export type V1ProductsImagesUpdateMutationBody = SoftwareImageRequest
    export type V1ProductsImagesUpdateMutationError = unknown

    export const useV1ProductsImagesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesUpdate>>, TError,{id: string;data: SoftwareImageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsImagesUpdate>>,
        TError,
        {id: string;data: SoftwareImageRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsImagesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software images.
 */
export const v1ProductsImagesPartialUpdate = (
    id: string,
    patchedSoftwareImageRequest: PatchedSoftwareImageRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<SoftwareImage>(
      {url: `http://localhost:8000/api/v1/api/v1/products/images/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedSoftwareImageRequest
    },
      options);
    }
  


export const getV1ProductsImagesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesPartialUpdate>>, TError,{id: string;data: PatchedSoftwareImageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesPartialUpdate>>, TError,{id: string;data: PatchedSoftwareImageRequest}, TContext> => {

const mutationKey = ['v1ProductsImagesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsImagesPartialUpdate>>, {id: string;data: PatchedSoftwareImageRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsImagesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsImagesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsImagesPartialUpdate>>>
    export type V1ProductsImagesPartialUpdateMutationBody = PatchedSoftwareImageRequest
    export type V1ProductsImagesPartialUpdateMutationError = unknown

    export const useV1ProductsImagesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesPartialUpdate>>, TError,{id: string;data: PatchedSoftwareImageRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsImagesPartialUpdate>>,
        TError,
        {id: string;data: PatchedSoftwareImageRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsImagesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software images.
 */
export const v1ProductsImagesDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/images/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1ProductsImagesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1ProductsImagesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsImagesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1ProductsImagesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsImagesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsImagesDestroy>>>
    
    export type V1ProductsImagesDestroyMutationError = unknown

    export const useV1ProductsImagesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsImagesDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsImagesDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1ProductsImagesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get new software releases.
 */
export const v1ProductsNewReleasesList = (
    params?: V1ProductsNewReleasesListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSoftwareList>(
      {url: `http://localhost:8000/api/v1/api/v1/products/new-releases/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsNewReleasesListQueryKey = (params?: V1ProductsNewReleasesListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/new-releases/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsNewReleasesListQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError = unknown>(params?: V1ProductsNewReleasesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsNewReleasesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>> = ({ signal }) => v1ProductsNewReleasesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsNewReleasesListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>>
export type V1ProductsNewReleasesListQueryError = unknown


export function useV1ProductsNewReleasesList<TData = Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError = unknown>(
 params: undefined |  V1ProductsNewReleasesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsNewReleasesList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsNewReleasesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsNewReleasesList<TData = Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError = unknown>(
 params?: V1ProductsNewReleasesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsNewReleasesList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsNewReleasesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsNewReleasesList<TData = Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError = unknown>(
 params?: V1ProductsNewReleasesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsNewReleasesList<TData = Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError = unknown>(
 params?: V1ProductsNewReleasesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsNewReleasesList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsNewReleasesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareList = (
    params?: V1ProductsSoftwareListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSoftwareList>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsSoftwareListQueryKey = (params?: V1ProductsSoftwareListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/software/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsSoftwareListQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError = unknown>(params?: V1ProductsSoftwareListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsSoftwareListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsSoftwareList>>> = ({ signal }) => v1ProductsSoftwareList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsSoftwareListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareList>>>
export type V1ProductsSoftwareListQueryError = unknown


export function useV1ProductsSoftwareList<TData = Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError = unknown>(
 params: undefined |  V1ProductsSoftwareListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareList<TData = Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError = unknown>(
 params?: V1ProductsSoftwareListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareList<TData = Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError = unknown>(
 params?: V1ProductsSoftwareListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsSoftwareList<TData = Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError = unknown>(
 params?: V1ProductsSoftwareListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsSoftwareListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareCreate = (
    softwareRequest: SoftwareRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareRequest, signal
    },
      options);
    }
  


export const getV1ProductsSoftwareCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareCreate>>, TError,{data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareCreate>>, TError,{data: SoftwareRequest}, TContext> => {

const mutationKey = ['v1ProductsSoftwareCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsSoftwareCreate>>, {data: SoftwareRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1ProductsSoftwareCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsSoftwareCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareCreate>>>
    export type V1ProductsSoftwareCreateMutationBody = SoftwareRequest
    export type V1ProductsSoftwareCreateMutationError = unknown

    export const useV1ProductsSoftwareCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareCreate>>, TError,{data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsSoftwareCreate>>,
        TError,
        {data: SoftwareRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsSoftwareCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareRetrieve = (
    slug: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsSoftwareRetrieveQueryKey = (slug?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/software/${slug}/`
    ] as const;
    }

    
export const getV1ProductsSoftwareRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError = unknown>(slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsSoftwareRetrieveQueryKey(slug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>> = ({ signal }) => v1ProductsSoftwareRetrieve(slug, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsSoftwareRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>>
export type V1ProductsSoftwareRetrieveQueryError = unknown


export function useV1ProductsSoftwareRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError = unknown>(
 slug: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsSoftwareRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsSoftwareRetrieveQueryOptions(slug,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareUpdate = (
    slug: string,
    softwareRequest: SoftwareRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: softwareRequest
    },
      options);
    }
  


export const getV1ProductsSoftwareUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareUpdate>>, TError,{slug: string;data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareUpdate>>, TError,{slug: string;data: SoftwareRequest}, TContext> => {

const mutationKey = ['v1ProductsSoftwareUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsSoftwareUpdate>>, {slug: string;data: SoftwareRequest}> = (props) => {
          const {slug,data} = props ?? {};

          return  v1ProductsSoftwareUpdate(slug,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsSoftwareUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareUpdate>>>
    export type V1ProductsSoftwareUpdateMutationBody = SoftwareRequest
    export type V1ProductsSoftwareUpdateMutationError = unknown

    export const useV1ProductsSoftwareUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareUpdate>>, TError,{slug: string;data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsSoftwareUpdate>>,
        TError,
        {slug: string;data: SoftwareRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsSoftwareUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwarePartialUpdate = (
    slug: string,
    patchedSoftwareRequest: PatchedSoftwareRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedSoftwareRequest
    },
      options);
    }
  


export const getV1ProductsSoftwarePartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwarePartialUpdate>>, TError,{slug: string;data: PatchedSoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwarePartialUpdate>>, TError,{slug: string;data: PatchedSoftwareRequest}, TContext> => {

const mutationKey = ['v1ProductsSoftwarePartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsSoftwarePartialUpdate>>, {slug: string;data: PatchedSoftwareRequest}> = (props) => {
          const {slug,data} = props ?? {};

          return  v1ProductsSoftwarePartialUpdate(slug,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsSoftwarePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwarePartialUpdate>>>
    export type V1ProductsSoftwarePartialUpdateMutationBody = PatchedSoftwareRequest
    export type V1ProductsSoftwarePartialUpdateMutationError = unknown

    export const useV1ProductsSoftwarePartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwarePartialUpdate>>, TError,{slug: string;data: PatchedSoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsSoftwarePartialUpdate>>,
        TError,
        {slug: string;data: PatchedSoftwareRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsSoftwarePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareDestroy = (
    slug: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1ProductsSoftwareDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDestroy>>, TError,{slug: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDestroy>>, TError,{slug: string}, TContext> => {

const mutationKey = ['v1ProductsSoftwareDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsSoftwareDestroy>>, {slug: string}> = (props) => {
          const {slug} = props ?? {};

          return  v1ProductsSoftwareDestroy(slug,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsSoftwareDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareDestroy>>>
    
    export type V1ProductsSoftwareDestroyMutationError = unknown

    export const useV1ProductsSoftwareDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDestroy>>, TError,{slug: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsSoftwareDestroy>>,
        TError,
        {slug: string},
        TContext
      > => {

      const mutationOptions = getV1ProductsSoftwareDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareDocumentsRetrieve = (
    slug: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/documents/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsSoftwareDocumentsRetrieveQueryKey = (slug?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/software/${slug}/documents/`
    ] as const;
    }

    
export const getV1ProductsSoftwareDocumentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError = unknown>(slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsSoftwareDocumentsRetrieveQueryKey(slug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>> = ({ signal }) => v1ProductsSoftwareDocumentsRetrieve(slug, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsSoftwareDocumentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>>
export type V1ProductsSoftwareDocumentsRetrieveQueryError = unknown


export function useV1ProductsSoftwareDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError = unknown>(
 slug: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsSoftwareDocumentsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareDocumentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsSoftwareDocumentsRetrieveQueryOptions(slug,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareImagesRetrieve = (
    slug: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/images/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsSoftwareImagesRetrieveQueryKey = (slug?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/software/${slug}/images/`
    ] as const;
    }

    
export const getV1ProductsSoftwareImagesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError = unknown>(slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsSoftwareImagesRetrieveQueryKey(slug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>> = ({ signal }) => v1ProductsSoftwareImagesRetrieve(slug, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsSoftwareImagesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>>
export type V1ProductsSoftwareImagesRetrieveQueryError = unknown


export function useV1ProductsSoftwareImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError = unknown>(
 slug: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsSoftwareImagesRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareImagesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsSoftwareImagesRetrieveQueryOptions(slug,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareToggleActiveCreate = (
    slug: string,
    softwareRequest: SoftwareRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/toggle_active/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareRequest, signal
    },
      options);
    }
  


export const getV1ProductsSoftwareToggleActiveCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareToggleActiveCreate>>, TError,{slug: string;data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareToggleActiveCreate>>, TError,{slug: string;data: SoftwareRequest}, TContext> => {

const mutationKey = ['v1ProductsSoftwareToggleActiveCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsSoftwareToggleActiveCreate>>, {slug: string;data: SoftwareRequest}> = (props) => {
          const {slug,data} = props ?? {};

          return  v1ProductsSoftwareToggleActiveCreate(slug,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsSoftwareToggleActiveCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareToggleActiveCreate>>>
    export type V1ProductsSoftwareToggleActiveCreateMutationBody = SoftwareRequest
    export type V1ProductsSoftwareToggleActiveCreateMutationError = unknown

    export const useV1ProductsSoftwareToggleActiveCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareToggleActiveCreate>>, TError,{slug: string;data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsSoftwareToggleActiveCreate>>,
        TError,
        {slug: string;data: SoftwareRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsSoftwareToggleActiveCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareToggleFeaturedCreate = (
    slug: string,
    softwareRequest: SoftwareRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/toggle_featured/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareRequest, signal
    },
      options);
    }
  


export const getV1ProductsSoftwareToggleFeaturedCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareToggleFeaturedCreate>>, TError,{slug: string;data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareToggleFeaturedCreate>>, TError,{slug: string;data: SoftwareRequest}, TContext> => {

const mutationKey = ['v1ProductsSoftwareToggleFeaturedCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsSoftwareToggleFeaturedCreate>>, {slug: string;data: SoftwareRequest}> = (props) => {
          const {slug,data} = props ?? {};

          return  v1ProductsSoftwareToggleFeaturedCreate(slug,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsSoftwareToggleFeaturedCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareToggleFeaturedCreate>>>
    export type V1ProductsSoftwareToggleFeaturedCreateMutationBody = SoftwareRequest
    export type V1ProductsSoftwareToggleFeaturedCreateMutationError = unknown

    export const useV1ProductsSoftwareToggleFeaturedCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsSoftwareToggleFeaturedCreate>>, TError,{slug: string;data: SoftwareRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsSoftwareToggleFeaturedCreate>>,
        TError,
        {slug: string;data: SoftwareRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsSoftwareToggleFeaturedCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software products.
 */
export const v1ProductsSoftwareVersionsRetrieve = (
    slug: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Software>(
      {url: `http://localhost:8000/api/v1/api/v1/products/software/${slug}/versions/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsSoftwareVersionsRetrieveQueryKey = (slug?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/software/${slug}/versions/`
    ] as const;
    }

    
export const getV1ProductsSoftwareVersionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError = unknown>(slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsSoftwareVersionsRetrieveQueryKey(slug);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>> = ({ signal }) => v1ProductsSoftwareVersionsRetrieve(slug, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(slug), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsSoftwareVersionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>>
export type V1ProductsSoftwareVersionsRetrieveQueryError = unknown


export function useV1ProductsSoftwareVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError = unknown>(
 slug: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsSoftwareVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsSoftwareVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError = unknown>(
 slug: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsSoftwareVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsSoftwareVersionsRetrieveQueryOptions(slug,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Record a software usage event.
Requires authentication and optionally an activation code.
 */
export const v1ProductsUsageCreate = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/usage/`, method: 'POST', signal
    },
      options);
    }
  


export const getV1ProductsUsageCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsUsageCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsUsageCreate>>, TError,void, TContext> => {

const mutationKey = ['v1ProductsUsageCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsUsageCreate>>, void> = () => {
          

          return  v1ProductsUsageCreate(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsUsageCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsUsageCreate>>>
    
    export type V1ProductsUsageCreateMutationError = unknown

    export const useV1ProductsUsageCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsUsageCreate>>, TError,void, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsUsageCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getV1ProductsUsageCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsList = (
    params?: V1ProductsVersionsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSoftwareVersionList>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ProductsVersionsListQueryKey = (params?: V1ProductsVersionsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/versions/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ProductsVersionsListQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError = unknown>(params?: V1ProductsVersionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsVersionsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsVersionsList>>> = ({ signal }) => v1ProductsVersionsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsVersionsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsList>>>
export type V1ProductsVersionsListQueryError = unknown


export function useV1ProductsVersionsList<TData = Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError = unknown>(
 params: undefined |  V1ProductsVersionsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsVersionsList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsVersionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsVersionsList<TData = Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError = unknown>(
 params?: V1ProductsVersionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsVersionsList>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsVersionsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsVersionsList<TData = Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError = unknown>(
 params?: V1ProductsVersionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsVersionsList<TData = Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError = unknown>(
 params?: V1ProductsVersionsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsVersionsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsCreate = (
    softwareVersionRequest: SoftwareVersionRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareVersion>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareVersionRequest, signal
    },
      options);
    }
  


export const getV1ProductsVersionsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsCreate>>, TError,{data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsCreate>>, TError,{data: SoftwareVersionRequest}, TContext> => {

const mutationKey = ['v1ProductsVersionsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsVersionsCreate>>, {data: SoftwareVersionRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1ProductsVersionsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsVersionsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsCreate>>>
    export type V1ProductsVersionsCreateMutationBody = SoftwareVersionRequest
    export type V1ProductsVersionsCreateMutationError = unknown

    export const useV1ProductsVersionsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsCreate>>, TError,{data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsVersionsCreate>>,
        TError,
        {data: SoftwareVersionRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsVersionsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareVersion>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ProductsVersionsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/products/versions/${id}/`
    ] as const;
    }

    
export const getV1ProductsVersionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ProductsVersionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>> = ({ signal }) => v1ProductsVersionsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ProductsVersionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>>
export type V1ProductsVersionsRetrieveQueryError = unknown


export function useV1ProductsVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ProductsVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ProductsVersionsRetrieve<TData = Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ProductsVersionsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ProductsVersionsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsUpdate = (
    id: string,
    softwareVersionRequest: SoftwareVersionRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<SoftwareVersion>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: softwareVersionRequest
    },
      options);
    }
  


export const getV1ProductsVersionsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsUpdate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsUpdate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext> => {

const mutationKey = ['v1ProductsVersionsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsVersionsUpdate>>, {id: string;data: SoftwareVersionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsVersionsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsVersionsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsUpdate>>>
    export type V1ProductsVersionsUpdateMutationBody = SoftwareVersionRequest
    export type V1ProductsVersionsUpdateMutationError = unknown

    export const useV1ProductsVersionsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsUpdate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsVersionsUpdate>>,
        TError,
        {id: string;data: SoftwareVersionRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsVersionsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsPartialUpdate = (
    id: string,
    patchedSoftwareVersionRequest: PatchedSoftwareVersionRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<SoftwareVersion>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedSoftwareVersionRequest
    },
      options);
    }
  


export const getV1ProductsVersionsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsPartialUpdate>>, TError,{id: string;data: PatchedSoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsPartialUpdate>>, TError,{id: string;data: PatchedSoftwareVersionRequest}, TContext> => {

const mutationKey = ['v1ProductsVersionsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsVersionsPartialUpdate>>, {id: string;data: PatchedSoftwareVersionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsVersionsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsVersionsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsPartialUpdate>>>
    export type V1ProductsVersionsPartialUpdateMutationBody = PatchedSoftwareVersionRequest
    export type V1ProductsVersionsPartialUpdateMutationError = unknown

    export const useV1ProductsVersionsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsPartialUpdate>>, TError,{id: string;data: PatchedSoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsVersionsPartialUpdate>>,
        TError,
        {id: string;data: PatchedSoftwareVersionRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsVersionsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1ProductsVersionsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1ProductsVersionsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsVersionsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1ProductsVersionsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsVersionsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsDestroy>>>
    
    export type V1ProductsVersionsDestroyMutationError = unknown

    export const useV1ProductsVersionsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsVersionsDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1ProductsVersionsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsToggleActiveCreate = (
    id: string,
    softwareVersionRequest: SoftwareVersionRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareVersion>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/${id}/toggle_active/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareVersionRequest, signal
    },
      options);
    }
  


export const getV1ProductsVersionsToggleActiveCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsToggleActiveCreate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsToggleActiveCreate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext> => {

const mutationKey = ['v1ProductsVersionsToggleActiveCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsVersionsToggleActiveCreate>>, {id: string;data: SoftwareVersionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsVersionsToggleActiveCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsVersionsToggleActiveCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsToggleActiveCreate>>>
    export type V1ProductsVersionsToggleActiveCreateMutationBody = SoftwareVersionRequest
    export type V1ProductsVersionsToggleActiveCreateMutationError = unknown

    export const useV1ProductsVersionsToggleActiveCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsToggleActiveCreate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsVersionsToggleActiveCreate>>,
        TError,
        {id: string;data: SoftwareVersionRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsVersionsToggleActiveCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ViewSet for software versions.
 */
export const v1ProductsVersionsToggleBetaCreate = (
    id: string,
    softwareVersionRequest: SoftwareVersionRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SoftwareVersion>(
      {url: `http://localhost:8000/api/v1/api/v1/products/versions/${id}/toggle_beta/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: softwareVersionRequest, signal
    },
      options);
    }
  


export const getV1ProductsVersionsToggleBetaCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsToggleBetaCreate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsToggleBetaCreate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext> => {

const mutationKey = ['v1ProductsVersionsToggleBetaCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ProductsVersionsToggleBetaCreate>>, {id: string;data: SoftwareVersionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ProductsVersionsToggleBetaCreate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ProductsVersionsToggleBetaCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ProductsVersionsToggleBetaCreate>>>
    export type V1ProductsVersionsToggleBetaCreateMutationBody = SoftwareVersionRequest
    export type V1ProductsVersionsToggleBetaCreateMutationError = unknown

    export const useV1ProductsVersionsToggleBetaCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ProductsVersionsToggleBetaCreate>>, TError,{id: string;data: SoftwareVersionRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ProductsVersionsToggleBetaCreate>>,
        TError,
        {id: string;data: SoftwareVersionRequest},
        TContext
      > => {

      const mutationOptions = getV1ProductsVersionsToggleBetaCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read‚Äëonly view of abuse attempts.
- Access restricted to staff.
- Supports filtering by IP and date range.
 */
export const v1abuseAttemptsList = (
    params?: V1abuseAttemptsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedAbuseAttemptList>(
      {url: `http://localhost:8000/api/v1/api/v1/security/abuse-attempts/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1abuseAttemptsListQueryKey = (params?: V1abuseAttemptsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/abuse-attempts/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1abuseAttemptsListQueryOptions = <TData = Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError = unknown>(params?: V1abuseAttemptsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1abuseAttemptsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1abuseAttemptsList>>> = ({ signal }) => v1abuseAttemptsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1abuseAttemptsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1abuseAttemptsList>>>
export type V1abuseAttemptsListQueryError = unknown


export function useV1abuseAttemptsList<TData = Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError = unknown>(
 params: undefined |  V1abuseAttemptsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1abuseAttemptsList>>,
          TError,
          Awaited<ReturnType<typeof v1abuseAttemptsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1abuseAttemptsList<TData = Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError = unknown>(
 params?: V1abuseAttemptsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1abuseAttemptsList>>,
          TError,
          Awaited<ReturnType<typeof v1abuseAttemptsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1abuseAttemptsList<TData = Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError = unknown>(
 params?: V1abuseAttemptsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1abuseAttemptsList<TData = Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError = unknown>(
 params?: V1abuseAttemptsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1abuseAttemptsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Read‚Äëonly view of abuse attempts.
- Access restricted to staff.
- Supports filtering by IP and date range.
 */
export const v1abuseAttemptsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<AbuseAttempt>(
      {url: `http://localhost:8000/api/v1/api/v1/security/abuse-attempts/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1abuseAttemptsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/abuse-attempts/${id}/`
    ] as const;
    }

    
export const getV1abuseAttemptsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1abuseAttemptsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>> = ({ signal }) => v1abuseAttemptsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1abuseAttemptsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>>
export type V1abuseAttemptsRetrieveQueryError = unknown


export function useV1abuseAttemptsRetrieve<TData = Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1abuseAttemptsRetrieve<TData = Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1abuseAttemptsRetrieve<TData = Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1abuseAttemptsRetrieve<TData = Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1abuseAttemptsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1abuseAttemptsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Read‚Äëonly view of abuse alerts.
- Access restricted to staff.
- Supports filtering by alert type and acknowledgment status.
 */
export const v1alertsList = (
    params?: V1alertsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedAbuseAlertList>(
      {url: `http://localhost:8000/api/v1/api/v1/security/alerts/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1alertsListQueryKey = (params?: V1alertsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/alerts/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1alertsListQueryOptions = <TData = Awaited<ReturnType<typeof v1alertsList>>, TError = unknown>(params?: V1alertsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1alertsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1alertsList>>> = ({ signal }) => v1alertsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1alertsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1alertsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1alertsList>>>
export type V1alertsListQueryError = unknown


export function useV1alertsList<TData = Awaited<ReturnType<typeof v1alertsList>>, TError = unknown>(
 params: undefined |  V1alertsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1alertsList>>,
          TError,
          Awaited<ReturnType<typeof v1alertsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1alertsList<TData = Awaited<ReturnType<typeof v1alertsList>>, TError = unknown>(
 params?: V1alertsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1alertsList>>,
          TError,
          Awaited<ReturnType<typeof v1alertsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1alertsList<TData = Awaited<ReturnType<typeof v1alertsList>>, TError = unknown>(
 params?: V1alertsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1alertsList<TData = Awaited<ReturnType<typeof v1alertsList>>, TError = unknown>(
 params?: V1alertsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1alertsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Read‚Äëonly view of abuse alerts.
- Access restricted to staff.
- Supports filtering by alert type and acknowledgment status.
 */
export const v1alertsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<AbuseAlert>(
      {url: `http://localhost:8000/api/v1/api/v1/security/alerts/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1alertsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/alerts/${id}/`
    ] as const;
    }

    
export const getV1alertsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1alertsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1alertsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1alertsRetrieve>>> = ({ signal }) => v1alertsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1alertsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1alertsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1alertsRetrieve>>>
export type V1alertsRetrieveQueryError = unknown


export function useV1alertsRetrieve<TData = Awaited<ReturnType<typeof v1alertsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1alertsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1alertsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1alertsRetrieve<TData = Awaited<ReturnType<typeof v1alertsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1alertsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1alertsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1alertsRetrieve<TData = Awaited<ReturnType<typeof v1alertsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1alertsRetrieve<TData = Awaited<ReturnType<typeof v1alertsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1alertsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1alertsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve audit logs (admin actions). Admin only.
Returns logs with an actor (non‚Äësystem actions), newest first, up to 100 entries.
 */
export const v1auditLogRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/security/audit-log/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1auditLogRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/audit-log/`
    ] as const;
    }

    
export const getV1auditLogRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1auditLogRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1auditLogRetrieve>>> = ({ signal }) => v1auditLogRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1auditLogRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1auditLogRetrieve>>>
export type V1auditLogRetrieveQueryError = unknown


export function useV1auditLogRetrieve<TData = Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1auditLogRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1auditLogRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1auditLogRetrieve<TData = Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1auditLogRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1auditLogRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1auditLogRetrieve<TData = Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1auditLogRetrieve<TData = Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1auditLogRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1auditLogRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for activation code blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
 */
export const v1codeBlacklistList = (
    params?: V1codeBlacklistListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedCodeBlacklistList>(
      {url: `http://localhost:8000/api/v1/api/v1/security/code-blacklist/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1codeBlacklistListQueryKey = (params?: V1codeBlacklistListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/code-blacklist/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1codeBlacklistListQueryOptions = <TData = Awaited<ReturnType<typeof v1codeBlacklistList>>, TError = unknown>(params?: V1codeBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1codeBlacklistListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1codeBlacklistList>>> = ({ signal }) => v1codeBlacklistList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1codeBlacklistListQueryResult = NonNullable<Awaited<ReturnType<typeof v1codeBlacklistList>>>
export type V1codeBlacklistListQueryError = unknown


export function useV1codeBlacklistList<TData = Awaited<ReturnType<typeof v1codeBlacklistList>>, TError = unknown>(
 params: undefined |  V1codeBlacklistListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1codeBlacklistList>>,
          TError,
          Awaited<ReturnType<typeof v1codeBlacklistList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1codeBlacklistList<TData = Awaited<ReturnType<typeof v1codeBlacklistList>>, TError = unknown>(
 params?: V1codeBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1codeBlacklistList>>,
          TError,
          Awaited<ReturnType<typeof v1codeBlacklistList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1codeBlacklistList<TData = Awaited<ReturnType<typeof v1codeBlacklistList>>, TError = unknown>(
 params?: V1codeBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1codeBlacklistList<TData = Awaited<ReturnType<typeof v1codeBlacklistList>>, TError = unknown>(
 params?: V1codeBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1codeBlacklistListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for activation code blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
 */
export const v1codeBlacklistCreate = (
    codeBlacklistRequest: CodeBlacklistRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<CodeBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/code-blacklist/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: codeBlacklistRequest, signal
    },
      options);
    }
  


export const getV1codeBlacklistCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistCreate>>, TError,{data: CodeBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistCreate>>, TError,{data: CodeBlacklistRequest}, TContext> => {

const mutationKey = ['v1codeBlacklistCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1codeBlacklistCreate>>, {data: CodeBlacklistRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1codeBlacklistCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1codeBlacklistCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1codeBlacklistCreate>>>
    export type V1codeBlacklistCreateMutationBody = CodeBlacklistRequest
    export type V1codeBlacklistCreateMutationError = unknown

    export const useV1codeBlacklistCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistCreate>>, TError,{data: CodeBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1codeBlacklistCreate>>,
        TError,
        {data: CodeBlacklistRequest},
        TContext
      > => {

      const mutationOptions = getV1codeBlacklistCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for activation code blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
 */
export const v1codeBlacklistRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<CodeBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/code-blacklist/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1codeBlacklistRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/code-blacklist/${id}/`
    ] as const;
    }

    
export const getV1codeBlacklistRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1codeBlacklistRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>> = ({ signal }) => v1codeBlacklistRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1codeBlacklistRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>>
export type V1codeBlacklistRetrieveQueryError = unknown


export function useV1codeBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1codeBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1codeBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1codeBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1codeBlacklistRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1codeBlacklistRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for activation code blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
 */
export const v1codeBlacklistUpdate = (
    id: string,
    codeBlacklistRequest: CodeBlacklistRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<CodeBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/code-blacklist/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: codeBlacklistRequest
    },
      options);
    }
  


export const getV1codeBlacklistUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistUpdate>>, TError,{id: string;data: CodeBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistUpdate>>, TError,{id: string;data: CodeBlacklistRequest}, TContext> => {

const mutationKey = ['v1codeBlacklistUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1codeBlacklistUpdate>>, {id: string;data: CodeBlacklistRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1codeBlacklistUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1codeBlacklistUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1codeBlacklistUpdate>>>
    export type V1codeBlacklistUpdateMutationBody = CodeBlacklistRequest
    export type V1codeBlacklistUpdateMutationError = unknown

    export const useV1codeBlacklistUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistUpdate>>, TError,{id: string;data: CodeBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1codeBlacklistUpdate>>,
        TError,
        {id: string;data: CodeBlacklistRequest},
        TContext
      > => {

      const mutationOptions = getV1codeBlacklistUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for activation code blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
 */
export const v1codeBlacklistPartialUpdate = (
    id: string,
    patchedCodeBlacklistRequest: PatchedCodeBlacklistRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<CodeBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/code-blacklist/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCodeBlacklistRequest
    },
      options);
    }
  


export const getV1codeBlacklistPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistPartialUpdate>>, TError,{id: string;data: PatchedCodeBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistPartialUpdate>>, TError,{id: string;data: PatchedCodeBlacklistRequest}, TContext> => {

const mutationKey = ['v1codeBlacklistPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1codeBlacklistPartialUpdate>>, {id: string;data: PatchedCodeBlacklistRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1codeBlacklistPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1codeBlacklistPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1codeBlacklistPartialUpdate>>>
    export type V1codeBlacklistPartialUpdateMutationBody = PatchedCodeBlacklistRequest
    export type V1codeBlacklistPartialUpdateMutationError = unknown

    export const useV1codeBlacklistPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistPartialUpdate>>, TError,{id: string;data: PatchedCodeBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1codeBlacklistPartialUpdate>>,
        TError,
        {id: string;data: PatchedCodeBlacklistRequest},
        TContext
      > => {

      const mutationOptions = getV1codeBlacklistPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for activation code blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
 */
export const v1codeBlacklistDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/security/code-blacklist/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1codeBlacklistDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1codeBlacklistDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1codeBlacklistDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1codeBlacklistDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1codeBlacklistDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1codeBlacklistDestroy>>>
    
    export type V1codeBlacklistDestroyMutationError = unknown

    export const useV1codeBlacklistDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1codeBlacklistDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1codeBlacklistDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1codeBlacklistDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Generate and return a device fingerprint based on the request.
Useful for testing and debugging. Accessible only to authenticated users.
 */
export const v1deviceCheckRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/security/device-check/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1deviceCheckRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/device-check/`
    ] as const;
    }

    
export const getV1deviceCheckRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1deviceCheckRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>> = ({ signal }) => v1deviceCheckRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1deviceCheckRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>>
export type V1deviceCheckRetrieveQueryError = unknown


export function useV1deviceCheckRetrieve<TData = Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1deviceCheckRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1deviceCheckRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1deviceCheckRetrieve<TData = Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1deviceCheckRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1deviceCheckRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1deviceCheckRetrieve<TData = Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1deviceCheckRetrieve<TData = Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1deviceCheckRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1deviceCheckRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for IP blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
- Supports filtering by IP address, active status, and searching by reason.
 */
export const v1ipBlacklistList = (
    params?: V1ipBlacklistListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedIPBlacklistList>(
      {url: `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1ipBlacklistListQueryKey = (params?: V1ipBlacklistListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1ipBlacklistListQueryOptions = <TData = Awaited<ReturnType<typeof v1ipBlacklistList>>, TError = unknown>(params?: V1ipBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ipBlacklistListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ipBlacklistList>>> = ({ signal }) => v1ipBlacklistList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ipBlacklistListQueryResult = NonNullable<Awaited<ReturnType<typeof v1ipBlacklistList>>>
export type V1ipBlacklistListQueryError = unknown


export function useV1ipBlacklistList<TData = Awaited<ReturnType<typeof v1ipBlacklistList>>, TError = unknown>(
 params: undefined |  V1ipBlacklistListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ipBlacklistList>>,
          TError,
          Awaited<ReturnType<typeof v1ipBlacklistList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ipBlacklistList<TData = Awaited<ReturnType<typeof v1ipBlacklistList>>, TError = unknown>(
 params?: V1ipBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ipBlacklistList>>,
          TError,
          Awaited<ReturnType<typeof v1ipBlacklistList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ipBlacklistList<TData = Awaited<ReturnType<typeof v1ipBlacklistList>>, TError = unknown>(
 params?: V1ipBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ipBlacklistList<TData = Awaited<ReturnType<typeof v1ipBlacklistList>>, TError = unknown>(
 params?: V1ipBlacklistListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ipBlacklistListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for IP blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
- Supports filtering by IP address, active status, and searching by reason.
 */
export const v1ipBlacklistCreate = (
    iPBlacklistRequest: IPBlacklistRequest,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<IPBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: iPBlacklistRequest, signal
    },
      options);
    }
  


export const getV1ipBlacklistCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistCreate>>, TError,{data: IPBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistCreate>>, TError,{data: IPBlacklistRequest}, TContext> => {

const mutationKey = ['v1ipBlacklistCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ipBlacklistCreate>>, {data: IPBlacklistRequest}> = (props) => {
          const {data} = props ?? {};

          return  v1ipBlacklistCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ipBlacklistCreateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ipBlacklistCreate>>>
    export type V1ipBlacklistCreateMutationBody = IPBlacklistRequest
    export type V1ipBlacklistCreateMutationError = unknown

    export const useV1ipBlacklistCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistCreate>>, TError,{data: IPBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ipBlacklistCreate>>,
        TError,
        {data: IPBlacklistRequest},
        TContext
      > => {

      const mutationOptions = getV1ipBlacklistCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for IP blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
- Supports filtering by IP address, active status, and searching by reason.
 */
export const v1ipBlacklistRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<IPBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1ipBlacklistRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/${id}/`
    ] as const;
    }

    
export const getV1ipBlacklistRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1ipBlacklistRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>> = ({ signal }) => v1ipBlacklistRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1ipBlacklistRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>>
export type V1ipBlacklistRetrieveQueryError = unknown


export function useV1ipBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ipBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1ipBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1ipBlacklistRetrieve<TData = Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1ipBlacklistRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1ipBlacklistRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * CRUD for IP blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
- Supports filtering by IP address, active status, and searching by reason.
 */
export const v1ipBlacklistUpdate = (
    id: string,
    iPBlacklistRequest: IPBlacklistRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<IPBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: iPBlacklistRequest
    },
      options);
    }
  


export const getV1ipBlacklistUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistUpdate>>, TError,{id: string;data: IPBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistUpdate>>, TError,{id: string;data: IPBlacklistRequest}, TContext> => {

const mutationKey = ['v1ipBlacklistUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ipBlacklistUpdate>>, {id: string;data: IPBlacklistRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ipBlacklistUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ipBlacklistUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ipBlacklistUpdate>>>
    export type V1ipBlacklistUpdateMutationBody = IPBlacklistRequest
    export type V1ipBlacklistUpdateMutationError = unknown

    export const useV1ipBlacklistUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistUpdate>>, TError,{id: string;data: IPBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ipBlacklistUpdate>>,
        TError,
        {id: string;data: IPBlacklistRequest},
        TContext
      > => {

      const mutationOptions = getV1ipBlacklistUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for IP blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
- Supports filtering by IP address, active status, and searching by reason.
 */
export const v1ipBlacklistPartialUpdate = (
    id: string,
    patchedIPBlacklistRequest: PatchedIPBlacklistRequest,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<IPBlacklist>(
      {url: `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedIPBlacklistRequest
    },
      options);
    }
  


export const getV1ipBlacklistPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistPartialUpdate>>, TError,{id: string;data: PatchedIPBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistPartialUpdate>>, TError,{id: string;data: PatchedIPBlacklistRequest}, TContext> => {

const mutationKey = ['v1ipBlacklistPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ipBlacklistPartialUpdate>>, {id: string;data: PatchedIPBlacklistRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  v1ipBlacklistPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ipBlacklistPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof v1ipBlacklistPartialUpdate>>>
    export type V1ipBlacklistPartialUpdateMutationBody = PatchedIPBlacklistRequest
    export type V1ipBlacklistPartialUpdateMutationError = unknown

    export const useV1ipBlacklistPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistPartialUpdate>>, TError,{id: string;data: PatchedIPBlacklistRequest}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ipBlacklistPartialUpdate>>,
        TError,
        {id: string;data: PatchedIPBlacklistRequest},
        TContext
      > => {

      const mutationOptions = getV1ipBlacklistPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * CRUD for IP blacklist entries.
- Superusers can create, update, delete.
- Staff members can only view.
- Supports filtering by IP address, active status, and searching by reason.
 */
export const v1ipBlacklistDestroy = (
    id: string,
 options?: SecondParameter<typeof apiClient>,) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/security/ip-blacklist/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getV1ipBlacklistDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
): UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['v1ipBlacklistDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof v1ipBlacklistDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  v1ipBlacklistDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type V1ipBlacklistDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof v1ipBlacklistDestroy>>>
    
    export type V1ipBlacklistDestroyMutationError = unknown

    export const useV1ipBlacklistDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof v1ipBlacklistDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof v1ipBlacklistDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getV1ipBlacklistDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read‚Äëonly view of security notification logs.
- Access restricted to staff.
- Supports filtering by risk level and user.
 */
export const v1securityLogsList = (
    params?: V1securityLogsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedSecurityNotificationLogList>(
      {url: `http://localhost:8000/api/v1/api/v1/security/security-logs/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getV1securityLogsListQueryKey = (params?: V1securityLogsListParams,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/security-logs/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getV1securityLogsListQueryOptions = <TData = Awaited<ReturnType<typeof v1securityLogsList>>, TError = unknown>(params?: V1securityLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1securityLogsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1securityLogsList>>> = ({ signal }) => v1securityLogsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1securityLogsListQueryResult = NonNullable<Awaited<ReturnType<typeof v1securityLogsList>>>
export type V1securityLogsListQueryError = unknown


export function useV1securityLogsList<TData = Awaited<ReturnType<typeof v1securityLogsList>>, TError = unknown>(
 params: undefined |  V1securityLogsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1securityLogsList>>,
          TError,
          Awaited<ReturnType<typeof v1securityLogsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1securityLogsList<TData = Awaited<ReturnType<typeof v1securityLogsList>>, TError = unknown>(
 params?: V1securityLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1securityLogsList>>,
          TError,
          Awaited<ReturnType<typeof v1securityLogsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1securityLogsList<TData = Awaited<ReturnType<typeof v1securityLogsList>>, TError = unknown>(
 params?: V1securityLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1securityLogsList<TData = Awaited<ReturnType<typeof v1securityLogsList>>, TError = unknown>(
 params?: V1securityLogsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1securityLogsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Read‚Äëonly view of security notification logs.
- Access restricted to staff.
- Supports filtering by risk level and user.
 */
export const v1securityLogsRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<SecurityNotificationLog>(
      {url: `http://localhost:8000/api/v1/api/v1/security/security-logs/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1securityLogsRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/security-logs/${id}/`
    ] as const;
    }

    
export const getV1securityLogsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1securityLogsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1securityLogsRetrieve>>> = ({ signal }) => v1securityLogsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1securityLogsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1securityLogsRetrieve>>>
export type V1securityLogsRetrieveQueryError = unknown


export function useV1securityLogsRetrieve<TData = Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1securityLogsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1securityLogsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1securityLogsRetrieve<TData = Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1securityLogsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1securityLogsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1securityLogsRetrieve<TData = Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1securityLogsRetrieve<TData = Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1securityLogsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1securityLogsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get current security settings (admin only).
Returns a subset of Django settings relevant to security.
 */
export const v1settingsRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/security/settings/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1settingsRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/settings/`
    ] as const;
    }

    
export const getV1settingsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1settingsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1settingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1settingsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1settingsRetrieve>>> = ({ signal }) => v1settingsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1settingsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1settingsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1settingsRetrieve>>>
export type V1settingsRetrieveQueryError = unknown


export function useV1settingsRetrieve<TData = Awaited<ReturnType<typeof v1settingsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1settingsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1settingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1settingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1settingsRetrieve<TData = Awaited<ReturnType<typeof v1settingsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1settingsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1settingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1settingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1settingsRetrieve<TData = Awaited<ReturnType<typeof v1settingsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1settingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1settingsRetrieve<TData = Awaited<ReturnType<typeof v1settingsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1settingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1settingsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return recent suspicious activities (abuse attempts + security logs).
Admin only. Accepts optional 'limit' query parameter (default 50).
 */
export const v1suspiciousActivityRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/security/suspicious-activity/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1suspiciousActivityRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/security/suspicious-activity/`
    ] as const;
    }

    
export const getV1suspiciousActivityRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1suspiciousActivityRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>> = ({ signal }) => v1suspiciousActivityRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1suspiciousActivityRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>>
export type V1suspiciousActivityRetrieveQueryError = unknown


export function useV1suspiciousActivityRetrieve<TData = Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1suspiciousActivityRetrieve<TData = Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1suspiciousActivityRetrieve<TData = Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1suspiciousActivityRetrieve<TData = Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1suspiciousActivityRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1suspiciousActivityRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Public endpoint to check API health and version.
Returns 200 OK when the API is operational.
 */
export const v1StatusRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/status/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1StatusRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/status/`
    ] as const;
    }

    
export const getV1StatusRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1StatusRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1StatusRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1StatusRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1StatusRetrieve>>> = ({ signal }) => v1StatusRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1StatusRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1StatusRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1StatusRetrieve>>>
export type V1StatusRetrieveQueryError = unknown


export function useV1StatusRetrieve<TData = Awaited<ReturnType<typeof v1StatusRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1StatusRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1StatusRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1StatusRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1StatusRetrieve<TData = Awaited<ReturnType<typeof v1StatusRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1StatusRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1StatusRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1StatusRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1StatusRetrieve<TData = Awaited<ReturnType<typeof v1StatusRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1StatusRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1StatusRetrieve<TData = Awaited<ReturnType<typeof v1StatusRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1StatusRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1StatusRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * System configuration endpoint (admin only).
Returns non‚Äësensitive configuration parameters.
 */
export const v1SystemConfigRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/system/config/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1SystemConfigRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/system/config/`
    ] as const;
    }

    
export const getV1SystemConfigRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1SystemConfigRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>> = ({ signal }) => v1SystemConfigRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1SystemConfigRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>>
export type V1SystemConfigRetrieveQueryError = unknown


export function useV1SystemConfigRetrieve<TData = Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1SystemConfigRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1SystemConfigRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1SystemConfigRetrieve<TData = Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1SystemConfigRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1SystemConfigRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1SystemConfigRetrieve<TData = Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1SystemConfigRetrieve<TData = Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemConfigRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1SystemConfigRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * System health check endpoint (admin only).
Returns status of critical services: database, cache, etc.
 */
export const v1SystemHealthRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/system/health/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1SystemHealthRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/system/health/`
    ] as const;
    }

    
export const getV1SystemHealthRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1SystemHealthRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>> = ({ signal }) => v1SystemHealthRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1SystemHealthRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>>
export type V1SystemHealthRetrieveQueryError = unknown


export function useV1SystemHealthRetrieve<TData = Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1SystemHealthRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1SystemHealthRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1SystemHealthRetrieve<TData = Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1SystemHealthRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1SystemHealthRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1SystemHealthRetrieve<TData = Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1SystemHealthRetrieve<TData = Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemHealthRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1SystemHealthRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * System metrics endpoint (admin only).
Returns basic performance metrics (placeholder for now).
 */
export const v1SystemMetricsRetrieve = (
    
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/api/v1/system/metrics/`, method: 'GET', signal
    },
      options);
    }
  



export const getV1SystemMetricsRetrieveQueryKey = () => {
    return [
    `http://localhost:8000/api/v1/api/v1/system/metrics/`
    ] as const;
    }

    
export const getV1SystemMetricsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getV1SystemMetricsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>> = ({ signal }) => v1SystemMetricsRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type V1SystemMetricsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>>
export type V1SystemMetricsRetrieveQueryError = unknown


export function useV1SystemMetricsRetrieve<TData = Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1SystemMetricsRetrieve<TData = Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useV1SystemMetricsRetrieve<TData = Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useV1SystemMetricsRetrieve<TData = Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof v1SystemMetricsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getV1SystemMetricsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Redirect to the best mirror for a given software version and artifact type.
- Simple usage (defaults to 'installer'): /file/<version_id>/
- Explicit usage: /file/<version_id>/<artifact_type>/
Requires authentication and a valid license.
 */
export const distributionFileRetrieve = (
    versionId: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/distribution/file/${versionId}/`, method: 'GET', signal
    },
      options);
    }
  



export const getDistributionFileRetrieveQueryKey = (versionId?: string,) => {
    return [
    `http://localhost:8000/api/v1/distribution/file/${versionId}/`
    ] as const;
    }

    
export const getDistributionFileRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof distributionFileRetrieve>>, TError = unknown>(versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDistributionFileRetrieveQueryKey(versionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof distributionFileRetrieve>>> = ({ signal }) => distributionFileRetrieve(versionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(versionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DistributionFileRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof distributionFileRetrieve>>>
export type DistributionFileRetrieveQueryError = unknown


export function useDistributionFileRetrieve<TData = Awaited<ReturnType<typeof distributionFileRetrieve>>, TError = unknown>(
 versionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof distributionFileRetrieve>>,
          TError,
          Awaited<ReturnType<typeof distributionFileRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDistributionFileRetrieve<TData = Awaited<ReturnType<typeof distributionFileRetrieve>>, TError = unknown>(
 versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof distributionFileRetrieve>>,
          TError,
          Awaited<ReturnType<typeof distributionFileRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDistributionFileRetrieve<TData = Awaited<ReturnType<typeof distributionFileRetrieve>>, TError = unknown>(
 versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDistributionFileRetrieve<TData = Awaited<ReturnType<typeof distributionFileRetrieve>>, TError = unknown>(
 versionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDistributionFileRetrieveQueryOptions(versionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Redirect to the best mirror for a given software version and artifact type.
- Simple usage (defaults to 'installer'): /file/<version_id>/
- Explicit usage: /file/<version_id>/<artifact_type>/
Requires authentication and a valid license.
 */
export const distributionFileRetrieve2 = (
    versionId: string,
    artifactType: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<void>(
      {url: `http://localhost:8000/api/v1/distribution/file/${versionId}/${artifactType}/`, method: 'GET', signal
    },
      options);
    }
  



export const getDistributionFileRetrieve2QueryKey = (versionId?: string,
    artifactType?: string,) => {
    return [
    `http://localhost:8000/api/v1/distribution/file/${versionId}/${artifactType}/`
    ] as const;
    }

    
export const getDistributionFileRetrieve2QueryOptions = <TData = Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError = unknown>(versionId: string,
    artifactType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDistributionFileRetrieve2QueryKey(versionId,artifactType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof distributionFileRetrieve2>>> = ({ signal }) => distributionFileRetrieve2(versionId,artifactType, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(versionId && artifactType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DistributionFileRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof distributionFileRetrieve2>>>
export type DistributionFileRetrieve2QueryError = unknown


export function useDistributionFileRetrieve2<TData = Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError = unknown>(
 versionId: string,
    artifactType: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof distributionFileRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof distributionFileRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDistributionFileRetrieve2<TData = Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError = unknown>(
 versionId: string,
    artifactType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof distributionFileRetrieve2>>,
          TError,
          Awaited<ReturnType<typeof distributionFileRetrieve2>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDistributionFileRetrieve2<TData = Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError = unknown>(
 versionId: string,
    artifactType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDistributionFileRetrieve2<TData = Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError = unknown>(
 versionId: string,
    artifactType: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionFileRetrieve2>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDistributionFileRetrieve2QueryOptions(versionId,artifactType,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List active mirrors (public).
 */
export const distributionMirrorsList = (
    params?: DistributionMirrorsListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedMirrorList>(
      {url: `http://localhost:8000/api/v1/distribution/mirrors/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getDistributionMirrorsListQueryKey = (params?: DistributionMirrorsListParams,) => {
    return [
    `http://localhost:8000/api/v1/distribution/mirrors/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getDistributionMirrorsListQueryOptions = <TData = Awaited<ReturnType<typeof distributionMirrorsList>>, TError = unknown>(params?: DistributionMirrorsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionMirrorsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDistributionMirrorsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof distributionMirrorsList>>> = ({ signal }) => distributionMirrorsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof distributionMirrorsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DistributionMirrorsListQueryResult = NonNullable<Awaited<ReturnType<typeof distributionMirrorsList>>>
export type DistributionMirrorsListQueryError = unknown


export function useDistributionMirrorsList<TData = Awaited<ReturnType<typeof distributionMirrorsList>>, TError = unknown>(
 params: undefined |  DistributionMirrorsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionMirrorsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof distributionMirrorsList>>,
          TError,
          Awaited<ReturnType<typeof distributionMirrorsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDistributionMirrorsList<TData = Awaited<ReturnType<typeof distributionMirrorsList>>, TError = unknown>(
 params?: DistributionMirrorsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionMirrorsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof distributionMirrorsList>>,
          TError,
          Awaited<ReturnType<typeof distributionMirrorsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDistributionMirrorsList<TData = Awaited<ReturnType<typeof distributionMirrorsList>>, TError = unknown>(
 params?: DistributionMirrorsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionMirrorsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDistributionMirrorsList<TData = Awaited<ReturnType<typeof distributionMirrorsList>>, TError = unknown>(
 params?: DistributionMirrorsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof distributionMirrorsList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDistributionMirrorsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * List notifications for the authenticated user.
 */
export const apiList = (
    params?: ApiListParams,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<PaginatedNotificationList>(
      {url: `http://localhost:8000/api/v1/notifications/api/notifications/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getApiListQueryKey = (params?: ApiListParams,) => {
    return [
    `http://localhost:8000/api/v1/notifications/api/notifications/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getApiListQueryOptions = <TData = Awaited<ReturnType<typeof apiList>>, TError = unknown>(params?: ApiListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiList>>> = ({ signal }) => apiList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiListQueryResult = NonNullable<Awaited<ReturnType<typeof apiList>>>
export type ApiListQueryError = unknown


export function useApiList<TData = Awaited<ReturnType<typeof apiList>>, TError = unknown>(
 params: undefined |  ApiListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiList>>,
          TError,
          Awaited<ReturnType<typeof apiList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiList<TData = Awaited<ReturnType<typeof apiList>>, TError = unknown>(
 params?: ApiListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiList>>,
          TError,
          Awaited<ReturnType<typeof apiList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiList<TData = Awaited<ReturnType<typeof apiList>>, TError = unknown>(
 params?: ApiListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiList<TData = Awaited<ReturnType<typeof apiList>>, TError = unknown>(
 params?: ApiListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiList>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a single notification (and mark it as read automatically).
 */
export const apiRetrieve = (
    id: string,
 options?: SecondParameter<typeof apiClient>,signal?: AbortSignal
) => {
      
      
      return apiClient<Notification>(
      {url: `http://localhost:8000/api/v1/notifications/api/notifications/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getApiRetrieveQueryKey = (id?: string,) => {
    return [
    `http://localhost:8000/api/v1/notifications/api/notifications/${id}/`
    ] as const;
    }

    
export const getApiRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiRetrieve>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRetrieve>>> = ({ signal }) => apiRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiRetrieve>>>
export type ApiRetrieveQueryError = unknown


export function useApiRetrieve<TData = Awaited<ReturnType<typeof apiRetrieve>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiRetrieve<TData = Awaited<ReturnType<typeof apiRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiRetrieve<TData = Awaited<ReturnType<typeof apiRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiRetrieve<TData = Awaited<ReturnType<typeof apiRetrieve>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiRetrieve>>, TError, TData>>, request?: SecondParameter<typeof apiClient>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const getCohortsListResponseMock = (): CohortAggregate[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), cohort_date: faker.date.past().toISOString().split('T')[0], period: faker.helpers.arrayElement(Object.values(PeriodEnum)), period_number: faker.number.int({min: undefined, max: undefined}), user_count: faker.number.int({min: undefined, max: undefined}), retained_count: faker.number.int({min: undefined, max: undefined}), retention_rate: faker.helpers.fromRegExp('^-?\d{0,3}(?:\.\d{0,2})?$'), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})))

export const getDailyListResponseMock = (): DailyAggregate[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), date: faker.date.past().toISOString().split('T')[0], total_users: faker.number.int({min: undefined, max: undefined}), active_users: faker.number.int({min: undefined, max: undefined}), new_users: faker.number.int({min: undefined, max: undefined}), total_sales: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), total_orders: faker.number.int({min: undefined, max: undefined}), licenses_activated: faker.number.int({min: undefined, max: undefined}), licenses_expired: faker.number.int({min: undefined, max: undefined}), total_usage_events: faker.number.int({min: undefined, max: undefined}), abuse_attempts: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})))

export const getDailyRetrieveResponseMock = (overrideResponse: Partial< DailyAggregate > = {}): DailyAggregate => ({id: faker.string.uuid(), date: faker.date.past().toISOString().split('T')[0], total_users: faker.number.int({min: undefined, max: undefined}), active_users: faker.number.int({min: undefined, max: undefined}), new_users: faker.number.int({min: undefined, max: undefined}), total_sales: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), total_orders: faker.number.int({min: undefined, max: undefined}), licenses_activated: faker.number.int({min: undefined, max: undefined}), licenses_expired: faker.number.int({min: undefined, max: undefined}), total_usage_events: faker.number.int({min: undefined, max: undefined}), abuse_attempts: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getExportsListResponseMock = (overrideResponse: Partial< PaginatedExportJobList > = {}): PaginatedExportJobList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), export_type: faker.helpers.arrayElement(Object.values(ExportTypeEnum)), status: faker.helpers.arrayElement(Object.values(ExportJobStatusEnum)), parameters: faker.helpers.arrayElement([{}, undefined]), file: faker.helpers.arrayElement([faker.internet.url(), null]), file_url: faker.internet.url(), error_message: faker.string.alpha({length: {min: 10, max: 20}}), created_by: faker.helpers.arrayElement([faker.string.uuid(), null]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), ...overrideResponse})

export const getExportsCreateResponseMock = (overrideResponse: Partial< ExportJob > = {}): ExportJob => ({id: faker.string.uuid(), export_type: faker.helpers.arrayElement(Object.values(ExportTypeEnum)), status: faker.helpers.arrayElement(Object.values(ExportJobStatusEnum)), parameters: faker.helpers.arrayElement([{}, undefined]), file: faker.helpers.arrayElement([faker.internet.url(), null]), file_url: faker.internet.url(), error_message: faker.string.alpha({length: {min: 10, max: 20}}), created_by: faker.helpers.arrayElement([faker.string.uuid(), null]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ...overrideResponse})

export const getExportsRetrieveResponseMock = (overrideResponse: Partial< ExportJob > = {}): ExportJob => ({id: faker.string.uuid(), export_type: faker.helpers.arrayElement(Object.values(ExportTypeEnum)), status: faker.helpers.arrayElement(Object.values(ExportJobStatusEnum)), parameters: faker.helpers.arrayElement([{}, undefined]), file: faker.helpers.arrayElement([faker.internet.url(), null]), file_url: faker.internet.url(), error_message: faker.string.alpha({length: {min: 10, max: 20}}), created_by: faker.helpers.arrayElement([faker.string.uuid(), null]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, completed_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ...overrideResponse})

export const getExportsDownloadRetrieveResponseMock = (): ExportsDownloadRetrieve200 => ({
        [faker.string.alphanumeric(5)]: {}
      })

export const getV1Auth2faEmergencyVerifyCreateResponseMock = (overrideResponse: Partial< EmergencyTwoFactorVerify > = {}): EmergencyTwoFactorVerify => ({verification_token: faker.string.alpha({length: {min: 10, max: 20}}), mfa_code: faker.string.alpha({length: {min: 6, max: 8}}), ...overrideResponse})

export const getV1AuthActionsListResponseMock = (overrideResponse: Partial< PaginatedAdminActionLogList > = {}): PaginatedAdminActionLogList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), admin_user: faker.internet.email(), action: faker.string.alpha({length: {min: 10, max: 20}}), target_user: faker.string.alpha({length: {min: 10, max: 20}}), target_model: faker.string.alpha({length: {min: 10, max: 20}}), target_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), details: faker.helpers.arrayElement([{}, undefined]), status: faker.helpers.arrayElement(Object.values(AdminActionLogStatusEnum)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1AuthActionsRetrieveResponseMock = (overrideResponse: Partial< AdminActionLog > = {}): AdminActionLog => ({id: faker.number.int({min: undefined, max: undefined}), admin_user: faker.internet.email(), action: faker.string.alpha({length: {min: 10, max: 20}}), target_user: faker.string.alpha({length: {min: 10, max: 20}}), target_model: faker.string.alpha({length: {min: 10, max: 20}}), target_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), details: faker.helpers.arrayElement([{}, undefined]), status: faker.helpers.arrayElement(Object.values(AdminActionLogStatusEnum)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1AuthAdminProfilesListResponseMock = (overrideResponse: Partial< PaginatedAdminProfileList > = {}): PaginatedAdminProfileList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user: faker.string.uuid(), user_email: faker.internet.email(), department: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1AuthAdminProfilesCreateResponseMock = (overrideResponse: Partial< AdminProfile > = {}): AdminProfile => ({id: faker.string.uuid(), user: faker.string.uuid(), user_email: faker.internet.email(), department: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1AuthAdminProfilesRetrieveResponseMock = (overrideResponse: Partial< AdminProfile > = {}): AdminProfile => ({id: faker.string.uuid(), user: faker.string.uuid(), user_email: faker.internet.email(), department: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1AuthAdminProfilesUpdateResponseMock = (overrideResponse: Partial< AdminProfile > = {}): AdminProfile => ({id: faker.string.uuid(), user: faker.string.uuid(), user_email: faker.internet.email(), department: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1AuthAdminProfilesPartialUpdateResponseMock = (overrideResponse: Partial< AdminProfile > = {}): AdminProfile => ({id: faker.string.uuid(), user: faker.string.uuid(), user_email: faker.internet.email(), department: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1AuthLoginCreateResponseMock = (overrideResponse: Partial< CustomTokenObtainPair > = {}): CustomTokenObtainPair => ({device_fingerprint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getV1AuthRegisterCreateResponseMock = (overrideResponse: Partial< UserRegistration > = {}): UserRegistration => ({email: faker.internet.email(), role: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(RoleEnum)), undefined]), first_name: faker.string.alpha({length: {min: 10, max: 150}}), last_name: faker.string.alpha({length: {min: 10, max: 150}}), company: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getV1AuthResetPasswordCreateResponseMock = (overrideResponse: Partial< PasswordResetRequest > = {}): PasswordResetRequest => ({email: faker.internet.email(), ...overrideResponse})

export const getV1AuthResetPasswordConfirmCreateResponseMock = (overrideResponse: Partial< PasswordResetConfirm > = {}): PasswordResetConfirm => ({token: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1AuthSessionsListResponseMock = (overrideResponse: Partial< PaginatedUserSessionList > = {}): PaginatedUserSessionList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), device_fingerprint: faker.string.alpha({length: {min: 10, max: 20}}), device_type: faker.string.alpha({length: {min: 10, max: 20}}), is_current: faker.string.alpha({length: {min: 10, max: 20}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), user_agent: faker.string.alpha({length: {min: 10, max: 20}}), last_activity: `${faker.date.past().toISOString().split('.')[0]}Z`, created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, is_active: faker.datatype.boolean()})), ...overrideResponse})

export const getV1AuthSessionsRetrieveResponseMock = (overrideResponse: Partial< UserSession > = {}): UserSession => ({id: faker.number.int({min: undefined, max: undefined}), device_fingerprint: faker.string.alpha({length: {min: 10, max: 20}}), device_type: faker.string.alpha({length: {min: 10, max: 20}}), is_current: faker.string.alpha({length: {min: 10, max: 20}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), user_agent: faker.string.alpha({length: {min: 10, max: 20}}), last_activity: `${faker.date.past().toISOString().split('.')[0]}Z`, created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, is_active: faker.datatype.boolean(), ...overrideResponse})

export const getV1AuthSessionsRevokeCreateResponseMock = (overrideResponse: Partial< UserSession > = {}): UserSession => ({id: faker.number.int({min: undefined, max: undefined}), device_fingerprint: faker.string.alpha({length: {min: 10, max: 20}}), device_type: faker.string.alpha({length: {min: 10, max: 20}}), is_current: faker.string.alpha({length: {min: 10, max: 20}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), location: faker.string.alpha({length: {min: 10, max: 20}}), user_agent: faker.string.alpha({length: {min: 10, max: 20}}), last_activity: `${faker.date.past().toISOString().split('.')[0]}Z`, created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, is_active: faker.datatype.boolean(), ...overrideResponse})

export const getV1AuthTokenRefreshCreateResponseMock = (overrideResponse: Partial< TokenRefresh > = {}): TokenRefresh => ({access: faker.string.alpha({length: {min: 10, max: 20}}), refresh: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1AuthUsersListResponseMock = (overrideResponse: Partial< PaginatedUserList > = {}): PaginatedUserList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), email: faker.internet.email(), first_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), last_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), role: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(RoleEnum)), undefined]), company: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), date_joined: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_login: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), ...overrideResponse})

export const getV1AuthUsersCreateResponseMock = (overrideResponse: Partial< User > = {}): User => ({id: faker.string.uuid(), email: faker.internet.email(), first_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), last_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), role: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(RoleEnum)), undefined]), company: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), date_joined: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_login: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ...overrideResponse})

export const getV1AuthUsersRetrieveResponseMock = (overrideResponse: Partial< User > = {}): User => ({id: faker.string.uuid(), email: faker.internet.email(), first_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), last_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), role: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(RoleEnum)), undefined]), company: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), date_joined: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_login: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ...overrideResponse})

export const getV1AuthUsersUpdateResponseMock = (overrideResponse: Partial< User > = {}): User => ({id: faker.string.uuid(), email: faker.internet.email(), first_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), last_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), role: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(RoleEnum)), undefined]), company: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), date_joined: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_login: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ...overrideResponse})

export const getV1AuthUsersPartialUpdateResponseMock = (overrideResponse: Partial< User > = {}): User => ({id: faker.string.uuid(), email: faker.internet.email(), first_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), last_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), role: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(RoleEnum)), undefined]), company: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), date_joined: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_login: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ...overrideResponse})

export const getV1AuthUsersMeRetrieveResponseMock = (overrideResponse: Partial< User > = {}): User => ({id: faker.string.uuid(), email: faker.internet.email(), first_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), last_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 150}}), undefined]), role: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(RoleEnum)), undefined]), company: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), date_joined: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_login: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ...overrideResponse})

export const getV1LicensesActivateCreateResponseMock = (overrideResponse: Partial< ActivationRequest > = {}): ActivationRequest => ({activation_code: faker.string.alpha({length: {min: 10, max: 50}}), software_slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), device_fingerprint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), force_activation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getV1LicensesActivationCodesListResponseMock = (overrideResponse: Partial< PaginatedActivationCodeList > = {}): PaginatedActivationCodeList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}})})), ...overrideResponse})

export const getV1LicensesActivationCodesCreateResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesActivationCodesRetrieveResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesActivationCodesUpdateResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesActivationCodesPartialUpdateResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesActivationCodesActivateDeviceCreateResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesActivationCodesDeactivateDeviceCreateResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesActivationCodesLicenseFileRetrieveResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesActivationCodesMyLicensesRetrieveResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesBatchesListResponseMock = (overrideResponse: Partial< PaginatedCodeBatchList > = {}): PaginatedCodeBatchList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 255}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), license_type: faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), count: faker.number.int({min: -2147483648, max: 2147483647}), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), expires_in_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), is_used: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), used_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), unused_count: faker.number.int({min: undefined, max: undefined}), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.internet.email(), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1LicensesBatchesCreateResponseMock = (overrideResponse: Partial< CodeBatch > = {}): CodeBatch => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 255}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), license_type: faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), count: faker.number.int({min: -2147483648, max: 2147483647}), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), expires_in_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), is_used: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), used_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), unused_count: faker.number.int({min: undefined, max: undefined}), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.internet.email(), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesBatchesRetrieveResponseMock = (overrideResponse: Partial< CodeBatch > = {}): CodeBatch => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 255}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), license_type: faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), count: faker.number.int({min: -2147483648, max: 2147483647}), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), expires_in_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), is_used: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), used_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), unused_count: faker.number.int({min: undefined, max: undefined}), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.internet.email(), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesBatchesUpdateResponseMock = (overrideResponse: Partial< CodeBatch > = {}): CodeBatch => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 255}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), license_type: faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), count: faker.number.int({min: -2147483648, max: 2147483647}), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), expires_in_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), is_used: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), used_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), unused_count: faker.number.int({min: undefined, max: undefined}), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.internet.email(), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesBatchesPartialUpdateResponseMock = (overrideResponse: Partial< CodeBatch > = {}): CodeBatch => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 255}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), license_type: faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), count: faker.number.int({min: -2147483648, max: 2147483647}), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), expires_in_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), is_used: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), used_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), unused_count: faker.number.int({min: undefined, max: undefined}), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.internet.email(), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesBatchesCodesRetrieveResponseMock = (overrideResponse: Partial< CodeBatch > = {}): CodeBatch => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 255}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), license_type: faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), count: faker.number.int({min: -2147483648, max: 2147483647}), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), expires_in_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), prefix: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), is_used: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), used_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), unused_count: faker.number.int({min: undefined, max: undefined}), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.internet.email(), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesDeactivateCreateResponseMock = (overrideResponse: Partial< DeactivationRequest > = {}): DeactivationRequest => ({activation_id: faker.string.uuid(), reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), keep_license: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getV1LicensesFeaturesListResponseMock = (overrideResponse: Partial< PaginatedLicenseFeatureList > = {}): PaginatedLicenseFeatureList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), available_in_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_standard: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_premium: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_enterprise: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), requires_activation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), max_usage: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1LicensesFeaturesCreateResponseMock = (overrideResponse: Partial< LicenseFeature > = {}): LicenseFeature => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), available_in_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_standard: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_premium: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_enterprise: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), requires_activation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), max_usage: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesFeaturesRetrieveResponseMock = (overrideResponse: Partial< LicenseFeature > = {}): LicenseFeature => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), available_in_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_standard: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_premium: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_enterprise: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), requires_activation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), max_usage: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesFeaturesUpdateResponseMock = (overrideResponse: Partial< LicenseFeature > = {}): LicenseFeature => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), available_in_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_standard: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_premium: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_enterprise: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), requires_activation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), max_usage: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesFeaturesPartialUpdateResponseMock = (overrideResponse: Partial< LicenseFeature > = {}): LicenseFeature => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), available_in_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_standard: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_premium: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), available_in_enterprise: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), requires_activation: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), max_usage: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesGenerateCreateResponseMock = (overrideResponse: Partial< ActivationCode > = {}): ActivationCode => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1LicensesLogsListResponseMock = (overrideResponse: Partial< PaginatedActivationLogList > = {}): PaginatedActivationLogList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), software_name: faker.string.alpha({length: {min: 10, max: 20}}), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), user_agent: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), action: faker.helpers.arrayElement(Object.values(ActionEnum)), success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), error_message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_suspicious: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), suspicion_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1LicensesLogsRetrieveResponseMock = (overrideResponse: Partial< ActivationLog > = {}): ActivationLog => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), software_name: faker.string.alpha({length: {min: 10, max: 20}}), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), user_agent: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), action: faker.helpers.arrayElement(Object.values(ActionEnum)), success: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), error_message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), is_suspicious: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), suspicion_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesMyLicensesListResponseMock = (overrideResponse: Partial< PaginatedActivationCodeList > = {}): PaginatedActivationCodeList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), software_name: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.string.alpha({length: {min: 10, max: 20}}), software_app_code: faker.string.alpha({length: {min: 10, max: 20}}), software_version: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), batch_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), encrypted_code: faker.string.alpha({length: {min: 10, max: 20}}), code_hash: faker.string.alpha({length: {min: 10, max: 20}}), human_code: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(LicenseType6d0Enum)), undefined]), status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActivationCodeStatusEnum)), undefined]), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), user_email: faker.helpers.arrayElement([faker.internet.email(), null]), generated_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), generated_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), max_activations: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), activation_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), concurrent_limit: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), device_fingerprint: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 64}}), null]), undefined]), device_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), device_info: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, activated_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), expires_at: `${faker.date.past().toISOString().split('.')[0]}Z`, last_used_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), revoked_by: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), revoked_by_email: faker.helpers.arrayElement([faker.internet.email(), null]), revoked_reason: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), custom_data: faker.helpers.arrayElement([{}, undefined]), is_valid: faker.datatype.boolean(), is_expired: faker.datatype.boolean(), is_revoked: faker.datatype.boolean(), remaining_activations: faker.number.int({min: undefined, max: undefined}), days_until_expiry: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), null]), license_file: faker.string.alpha({length: {min: 10, max: 20}})})), ...overrideResponse})

export const getV1LicensesRevokeCreateResponseMock = (overrideResponse: Partial< RevocationRequest > = {}): RevocationRequest => ({activation_id: faker.string.uuid(), reason: faker.string.alpha({length: {min: 10, max: 20}}), notify_user: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getV1LicensesRevokeCreate2ResponseMock = (overrideResponse: Partial< RevocationRequest > = {}): RevocationRequest => ({activation_id: faker.string.uuid(), reason: faker.string.alpha({length: {min: 10, max: 20}}), notify_user: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getV1LicensesUsageListResponseMock = (overrideResponse: Partial< PaginatedLicenseUsageList > = {}): PaginatedLicenseUsageList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), feature: faker.string.uuid(), feature_name: faker.string.alpha({length: {min: 10, max: 20}}), feature_code: faker.string.alpha({length: {min: 10, max: 20}}), usage_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), usage_data: faker.helpers.arrayElement([{}, undefined]), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1LicensesUsageCreateResponseMock = (overrideResponse: Partial< LicenseUsage > = {}): LicenseUsage => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), feature: faker.string.uuid(), feature_name: faker.string.alpha({length: {min: 10, max: 20}}), feature_code: faker.string.alpha({length: {min: 10, max: 20}}), usage_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), usage_data: faker.helpers.arrayElement([{}, undefined]), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesUsageRetrieveResponseMock = (overrideResponse: Partial< LicenseUsage > = {}): LicenseUsage => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), feature: faker.string.uuid(), feature_name: faker.string.alpha({length: {min: 10, max: 20}}), feature_code: faker.string.alpha({length: {min: 10, max: 20}}), usage_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), usage_data: faker.helpers.arrayElement([{}, undefined]), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesUsageUpdateResponseMock = (overrideResponse: Partial< LicenseUsage > = {}): LicenseUsage => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), feature: faker.string.uuid(), feature_name: faker.string.alpha({length: {min: 10, max: 20}}), feature_code: faker.string.alpha({length: {min: 10, max: 20}}), usage_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), usage_data: faker.helpers.arrayElement([{}, undefined]), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesUsagePartialUpdateResponseMock = (overrideResponse: Partial< LicenseUsage > = {}): LicenseUsage => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), feature: faker.string.uuid(), feature_name: faker.string.alpha({length: {min: 10, max: 20}}), feature_code: faker.string.alpha({length: {min: 10, max: 20}}), usage_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), usage_data: faker.helpers.arrayElement([{}, undefined]), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesUsageLogUsageCreateResponseMock = (overrideResponse: Partial< LicenseUsage > = {}): LicenseUsage => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), activation_code_human: faker.string.alpha({length: {min: 10, max: 20}}), feature: faker.string.uuid(), feature_name: faker.string.alpha({length: {min: 10, max: 20}}), feature_code: faker.string.alpha({length: {min: 10, max: 20}}), usage_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), usage_data: faker.helpers.arrayElement([{}, undefined]), device_fingerprint: faker.string.alpha({length: {min: 10, max: 64}}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1LicensesValidateCreateResponseMock = (overrideResponse: Partial< ValidateActivation > = {}): ValidateActivation => ({activation_code: faker.string.alpha({length: {min: 10, max: 20}}), software_slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), device_fingerprint: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), check_only: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getV1PaymentsCouponsListResponseMock = (overrideResponse: Partial< PaginatedCouponList > = {}): PaginatedCouponList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), discount_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(DiscountTypeEnum)), undefined]), discount_value: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), max_discount: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), null]), undefined]), valid_from: `${faker.date.past().toISOString().split('.')[0]}Z`, valid_until: `${faker.date.past().toISOString().split('.')[0]}Z`, max_uses: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), max_uses_per_user: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), minimum_purchase: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), times_used: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, applicable_software: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.uuid())), undefined])})), ...overrideResponse})

export const getV1PaymentsCouponsCreateResponseMock = (overrideResponse: Partial< Coupon > = {}): Coupon => ({id: faker.string.uuid(), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), discount_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(DiscountTypeEnum)), undefined]), discount_value: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), max_discount: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), null]), undefined]), valid_from: `${faker.date.past().toISOString().split('.')[0]}Z`, valid_until: `${faker.date.past().toISOString().split('.')[0]}Z`, max_uses: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), max_uses_per_user: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), minimum_purchase: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), times_used: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, applicable_software: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.uuid())), undefined]), ...overrideResponse})

export const getV1PaymentsCouponsRetrieveResponseMock = (overrideResponse: Partial< Coupon > = {}): Coupon => ({id: faker.string.uuid(), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), discount_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(DiscountTypeEnum)), undefined]), discount_value: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), max_discount: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), null]), undefined]), valid_from: `${faker.date.past().toISOString().split('.')[0]}Z`, valid_until: `${faker.date.past().toISOString().split('.')[0]}Z`, max_uses: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), max_uses_per_user: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), minimum_purchase: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), times_used: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, applicable_software: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.uuid())), undefined]), ...overrideResponse})

export const getV1PaymentsCouponsUpdateResponseMock = (overrideResponse: Partial< Coupon > = {}): Coupon => ({id: faker.string.uuid(), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), discount_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(DiscountTypeEnum)), undefined]), discount_value: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), max_discount: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), null]), undefined]), valid_from: `${faker.date.past().toISOString().split('.')[0]}Z`, valid_until: `${faker.date.past().toISOString().split('.')[0]}Z`, max_uses: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), max_uses_per_user: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), minimum_purchase: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), times_used: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, applicable_software: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.uuid())), undefined]), ...overrideResponse})

export const getV1PaymentsCouponsPartialUpdateResponseMock = (overrideResponse: Partial< Coupon > = {}): Coupon => ({id: faker.string.uuid(), code: faker.string.alpha({length: {min: 10, max: 50}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), discount_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(DiscountTypeEnum)), undefined]), discount_value: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), max_discount: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), null]), undefined]), valid_from: `${faker.date.past().toISOString().split('.')[0]}Z`, valid_until: `${faker.date.past().toISOString().split('.')[0]}Z`, max_uses: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), null]), undefined]), max_uses_per_user: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), minimum_purchase: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), times_used: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, applicable_software: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.uuid())), undefined]), ...overrideResponse})

export const getV1PaymentsCreatePaymentCreateResponseMock = (overrideResponse: Partial< GenericResponse > = {}): GenericResponse => ({status: faker.string.alpha({length: {min: 10, max: 20}}), ...overrideResponse})

export const getV1PaymentsInvoicesListResponseMock = (overrideResponse: Partial< PaginatedInvoiceList > = {}): PaginatedInvoiceList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user: faker.string.alpha({length: {min: 10, max: 20}}), payment: faker.string.uuid(), number: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(Object.values(InvoiceStatusEnum)), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), amount: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), tax: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), total: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), issued_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), paid_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), due_at: `${faker.date.past().toISOString().split('.')[0]}Z`, pdf_file: faker.helpers.arrayElement([faker.internet.url(), null]), metadata: {
        [faker.string.alphanumeric(5)]: {}
      }, created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1PaymentsInvoicesRetrieveResponseMock = (overrideResponse: Partial< Invoice > = {}): Invoice => ({id: faker.string.uuid(), user: faker.string.alpha({length: {min: 10, max: 20}}), payment: faker.string.uuid(), number: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(Object.values(InvoiceStatusEnum)), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), amount: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), tax: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), total: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), issued_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), paid_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), due_at: `${faker.date.past().toISOString().split('.')[0]}Z`, pdf_file: faker.helpers.arrayElement([faker.internet.url(), null]), metadata: {
        [faker.string.alphanumeric(5)]: {}
      }, created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsInvoicesDownloadRetrieveResponseMock = (overrideResponse: Partial< Invoice > = {}): Invoice => ({id: faker.string.uuid(), user: faker.string.alpha({length: {min: 10, max: 20}}), payment: faker.string.uuid(), number: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(Object.values(InvoiceStatusEnum)), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), amount: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), tax: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), total: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), issued_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), paid_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), due_at: `${faker.date.past().toISOString().split('.')[0]}Z`, pdf_file: faker.helpers.arrayElement([faker.internet.url(), null]), metadata: {
        [faker.string.alphanumeric(5)]: {}
      }, created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsMyTransactionsListResponseMock = (overrideResponse: Partial< PaginatedTransactionList > = {}): PaginatedTransactionList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), amount: faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), currency: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(Object.values(TransactionStatusEnum)), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, invoice_number: faker.string.alpha({length: {min: 10, max: 20}}), invoice_id: faker.string.uuid()})), ...overrideResponse})

export const getV1PaymentsPaymentsListResponseMock = (): PaymentPlaceholder[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({status: faker.string.alpha({length: {min: 10, max: 20}})})))

export const getV1PaymentsPlansListResponseMock = (overrideResponse: Partial< PaginatedPlanList > = {}): PaginatedPlanList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1PaymentsPlansRetrieveResponseMock = (overrideResponse: Partial< Plan > = {}): Plan => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsSubscriptionsListResponseMock = (overrideResponse: Partial< PaginatedSubscriptionList > = {}): PaginatedSubscriptionList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user: faker.string.uuid(), plan: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), plan_detail: {...{id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},}, status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SubscriptionStatusEnum)), undefined]), started_at: `${faker.date.past().toISOString().split('.')[0]}Z`, current_period_start: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), current_period_end: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), canceled_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ended_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), cancel_at_period_end: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), gateway: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), gateway_subscription_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), metadata: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1PaymentsSubscriptionsCreateResponseMock = (overrideResponse: Partial< Subscription > = {}): Subscription => ({id: faker.string.uuid(), user: faker.string.uuid(), plan: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), plan_detail: {...{id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},}, status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SubscriptionStatusEnum)), undefined]), started_at: `${faker.date.past().toISOString().split('.')[0]}Z`, current_period_start: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), current_period_end: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), canceled_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ended_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), cancel_at_period_end: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), gateway: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), gateway_subscription_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), metadata: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsSubscriptionsRetrieveResponseMock = (overrideResponse: Partial< Subscription > = {}): Subscription => ({id: faker.string.uuid(), user: faker.string.uuid(), plan: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), plan_detail: {...{id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},}, status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SubscriptionStatusEnum)), undefined]), started_at: `${faker.date.past().toISOString().split('.')[0]}Z`, current_period_start: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), current_period_end: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), canceled_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ended_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), cancel_at_period_end: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), gateway: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), gateway_subscription_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), metadata: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsSubscriptionsUpdateResponseMock = (overrideResponse: Partial< Subscription > = {}): Subscription => ({id: faker.string.uuid(), user: faker.string.uuid(), plan: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), plan_detail: {...{id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},}, status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SubscriptionStatusEnum)), undefined]), started_at: `${faker.date.past().toISOString().split('.')[0]}Z`, current_period_start: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), current_period_end: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), canceled_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ended_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), cancel_at_period_end: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), gateway: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), gateway_subscription_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), metadata: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsSubscriptionsPartialUpdateResponseMock = (overrideResponse: Partial< Subscription > = {}): Subscription => ({id: faker.string.uuid(), user: faker.string.uuid(), plan: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), plan_detail: {...{id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},}, status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SubscriptionStatusEnum)), undefined]), started_at: `${faker.date.past().toISOString().split('.')[0]}Z`, current_period_start: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), current_period_end: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), canceled_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ended_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), cancel_at_period_end: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), gateway: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), gateway_subscription_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), metadata: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsSubscriptionsCancelCreateResponseMock = (overrideResponse: Partial< Subscription > = {}): Subscription => ({id: faker.string.uuid(), user: faker.string.uuid(), plan: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), plan_detail: {...{id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},}, status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SubscriptionStatusEnum)), undefined]), started_at: `${faker.date.past().toISOString().split('.')[0]}Z`, current_period_start: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), current_period_end: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), canceled_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ended_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), cancel_at_period_end: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), gateway: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), gateway_subscription_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), metadata: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1PaymentsSubscriptionsWebhookCreateResponseMock = (overrideResponse: Partial< Subscription > = {}): Subscription => ({id: faker.string.uuid(), user: faker.string.uuid(), plan: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), plan_detail: {...{id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), code: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,10}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), interval: faker.helpers.arrayElement(Object.values(IntervalEnum)), trial_days: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), sort_order: faker.helpers.arrayElement([faker.number.int({min: 0, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`},}, status: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SubscriptionStatusEnum)), undefined]), started_at: `${faker.date.past().toISOString().split('.')[0]}Z`, current_period_start: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), current_period_end: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), canceled_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), ended_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), cancel_at_period_end: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), gateway: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), gateway_subscription_id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), null]), metadata: faker.helpers.arrayElement([{}, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsVersionsList2ResponseMock = (overrideResponse: Partial< PaginatedSoftwareVersionList > = {}): PaginatedSoftwareVersionList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), ...overrideResponse})

export const getV1ProductsCategoriesListResponseMock = (overrideResponse: Partial< PaginatedCategoryList > = {}): PaginatedCategoryList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), parent: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), parent_name: faker.string.alpha({length: {min: 10, max: 20}}), icon: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), software_count: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1ProductsCategoriesCreateResponseMock = (overrideResponse: Partial< Category > = {}): Category => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), parent: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), parent_name: faker.string.alpha({length: {min: 10, max: 20}}), icon: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), software_count: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsCategoriesRetrieveResponseMock = (overrideResponse: Partial< Category > = {}): Category => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), parent: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), parent_name: faker.string.alpha({length: {min: 10, max: 20}}), icon: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), software_count: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsCategoriesUpdateResponseMock = (overrideResponse: Partial< Category > = {}): Category => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), parent: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), parent_name: faker.string.alpha({length: {min: 10, max: 20}}), icon: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), software_count: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsCategoriesPartialUpdateResponseMock = (overrideResponse: Partial< Category > = {}): Category => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 100}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), parent: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), parent_name: faker.string.alpha({length: {min: 10, max: 20}}), icon: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 50}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), software_count: faker.number.int({min: undefined, max: undefined}), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsDocumentsListResponseMock = (overrideResponse: Partial< PaginatedSoftwareDocumentList > = {}): PaginatedSoftwareDocumentList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1ProductsDocumentsCreateResponseMock = (overrideResponse: Partial< SoftwareDocument > = {}): SoftwareDocument => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsDocumentsRetrieveResponseMock = (overrideResponse: Partial< SoftwareDocument > = {}): SoftwareDocument => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsDocumentsUpdateResponseMock = (overrideResponse: Partial< SoftwareDocument > = {}): SoftwareDocument => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsDocumentsPartialUpdateResponseMock = (overrideResponse: Partial< SoftwareDocument > = {}): SoftwareDocument => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsDocumentsDownloadRetrieveResponseMock = (overrideResponse: Partial< SoftwareDocument > = {}): SoftwareDocument => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsFeaturedListResponseMock = (): Software[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})))

export const getV1ProductsImagesListResponseMock = (overrideResponse: Partial< PaginatedSoftwareImageList > = {}): PaginatedSoftwareImageList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1ProductsImagesCreateResponseMock = (overrideResponse: Partial< SoftwareImage > = {}): SoftwareImage => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsImagesRetrieveResponseMock = (overrideResponse: Partial< SoftwareImage > = {}): SoftwareImage => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsImagesUpdateResponseMock = (overrideResponse: Partial< SoftwareImage > = {}): SoftwareImage => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsImagesPartialUpdateResponseMock = (overrideResponse: Partial< SoftwareImage > = {}): SoftwareImage => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsNewReleasesListResponseMock = (overrideResponse: Partial< PaginatedSoftwareList > = {}): PaginatedSoftwareList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1ProductsSoftwareListResponseMock = (overrideResponse: Partial< PaginatedSoftwareList > = {}): PaginatedSoftwareList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1ProductsSoftwareCreateResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwareRetrieveResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwareUpdateResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwarePartialUpdateResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwareDocumentsRetrieveResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwareImagesRetrieveResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwareToggleActiveCreateResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwareToggleFeaturedCreateResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsSoftwareVersionsRetrieveResponseMock = (overrideResponse: Partial< Software > = {}): Software => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 255}}), slug: faker.helpers.fromRegExp('^[-a-zA-Z0-9_]+$'), app_code: faker.string.alpha({length: {min: 10, max: 10}}), category: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), category_name: faker.string.alpha({length: {min: 10, max: 20}}), short_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), full_description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), features: faker.helpers.arrayElement([{}, undefined]), requirements: faker.helpers.arrayElement([{}, undefined]), tags: faker.helpers.arrayElement([{}, undefined]), base_price: faker.helpers.arrayElement([faker.helpers.fromRegExp('^-?\d{0,8}(?:\.\d{0,2})?$'), undefined]), currency: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 3}}), undefined]), license_type: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(SoftwareLicenseTypeEnum)), undefined]), pricing_tiers: faker.string.alpha({length: {min: 10, max: 20}}), has_trial: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), trial_days: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), trial_features: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_featured: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_new: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), download_count: faker.number.int({min: undefined, max: undefined}), average_rating: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), review_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.string.alpha({length: {min: 10, max: 20}}), current_version: faker.string.alpha({length: {min: 10, max: 20}}), versions: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), images: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), image_type: faker.helpers.arrayElement(Object.values(ImageTypeEnum)), image_url: faker.string.alpha({length: {min: 10, max: 20}}), thumbnail_url: faker.string.alpha({length: {min: 10, max: 20}}), alt_text: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), caption: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 255}}), undefined]), display_order: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), documents: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), document_type: faker.helpers.arrayElement(Object.values(DocumentTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), file_url: faker.string.alpha({length: {min: 10, max: 20}}), file_size: faker.string.alpha({length: {min: 10, max: 20}}), file_type: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 10}}), undefined]), version: faker.string.alpha({length: {min: 10, max: 50}}), download_count: faker.number.int({min: undefined, max: undefined}), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ProductsVersionsListResponseMock = (overrideResponse: Partial< PaginatedSoftwareVersionList > = {}): PaginatedSoftwareVersionList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined])})), ...overrideResponse})

export const getV1ProductsVersionsCreateResponseMock = (overrideResponse: Partial< SoftwareVersion > = {}): SoftwareVersion => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getV1ProductsVersionsRetrieveResponseMock = (overrideResponse: Partial< SoftwareVersion > = {}): SoftwareVersion => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getV1ProductsVersionsUpdateResponseMock = (overrideResponse: Partial< SoftwareVersion > = {}): SoftwareVersion => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getV1ProductsVersionsPartialUpdateResponseMock = (overrideResponse: Partial< SoftwareVersion > = {}): SoftwareVersion => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getV1ProductsVersionsToggleActiveCreateResponseMock = (overrideResponse: Partial< SoftwareVersion > = {}): SoftwareVersion => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getV1ProductsVersionsToggleBetaCreateResponseMock = (overrideResponse: Partial< SoftwareVersion > = {}): SoftwareVersion => ({id: faker.string.uuid(), software: faker.string.uuid(), version_number: faker.string.alpha({length: {min: 10, max: 50}}), version_code: faker.string.alpha({length: {min: 10, max: 20}}), release_name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 100}}), undefined]), release_notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), changelog: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), binary_file: faker.internet.url(), binary_size: faker.number.int({min: undefined, max: undefined}), file_size_human: faker.string.alpha({length: {min: 10, max: 20}}), binary_checksum: faker.string.alpha({length: {min: 10, max: 20}}), installer_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), download_url: faker.string.alpha({length: {min: 10, max: 20}}), download_count: faker.number.int({min: undefined, max: undefined}), supported_os: faker.helpers.arrayElement([{}, undefined]), min_requirements: faker.helpers.arrayElement([{}, undefined]), recommended_requirements: faker.helpers.arrayElement([{}, undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_beta: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_stable: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), is_signed: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), signature_file: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, released_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, undefined]), ...overrideResponse})

export const getV1abuseAttemptsListResponseMock = (overrideResponse: Partial< PaginatedAbuseAttemptList > = {}): PaginatedAbuseAttemptList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), user_agent: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), attempt_type: faker.helpers.arrayElement(Object.values(AttemptTypeEnum)), severity: faker.helpers.arrayElement([faker.helpers.arrayElement([1,5,8,10] as const), undefined]), action_taken: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActionTakenEnum)), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1abuseAttemptsRetrieveResponseMock = (overrideResponse: Partial< AbuseAttempt > = {}): AbuseAttempt => ({id: faker.string.uuid(), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), user_agent: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), attempt_type: faker.helpers.arrayElement(Object.values(AttemptTypeEnum)), severity: faker.helpers.arrayElement([faker.helpers.arrayElement([1,5,8,10] as const), undefined]), action_taken: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(ActionTakenEnum)), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1alertsListResponseMock = (overrideResponse: Partial< PaginatedAbuseAlertList > = {}): PaginatedAbuseAlertList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), alert_type: faker.helpers.arrayElement(Object.values(AlertTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), message: faker.string.alpha({length: {min: 10, max: 20}}), acknowledged: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), acknowledged_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1alertsRetrieveResponseMock = (overrideResponse: Partial< AbuseAlert > = {}): AbuseAlert => ({id: faker.string.uuid(), alert_type: faker.helpers.arrayElement(Object.values(AlertTypeEnum)), title: faker.string.alpha({length: {min: 10, max: 255}}), message: faker.string.alpha({length: {min: 10, max: 20}}), acknowledged: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), acknowledged_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1codeBlacklistListResponseMock = (overrideResponse: Partial< PaginatedCodeBlacklistList > = {}): PaginatedCodeBlacklistList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(CodeBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1codeBlacklistCreateResponseMock = (overrideResponse: Partial< CodeBlacklist > = {}): CodeBlacklist => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(CodeBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1codeBlacklistRetrieveResponseMock = (overrideResponse: Partial< CodeBlacklist > = {}): CodeBlacklist => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(CodeBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1codeBlacklistUpdateResponseMock = (overrideResponse: Partial< CodeBlacklist > = {}): CodeBlacklist => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(CodeBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1codeBlacklistPartialUpdateResponseMock = (overrideResponse: Partial< CodeBlacklist > = {}): CodeBlacklist => ({id: faker.string.uuid(), activation_code: faker.string.uuid(), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(CodeBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ipBlacklistListResponseMock = (overrideResponse: Partial< PaginatedIPBlacklistList > = {}): PaginatedIPBlacklistList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), subnet_mask: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: 0, max: 32767}), null]), undefined]), cidr: faker.string.alpha({length: {min: 10, max: 20}}), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(IPBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1ipBlacklistCreateResponseMock = (overrideResponse: Partial< IPBlacklist > = {}): IPBlacklist => ({id: faker.string.uuid(), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), subnet_mask: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: 0, max: 32767}), null]), undefined]), cidr: faker.string.alpha({length: {min: 10, max: 20}}), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(IPBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ipBlacklistRetrieveResponseMock = (overrideResponse: Partial< IPBlacklist > = {}): IPBlacklist => ({id: faker.string.uuid(), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), subnet_mask: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: 0, max: 32767}), null]), undefined]), cidr: faker.string.alpha({length: {min: 10, max: 20}}), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(IPBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ipBlacklistUpdateResponseMock = (overrideResponse: Partial< IPBlacklist > = {}): IPBlacklist => ({id: faker.string.uuid(), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), subnet_mask: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: 0, max: 32767}), null]), undefined]), cidr: faker.string.alpha({length: {min: 10, max: 20}}), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(IPBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1ipBlacklistPartialUpdateResponseMock = (overrideResponse: Partial< IPBlacklist > = {}): IPBlacklist => ({id: faker.string.uuid(), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), subnet_mask: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.number.int({min: 0, max: 32767}), null]), undefined]), cidr: faker.string.alpha({length: {min: 10, max: 20}}), reason: faker.string.alpha({length: {min: 10, max: 20}}), source: faker.helpers.arrayElement([faker.helpers.arrayElement(Object.values(IPBlacklistSourceEnum)), undefined]), is_permanent: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), expires_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), undefined]), is_active: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getV1securityLogsListResponseMock = (overrideResponse: Partial< PaginatedSecurityNotificationLogList > = {}): PaginatedSecurityNotificationLogList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), event_hash: faker.string.alpha({length: {min: 10, max: 64}}), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), risk_level: faker.number.int({min: -2147483648, max: 2147483647}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), recipient_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getV1securityLogsRetrieveResponseMock = (overrideResponse: Partial< SecurityNotificationLog > = {}): SecurityNotificationLog => ({id: faker.string.uuid(), event_hash: faker.string.alpha({length: {min: 10, max: 64}}), user: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.uuid(), null]), undefined]), risk_level: faker.number.int({min: -2147483648, max: 2147483647}), ip_address: faker.string.alpha({length: {min: 10, max: 20}}), recipient_count: faker.helpers.arrayElement([faker.number.int({min: -2147483648, max: 2147483647}), undefined]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getDistributionMirrorsListResponseMock = (overrideResponse: Partial< PaginatedMirrorList > = {}): PaginatedMirrorList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), name: faker.string.alpha({length: {min: 10, max: 20}}), base_url: faker.internet.url(), region: faker.string.alpha({length: {min: 10, max: 20}}), priority: faker.number.int({min: undefined, max: undefined}), is_online: faker.datatype.boolean()})), ...overrideResponse})

export const getApiListResponseMock = (overrideResponse: Partial< PaginatedNotificationList > = {}): PaginatedNotificationList => ({count: faker.number.int({min: undefined, max: undefined}), next: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), previous: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.internet.url(), null]), undefined]), results: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.uuid(), user: faker.string.uuid(), channel: faker.helpers.arrayElement(Object.values(ChannelEnum)), subject: faker.string.alpha({length: {min: 10, max: 20}}), body: faker.string.alpha({length: {min: 10, max: 20}}), html_body: faker.string.alpha({length: {min: 10, max: 20}}), context: {}, status: faker.helpers.arrayElement(Object.values(NotificationStatusEnum)), sent_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), opened_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), clicked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`})), ...overrideResponse})

export const getApiRetrieveResponseMock = (overrideResponse: Partial< Notification > = {}): Notification => ({id: faker.string.uuid(), user: faker.string.uuid(), channel: faker.helpers.arrayElement(Object.values(ChannelEnum)), subject: faker.string.alpha({length: {min: 10, max: 20}}), body: faker.string.alpha({length: {min: 10, max: 20}}), html_body: faker.string.alpha({length: {min: 10, max: 20}}), context: {}, status: faker.helpers.arrayElement(Object.values(NotificationStatusEnum)), sent_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), opened_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), clicked_at: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})


export const getCohortsListMockHandler = (overrideResponse?: CohortAggregate[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CohortAggregate[]> | CohortAggregate[]), options?: RequestHandlerOptions) => {
  return http.get('*/analytics/cohorts/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCohortsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDailyListMockHandler = (overrideResponse?: DailyAggregate[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DailyAggregate[]> | DailyAggregate[]), options?: RequestHandlerOptions) => {
  return http.get('*/analytics/daily/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDailyListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDailyRetrieveMockHandler = (overrideResponse?: DailyAggregate | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<DailyAggregate> | DailyAggregate), options?: RequestHandlerOptions) => {
  return http.get('*/analytics/daily/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDailyRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getExportsListMockHandler = (overrideResponse?: PaginatedExportJobList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedExportJobList> | PaginatedExportJobList), options?: RequestHandlerOptions) => {
  return http.get('*/analytics/exports/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getExportsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getExportsCreateMockHandler = (overrideResponse?: ExportJob | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ExportJob> | ExportJob), options?: RequestHandlerOptions) => {
  return http.post('*/analytics/exports/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getExportsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getExportsRetrieveMockHandler = (overrideResponse?: ExportJob | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ExportJob> | ExportJob), options?: RequestHandlerOptions) => {
  return http.get('*/analytics/exports/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getExportsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getExportsDownloadRetrieveMockHandler = (overrideResponse?: ExportsDownloadRetrieve200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ExportsDownloadRetrieve200> | ExportsDownloadRetrieve200), options?: RequestHandlerOptions) => {
  return http.get('*/analytics/exports/:id/download/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getExportsDownloadRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1Auth2faEmergencyRegenerateBackupCodesCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/2fa/emergency/regenerate-backup-codes/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1Auth2faEmergencySetupRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/2fa/emergency/setup/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1Auth2faEmergencySetupCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/2fa/emergency/setup/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1Auth2faEmergencySetupDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/auth/2fa/emergency/setup/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1Auth2faEmergencyVerifyCreateMockHandler = (overrideResponse?: EmergencyTwoFactorVerify | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<EmergencyTwoFactorVerify> | EmergencyTwoFactorVerify), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/2fa/emergency/verify/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1Auth2faEmergencyVerifyCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthActionsListMockHandler = (overrideResponse?: PaginatedAdminActionLogList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedAdminActionLogList> | PaginatedAdminActionLogList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/actions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthActionsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthActionsRetrieveMockHandler = (overrideResponse?: AdminActionLog | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminActionLog> | AdminActionLog), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/actions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthActionsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthAdminProfilesListMockHandler = (overrideResponse?: PaginatedAdminProfileList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedAdminProfileList> | PaginatedAdminProfileList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/admin-profiles/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthAdminProfilesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthAdminProfilesCreateMockHandler = (overrideResponse?: AdminProfile | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AdminProfile> | AdminProfile), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/admin-profiles/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthAdminProfilesCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthAdminProfilesRetrieveMockHandler = (overrideResponse?: AdminProfile | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AdminProfile> | AdminProfile), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/admin-profiles/:user/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthAdminProfilesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthAdminProfilesUpdateMockHandler = (overrideResponse?: AdminProfile | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<AdminProfile> | AdminProfile), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/auth/admin-profiles/:user/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthAdminProfilesUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthAdminProfilesPartialUpdateMockHandler = (overrideResponse?: AdminProfile | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<AdminProfile> | AdminProfile), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/auth/admin-profiles/:user/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthAdminProfilesPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthAdminProfilesDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/auth/admin-profiles/:user/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1AuthChangePasswordCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/change-password/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthDeviceVerifyConfirmCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/device/verify/confirm/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthDevicesRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/devices/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthDevicesDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/auth/devices/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1AuthDevicesRetrieve2MockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/devices/:sessionId/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthDevicesDestroy2MockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/auth/devices/:sessionId/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1AuthLoginCreateMockHandler = (overrideResponse?: CustomTokenObtainPair | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CustomTokenObtainPair> | CustomTokenObtainPair), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/login/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthLoginCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthLogoutCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/logout/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthPreferencesRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/preferences/notifications/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthPreferencesCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/preferences/notifications/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthRegisterCreateMockHandler = (overrideResponse?: UserRegistration | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<UserRegistration> | UserRegistration), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/register/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthRegisterCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthResetPasswordCreateMockHandler = (overrideResponse?: PasswordResetRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PasswordResetRequest> | PasswordResetRequest), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/reset-password/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthResetPasswordCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthResetPasswordConfirmCreateMockHandler = (overrideResponse?: PasswordResetConfirm | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PasswordResetConfirm> | PasswordResetConfirm), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/reset-password/confirm/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthResetPasswordConfirmCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthSessionsListMockHandler = (overrideResponse?: PaginatedUserSessionList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedUserSessionList> | PaginatedUserSessionList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/sessions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthSessionsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthSessionsRetrieveMockHandler = (overrideResponse?: UserSession | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserSession> | UserSession), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/sessions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthSessionsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthSessionsRevokeCreateMockHandler = (overrideResponse?: UserSession | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<UserSession> | UserSession), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/sessions/:id/revoke/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthSessionsRevokeCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthTokenRefreshCreateMockHandler = (overrideResponse?: TokenRefresh | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TokenRefresh> | TokenRefresh), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/token/refresh/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthTokenRefreshCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthTokenVerifyCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/token/verify/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthUnsubscribeCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/unsubscribe/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1AuthUsersListMockHandler = (overrideResponse?: PaginatedUserList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedUserList> | PaginatedUserList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/users/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthUsersListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthUsersCreateMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/auth/users/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthUsersCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthUsersRetrieveMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/users/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthUsersRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthUsersUpdateMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/auth/users/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthUsersUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthUsersPartialUpdateMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/auth/users/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthUsersPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthUsersDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/auth/users/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1AuthUsersMeRetrieveMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/users/me/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1AuthUsersMeRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1AuthVerifyEmailRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/auth/verify-email/:token/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1CatalogRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/catalog/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1analyticsRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/analytics/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1licenseUsageRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/license-usage/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1overviewRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/overview/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1reportsRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/reports/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1salesRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/sales/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1statsRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/stats/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1systemMonitoringRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/system-monitoring/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1userActivityRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/dashboard/user-activity/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1LicensesActivateCreateMockHandler = (overrideResponse?: ActivationRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ActivationRequest> | ActivationRequest), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/activate/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivateCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesListMockHandler = (overrideResponse?: PaginatedActivationCodeList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedActivationCodeList> | PaginatedActivationCodeList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/activation-codes/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesCreateMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/activation-codes/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesRetrieveMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/activation-codes/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesUpdateMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/licenses/activation-codes/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesPartialUpdateMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/licenses/activation-codes/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/licenses/activation-codes/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1LicensesActivationCodesActivateDeviceCreateMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/activation-codes/:id/activate_device/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesActivateDeviceCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesDeactivateDeviceCreateMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/activation-codes/:id/deactivate_device/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesDeactivateDeviceCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesLicenseFileRetrieveMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/activation-codes/:id/license_file/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesLicenseFileRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesActivationCodesMyLicensesRetrieveMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/activation-codes/my_licenses/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesActivationCodesMyLicensesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesBatchesListMockHandler = (overrideResponse?: PaginatedCodeBatchList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedCodeBatchList> | PaginatedCodeBatchList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/batches/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesBatchesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesBatchesCreateMockHandler = (overrideResponse?: CodeBatch | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CodeBatch> | CodeBatch), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/batches/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesBatchesCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesBatchesRetrieveMockHandler = (overrideResponse?: CodeBatch | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CodeBatch> | CodeBatch), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/batches/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesBatchesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesBatchesUpdateMockHandler = (overrideResponse?: CodeBatch | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<CodeBatch> | CodeBatch), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/licenses/batches/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesBatchesUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesBatchesPartialUpdateMockHandler = (overrideResponse?: CodeBatch | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<CodeBatch> | CodeBatch), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/licenses/batches/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesBatchesPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesBatchesDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/licenses/batches/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1LicensesBatchesCodesRetrieveMockHandler = (overrideResponse?: CodeBatch | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CodeBatch> | CodeBatch), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/batches/:id/codes/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesBatchesCodesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesCheckUpdatesRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/check-updates/:softwareSlug/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1LicensesDeactivateCreateMockHandler = (overrideResponse?: DeactivationRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<DeactivationRequest> | DeactivationRequest), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/deactivate/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesDeactivateCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesFeaturesListMockHandler = (overrideResponse?: PaginatedLicenseFeatureList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedLicenseFeatureList> | PaginatedLicenseFeatureList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/features/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesFeaturesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesFeaturesCreateMockHandler = (overrideResponse?: LicenseFeature | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LicenseFeature> | LicenseFeature), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/features/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesFeaturesCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesFeaturesRetrieveMockHandler = (overrideResponse?: LicenseFeature | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LicenseFeature> | LicenseFeature), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/features/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesFeaturesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesFeaturesUpdateMockHandler = (overrideResponse?: LicenseFeature | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<LicenseFeature> | LicenseFeature), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/licenses/features/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesFeaturesUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesFeaturesPartialUpdateMockHandler = (overrideResponse?: LicenseFeature | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<LicenseFeature> | LicenseFeature), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/licenses/features/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesFeaturesPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesFeaturesDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/licenses/features/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1LicensesGenerateCreateMockHandler = (overrideResponse?: ActivationCode | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ActivationCode> | ActivationCode), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/generate/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesGenerateCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesLogsListMockHandler = (overrideResponse?: PaginatedActivationLogList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedActivationLogList> | PaginatedActivationLogList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/logs/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesLogsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesLogsRetrieveMockHandler = (overrideResponse?: ActivationLog | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ActivationLog> | ActivationLog), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/logs/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesLogsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesMyLicensesListMockHandler = (overrideResponse?: PaginatedActivationCodeList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedActivationCodeList> | PaginatedActivationCodeList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/my-licenses/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesMyLicensesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesRevokeCreateMockHandler = (overrideResponse?: RevocationRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<RevocationRequest> | RevocationRequest), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/revoke/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesRevokeCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesRevokeCreate2MockHandler = (overrideResponse?: RevocationRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<RevocationRequest> | RevocationRequest), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/revoke/:codeId/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesRevokeCreate2ResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesUsageListMockHandler = (overrideResponse?: PaginatedLicenseUsageList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedLicenseUsageList> | PaginatedLicenseUsageList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/usage/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesUsageListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesUsageCreateMockHandler = (overrideResponse?: LicenseUsage | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LicenseUsage> | LicenseUsage), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/usage/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesUsageCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesUsageRetrieveMockHandler = (overrideResponse?: LicenseUsage | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LicenseUsage> | LicenseUsage), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/licenses/usage/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesUsageRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesUsageUpdateMockHandler = (overrideResponse?: LicenseUsage | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<LicenseUsage> | LicenseUsage), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/licenses/usage/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesUsageUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesUsagePartialUpdateMockHandler = (overrideResponse?: LicenseUsage | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<LicenseUsage> | LicenseUsage), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/licenses/usage/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesUsagePartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesUsageDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/licenses/usage/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1LicensesUsageLogUsageCreateMockHandler = (overrideResponse?: LicenseUsage | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LicenseUsage> | LicenseUsage), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/usage/log_usage/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesUsageLogUsageCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesValidateCreateMockHandler = (overrideResponse?: ValidateActivation | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ValidateActivation> | ValidateActivation), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/validate/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1LicensesValidateCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1LicensesValidateOfflineCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/licenses/validate-offline/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1PaymentsCouponsListMockHandler = (overrideResponse?: PaginatedCouponList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedCouponList> | PaginatedCouponList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/coupons/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsCouponsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsCouponsCreateMockHandler = (overrideResponse?: Coupon | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Coupon> | Coupon), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/payments/coupons/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsCouponsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsCouponsRetrieveMockHandler = (overrideResponse?: Coupon | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Coupon> | Coupon), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/coupons/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsCouponsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsCouponsUpdateMockHandler = (overrideResponse?: Coupon | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Coupon> | Coupon), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/payments/coupons/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsCouponsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsCouponsPartialUpdateMockHandler = (overrideResponse?: Coupon | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Coupon> | Coupon), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/payments/coupons/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsCouponsPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsCouponsDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/payments/coupons/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1PaymentsCreatePaymentCreateMockHandler = (overrideResponse?: GenericResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<GenericResponse> | GenericResponse), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/payments/create-payment/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsCreatePaymentCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsInvoicesListMockHandler = (overrideResponse?: PaginatedInvoiceList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedInvoiceList> | PaginatedInvoiceList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/invoices/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsInvoicesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsInvoicesRetrieveMockHandler = (overrideResponse?: Invoice | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Invoice> | Invoice), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/invoices/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsInvoicesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsInvoicesDownloadRetrieveMockHandler = (overrideResponse?: Invoice | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Invoice> | Invoice), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/invoices/:id/download/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsInvoicesDownloadRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsMyTransactionsListMockHandler = (overrideResponse?: PaginatedTransactionList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedTransactionList> | PaginatedTransactionList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/my-transactions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsMyTransactionsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsPaymentsListMockHandler = (overrideResponse?: PaymentPlaceholder[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaymentPlaceholder[]> | PaymentPlaceholder[]), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/payments/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsPaymentsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsPlansListMockHandler = (overrideResponse?: PaginatedPlanList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedPlanList> | PaginatedPlanList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/plans/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsPlansListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsPlansRetrieveMockHandler = (overrideResponse?: Plan | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Plan> | Plan), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/plans/:code/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsPlansRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsSubscriptionsListMockHandler = (overrideResponse?: PaginatedSubscriptionList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSubscriptionList> | PaginatedSubscriptionList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/subscriptions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsSubscriptionsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsSubscriptionsCreateMockHandler = (overrideResponse?: Subscription | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Subscription> | Subscription), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/payments/subscriptions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsSubscriptionsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsSubscriptionsRetrieveMockHandler = (overrideResponse?: Subscription | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Subscription> | Subscription), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/payments/subscriptions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsSubscriptionsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsSubscriptionsUpdateMockHandler = (overrideResponse?: Subscription | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Subscription> | Subscription), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/payments/subscriptions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsSubscriptionsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsSubscriptionsPartialUpdateMockHandler = (overrideResponse?: Subscription | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Subscription> | Subscription), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/payments/subscriptions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsSubscriptionsPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsSubscriptionsDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/payments/subscriptions/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1PaymentsSubscriptionsCancelCreateMockHandler = (overrideResponse?: Subscription | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Subscription> | Subscription), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/payments/subscriptions/:id/cancel/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsSubscriptionsCancelCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1PaymentsSubscriptionsWebhookCreateMockHandler = (overrideResponse?: Subscription | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Subscription> | Subscription), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/payments/subscriptions/webhook/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1PaymentsSubscriptionsWebhookCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsDownloadRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/:slug/download/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1ProductsDownloadRetrieve2MockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/:slug/download/:versionId/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1ProductsVersionsList2MockHandler = (overrideResponse?: PaginatedSoftwareVersionList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSoftwareVersionList> | PaginatedSoftwareVersionList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/:slug/versions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsList2ResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsCategoriesListMockHandler = (overrideResponse?: PaginatedCategoryList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedCategoryList> | PaginatedCategoryList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/categories/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsCategoriesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsCategoriesCreateMockHandler = (overrideResponse?: Category | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Category> | Category), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/categories/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsCategoriesCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsCategoriesRetrieveMockHandler = (overrideResponse?: Category | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Category> | Category), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/categories/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsCategoriesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsCategoriesUpdateMockHandler = (overrideResponse?: Category | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Category> | Category), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/products/categories/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsCategoriesUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsCategoriesPartialUpdateMockHandler = (overrideResponse?: Category | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Category> | Category), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/products/categories/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsCategoriesPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsCategoriesDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/products/categories/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1ProductsDocumentsListMockHandler = (overrideResponse?: PaginatedSoftwareDocumentList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSoftwareDocumentList> | PaginatedSoftwareDocumentList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/documents/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsDocumentsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsDocumentsCreateMockHandler = (overrideResponse?: SoftwareDocument | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SoftwareDocument> | SoftwareDocument), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/documents/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsDocumentsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsDocumentsRetrieveMockHandler = (overrideResponse?: SoftwareDocument | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SoftwareDocument> | SoftwareDocument), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/documents/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsDocumentsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsDocumentsUpdateMockHandler = (overrideResponse?: SoftwareDocument | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SoftwareDocument> | SoftwareDocument), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/products/documents/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsDocumentsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsDocumentsPartialUpdateMockHandler = (overrideResponse?: SoftwareDocument | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<SoftwareDocument> | SoftwareDocument), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/products/documents/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsDocumentsPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsDocumentsDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/products/documents/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1ProductsDocumentsDownloadRetrieveMockHandler = (overrideResponse?: SoftwareDocument | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SoftwareDocument> | SoftwareDocument), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/documents/:id/download/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsDocumentsDownloadRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsFeaturedListMockHandler = (overrideResponse?: Software[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Software[]> | Software[]), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/featured/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsFeaturedListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsImagesListMockHandler = (overrideResponse?: PaginatedSoftwareImageList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSoftwareImageList> | PaginatedSoftwareImageList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/images/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsImagesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsImagesCreateMockHandler = (overrideResponse?: SoftwareImage | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SoftwareImage> | SoftwareImage), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/images/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsImagesCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsImagesRetrieveMockHandler = (overrideResponse?: SoftwareImage | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SoftwareImage> | SoftwareImage), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/images/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsImagesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsImagesUpdateMockHandler = (overrideResponse?: SoftwareImage | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SoftwareImage> | SoftwareImage), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/products/images/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsImagesUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsImagesPartialUpdateMockHandler = (overrideResponse?: SoftwareImage | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<SoftwareImage> | SoftwareImage), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/products/images/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsImagesPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsImagesDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/products/images/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1ProductsNewReleasesListMockHandler = (overrideResponse?: PaginatedSoftwareList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSoftwareList> | PaginatedSoftwareList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/new-releases/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsNewReleasesListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareListMockHandler = (overrideResponse?: PaginatedSoftwareList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSoftwareList> | PaginatedSoftwareList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/software/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareCreateMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/software/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareRetrieveMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/software/:slug/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareUpdateMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/products/software/:slug/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwarePartialUpdateMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/products/software/:slug/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwarePartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/products/software/:slug/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1ProductsSoftwareDocumentsRetrieveMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/software/:slug/documents/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareDocumentsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareImagesRetrieveMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/software/:slug/images/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareImagesRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareToggleActiveCreateMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/software/:slug/toggle_active/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareToggleActiveCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareToggleFeaturedCreateMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/software/:slug/toggle_featured/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareToggleFeaturedCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsSoftwareVersionsRetrieveMockHandler = (overrideResponse?: Software | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Software> | Software), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/software/:slug/versions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsSoftwareVersionsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsUsageCreateMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/usage/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1ProductsVersionsListMockHandler = (overrideResponse?: PaginatedSoftwareVersionList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSoftwareVersionList> | PaginatedSoftwareVersionList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/versions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsVersionsCreateMockHandler = (overrideResponse?: SoftwareVersion | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SoftwareVersion> | SoftwareVersion), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/versions/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsVersionsRetrieveMockHandler = (overrideResponse?: SoftwareVersion | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SoftwareVersion> | SoftwareVersion), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/products/versions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsVersionsUpdateMockHandler = (overrideResponse?: SoftwareVersion | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SoftwareVersion> | SoftwareVersion), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/products/versions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsVersionsPartialUpdateMockHandler = (overrideResponse?: SoftwareVersion | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<SoftwareVersion> | SoftwareVersion), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/products/versions/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsVersionsDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/products/versions/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1ProductsVersionsToggleActiveCreateMockHandler = (overrideResponse?: SoftwareVersion | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SoftwareVersion> | SoftwareVersion), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/versions/:id/toggle_active/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsToggleActiveCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ProductsVersionsToggleBetaCreateMockHandler = (overrideResponse?: SoftwareVersion | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SoftwareVersion> | SoftwareVersion), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/products/versions/:id/toggle_beta/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ProductsVersionsToggleBetaCreateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1abuseAttemptsListMockHandler = (overrideResponse?: PaginatedAbuseAttemptList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedAbuseAttemptList> | PaginatedAbuseAttemptList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/abuse-attempts/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1abuseAttemptsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1abuseAttemptsRetrieveMockHandler = (overrideResponse?: AbuseAttempt | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AbuseAttempt> | AbuseAttempt), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/abuse-attempts/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1abuseAttemptsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1alertsListMockHandler = (overrideResponse?: PaginatedAbuseAlertList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedAbuseAlertList> | PaginatedAbuseAlertList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/alerts/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1alertsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1alertsRetrieveMockHandler = (overrideResponse?: AbuseAlert | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<AbuseAlert> | AbuseAlert), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/alerts/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1alertsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1auditLogRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/audit-log/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1codeBlacklistListMockHandler = (overrideResponse?: PaginatedCodeBlacklistList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedCodeBlacklistList> | PaginatedCodeBlacklistList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/code-blacklist/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1codeBlacklistListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1codeBlacklistCreateMockHandler = (overrideResponse?: CodeBlacklist | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CodeBlacklist> | CodeBlacklist), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/security/code-blacklist/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1codeBlacklistCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1codeBlacklistRetrieveMockHandler = (overrideResponse?: CodeBlacklist | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CodeBlacklist> | CodeBlacklist), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/code-blacklist/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1codeBlacklistRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1codeBlacklistUpdateMockHandler = (overrideResponse?: CodeBlacklist | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<CodeBlacklist> | CodeBlacklist), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/security/code-blacklist/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1codeBlacklistUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1codeBlacklistPartialUpdateMockHandler = (overrideResponse?: CodeBlacklist | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<CodeBlacklist> | CodeBlacklist), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/security/code-blacklist/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1codeBlacklistPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1codeBlacklistDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/security/code-blacklist/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1deviceCheckRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/device-check/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1ipBlacklistListMockHandler = (overrideResponse?: PaginatedIPBlacklistList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedIPBlacklistList> | PaginatedIPBlacklistList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/ip-blacklist/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ipBlacklistListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ipBlacklistCreateMockHandler = (overrideResponse?: IPBlacklist | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<IPBlacklist> | IPBlacklist), options?: RequestHandlerOptions) => {
  return http.post('*/api/v1/security/ip-blacklist/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ipBlacklistCreateResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ipBlacklistRetrieveMockHandler = (overrideResponse?: IPBlacklist | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<IPBlacklist> | IPBlacklist), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/ip-blacklist/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ipBlacklistRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ipBlacklistUpdateMockHandler = (overrideResponse?: IPBlacklist | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<IPBlacklist> | IPBlacklist), options?: RequestHandlerOptions) => {
  return http.put('*/api/v1/security/ip-blacklist/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ipBlacklistUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ipBlacklistPartialUpdateMockHandler = (overrideResponse?: IPBlacklist | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<IPBlacklist> | IPBlacklist), options?: RequestHandlerOptions) => {
  return http.patch('*/api/v1/security/ip-blacklist/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1ipBlacklistPartialUpdateResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1ipBlacklistDestroyMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/api/v1/security/ip-blacklist/:id/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getV1securityLogsListMockHandler = (overrideResponse?: PaginatedSecurityNotificationLogList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedSecurityNotificationLogList> | PaginatedSecurityNotificationLogList), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/security-logs/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1securityLogsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1securityLogsRetrieveMockHandler = (overrideResponse?: SecurityNotificationLog | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SecurityNotificationLog> | SecurityNotificationLog), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/security-logs/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getV1securityLogsRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getV1settingsRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/settings/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1suspiciousActivityRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/security/suspicious-activity/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1StatusRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/status/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1SystemConfigRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/system/config/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1SystemHealthRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/system/health/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getV1SystemMetricsRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/api/v1/system/metrics/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getDistributionFileRetrieveMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/distribution/file/:versionId/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getDistributionFileRetrieve2MockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.get('*/distribution/file/:versionId/:artifactType/', async (info) => {await delay(1000);
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 200,
        
      })
  }, options)
}

export const getDistributionMirrorsListMockHandler = (overrideResponse?: PaginatedMirrorList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedMirrorList> | PaginatedMirrorList), options?: RequestHandlerOptions) => {
  return http.get('*/distribution/mirrors/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDistributionMirrorsListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getApiListMockHandler = (overrideResponse?: PaginatedNotificationList | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PaginatedNotificationList> | PaginatedNotificationList), options?: RequestHandlerOptions) => {
  return http.get('*/notifications/api/notifications/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getApiListResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getApiRetrieveMockHandler = (overrideResponse?: Notification | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Notification> | Notification), options?: RequestHandlerOptions) => {
  return http.get('*/notifications/api/notifications/:id/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getApiRetrieveResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}
export const getSoftwareDistributionPlatformAPIMock = () => [
  getCohortsListMockHandler(),
  getDailyListMockHandler(),
  getDailyRetrieveMockHandler(),
  getExportsListMockHandler(),
  getExportsCreateMockHandler(),
  getExportsRetrieveMockHandler(),
  getExportsDownloadRetrieveMockHandler(),
  getV1Auth2faEmergencyRegenerateBackupCodesCreateMockHandler(),
  getV1Auth2faEmergencySetupRetrieveMockHandler(),
  getV1Auth2faEmergencySetupCreateMockHandler(),
  getV1Auth2faEmergencySetupDestroyMockHandler(),
  getV1Auth2faEmergencyVerifyCreateMockHandler(),
  getV1AuthActionsListMockHandler(),
  getV1AuthActionsRetrieveMockHandler(),
  getV1AuthAdminProfilesListMockHandler(),
  getV1AuthAdminProfilesCreateMockHandler(),
  getV1AuthAdminProfilesRetrieveMockHandler(),
  getV1AuthAdminProfilesUpdateMockHandler(),
  getV1AuthAdminProfilesPartialUpdateMockHandler(),
  getV1AuthAdminProfilesDestroyMockHandler(),
  getV1AuthChangePasswordCreateMockHandler(),
  getV1AuthDeviceVerifyConfirmCreateMockHandler(),
  getV1AuthDevicesRetrieveMockHandler(),
  getV1AuthDevicesDestroyMockHandler(),
  getV1AuthDevicesRetrieve2MockHandler(),
  getV1AuthDevicesDestroy2MockHandler(),
  getV1AuthLoginCreateMockHandler(),
  getV1AuthLogoutCreateMockHandler(),
  getV1AuthPreferencesRetrieveMockHandler(),
  getV1AuthPreferencesCreateMockHandler(),
  getV1AuthRegisterCreateMockHandler(),
  getV1AuthResetPasswordCreateMockHandler(),
  getV1AuthResetPasswordConfirmCreateMockHandler(),
  getV1AuthSessionsListMockHandler(),
  getV1AuthSessionsRetrieveMockHandler(),
  getV1AuthSessionsRevokeCreateMockHandler(),
  getV1AuthTokenRefreshCreateMockHandler(),
  getV1AuthTokenVerifyCreateMockHandler(),
  getV1AuthUnsubscribeCreateMockHandler(),
  getV1AuthUsersListMockHandler(),
  getV1AuthUsersCreateMockHandler(),
  getV1AuthUsersRetrieveMockHandler(),
  getV1AuthUsersUpdateMockHandler(),
  getV1AuthUsersPartialUpdateMockHandler(),
  getV1AuthUsersDestroyMockHandler(),
  getV1AuthUsersMeRetrieveMockHandler(),
  getV1AuthVerifyEmailRetrieveMockHandler(),
  getV1CatalogRetrieveMockHandler(),
  getV1analyticsRetrieveMockHandler(),
  getV1licenseUsageRetrieveMockHandler(),
  getV1overviewRetrieveMockHandler(),
  getV1reportsRetrieveMockHandler(),
  getV1salesRetrieveMockHandler(),
  getV1statsRetrieveMockHandler(),
  getV1systemMonitoringRetrieveMockHandler(),
  getV1userActivityRetrieveMockHandler(),
  getV1LicensesActivateCreateMockHandler(),
  getV1LicensesActivationCodesListMockHandler(),
  getV1LicensesActivationCodesCreateMockHandler(),
  getV1LicensesActivationCodesRetrieveMockHandler(),
  getV1LicensesActivationCodesUpdateMockHandler(),
  getV1LicensesActivationCodesPartialUpdateMockHandler(),
  getV1LicensesActivationCodesDestroyMockHandler(),
  getV1LicensesActivationCodesActivateDeviceCreateMockHandler(),
  getV1LicensesActivationCodesDeactivateDeviceCreateMockHandler(),
  getV1LicensesActivationCodesLicenseFileRetrieveMockHandler(),
  getV1LicensesActivationCodesMyLicensesRetrieveMockHandler(),
  getV1LicensesBatchesListMockHandler(),
  getV1LicensesBatchesCreateMockHandler(),
  getV1LicensesBatchesRetrieveMockHandler(),
  getV1LicensesBatchesUpdateMockHandler(),
  getV1LicensesBatchesPartialUpdateMockHandler(),
  getV1LicensesBatchesDestroyMockHandler(),
  getV1LicensesBatchesCodesRetrieveMockHandler(),
  getV1LicensesCheckUpdatesRetrieveMockHandler(),
  getV1LicensesDeactivateCreateMockHandler(),
  getV1LicensesFeaturesListMockHandler(),
  getV1LicensesFeaturesCreateMockHandler(),
  getV1LicensesFeaturesRetrieveMockHandler(),
  getV1LicensesFeaturesUpdateMockHandler(),
  getV1LicensesFeaturesPartialUpdateMockHandler(),
  getV1LicensesFeaturesDestroyMockHandler(),
  getV1LicensesGenerateCreateMockHandler(),
  getV1LicensesLogsListMockHandler(),
  getV1LicensesLogsRetrieveMockHandler(),
  getV1LicensesMyLicensesListMockHandler(),
  getV1LicensesRevokeCreateMockHandler(),
  getV1LicensesRevokeCreate2MockHandler(),
  getV1LicensesUsageListMockHandler(),
  getV1LicensesUsageCreateMockHandler(),
  getV1LicensesUsageRetrieveMockHandler(),
  getV1LicensesUsageUpdateMockHandler(),
  getV1LicensesUsagePartialUpdateMockHandler(),
  getV1LicensesUsageDestroyMockHandler(),
  getV1LicensesUsageLogUsageCreateMockHandler(),
  getV1LicensesValidateCreateMockHandler(),
  getV1LicensesValidateOfflineCreateMockHandler(),
  getV1PaymentsCouponsListMockHandler(),
  getV1PaymentsCouponsCreateMockHandler(),
  getV1PaymentsCouponsRetrieveMockHandler(),
  getV1PaymentsCouponsUpdateMockHandler(),
  getV1PaymentsCouponsPartialUpdateMockHandler(),
  getV1PaymentsCouponsDestroyMockHandler(),
  getV1PaymentsCreatePaymentCreateMockHandler(),
  getV1PaymentsInvoicesListMockHandler(),
  getV1PaymentsInvoicesRetrieveMockHandler(),
  getV1PaymentsInvoicesDownloadRetrieveMockHandler(),
  getV1PaymentsMyTransactionsListMockHandler(),
  getV1PaymentsPaymentsListMockHandler(),
  getV1PaymentsPlansListMockHandler(),
  getV1PaymentsPlansRetrieveMockHandler(),
  getV1PaymentsSubscriptionsListMockHandler(),
  getV1PaymentsSubscriptionsCreateMockHandler(),
  getV1PaymentsSubscriptionsRetrieveMockHandler(),
  getV1PaymentsSubscriptionsUpdateMockHandler(),
  getV1PaymentsSubscriptionsPartialUpdateMockHandler(),
  getV1PaymentsSubscriptionsDestroyMockHandler(),
  getV1PaymentsSubscriptionsCancelCreateMockHandler(),
  getV1PaymentsSubscriptionsWebhookCreateMockHandler(),
  getV1ProductsDownloadRetrieveMockHandler(),
  getV1ProductsDownloadRetrieve2MockHandler(),
  getV1ProductsVersionsList2MockHandler(),
  getV1ProductsCategoriesListMockHandler(),
  getV1ProductsCategoriesCreateMockHandler(),
  getV1ProductsCategoriesRetrieveMockHandler(),
  getV1ProductsCategoriesUpdateMockHandler(),
  getV1ProductsCategoriesPartialUpdateMockHandler(),
  getV1ProductsCategoriesDestroyMockHandler(),
  getV1ProductsDocumentsListMockHandler(),
  getV1ProductsDocumentsCreateMockHandler(),
  getV1ProductsDocumentsRetrieveMockHandler(),
  getV1ProductsDocumentsUpdateMockHandler(),
  getV1ProductsDocumentsPartialUpdateMockHandler(),
  getV1ProductsDocumentsDestroyMockHandler(),
  getV1ProductsDocumentsDownloadRetrieveMockHandler(),
  getV1ProductsFeaturedListMockHandler(),
  getV1ProductsImagesListMockHandler(),
  getV1ProductsImagesCreateMockHandler(),
  getV1ProductsImagesRetrieveMockHandler(),
  getV1ProductsImagesUpdateMockHandler(),
  getV1ProductsImagesPartialUpdateMockHandler(),
  getV1ProductsImagesDestroyMockHandler(),
  getV1ProductsNewReleasesListMockHandler(),
  getV1ProductsSoftwareListMockHandler(),
  getV1ProductsSoftwareCreateMockHandler(),
  getV1ProductsSoftwareRetrieveMockHandler(),
  getV1ProductsSoftwareUpdateMockHandler(),
  getV1ProductsSoftwarePartialUpdateMockHandler(),
  getV1ProductsSoftwareDestroyMockHandler(),
  getV1ProductsSoftwareDocumentsRetrieveMockHandler(),
  getV1ProductsSoftwareImagesRetrieveMockHandler(),
  getV1ProductsSoftwareToggleActiveCreateMockHandler(),
  getV1ProductsSoftwareToggleFeaturedCreateMockHandler(),
  getV1ProductsSoftwareVersionsRetrieveMockHandler(),
  getV1ProductsUsageCreateMockHandler(),
  getV1ProductsVersionsListMockHandler(),
  getV1ProductsVersionsCreateMockHandler(),
  getV1ProductsVersionsRetrieveMockHandler(),
  getV1ProductsVersionsUpdateMockHandler(),
  getV1ProductsVersionsPartialUpdateMockHandler(),
  getV1ProductsVersionsDestroyMockHandler(),
  getV1ProductsVersionsToggleActiveCreateMockHandler(),
  getV1ProductsVersionsToggleBetaCreateMockHandler(),
  getV1abuseAttemptsListMockHandler(),
  getV1abuseAttemptsRetrieveMockHandler(),
  getV1alertsListMockHandler(),
  getV1alertsRetrieveMockHandler(),
  getV1auditLogRetrieveMockHandler(),
  getV1codeBlacklistListMockHandler(),
  getV1codeBlacklistCreateMockHandler(),
  getV1codeBlacklistRetrieveMockHandler(),
  getV1codeBlacklistUpdateMockHandler(),
  getV1codeBlacklistPartialUpdateMockHandler(),
  getV1codeBlacklistDestroyMockHandler(),
  getV1deviceCheckRetrieveMockHandler(),
  getV1ipBlacklistListMockHandler(),
  getV1ipBlacklistCreateMockHandler(),
  getV1ipBlacklistRetrieveMockHandler(),
  getV1ipBlacklistUpdateMockHandler(),
  getV1ipBlacklistPartialUpdateMockHandler(),
  getV1ipBlacklistDestroyMockHandler(),
  getV1securityLogsListMockHandler(),
  getV1securityLogsRetrieveMockHandler(),
  getV1settingsRetrieveMockHandler(),
  getV1suspiciousActivityRetrieveMockHandler(),
  getV1StatusRetrieveMockHandler(),
  getV1SystemConfigRetrieveMockHandler(),
  getV1SystemHealthRetrieveMockHandler(),
  getV1SystemMetricsRetrieveMockHandler(),
  getDistributionFileRetrieveMockHandler(),
  getDistributionFileRetrieve2MockHandler(),
  getDistributionMirrorsListMockHandler(),
  getApiListMockHandler(),
  getApiRetrieveMockHandler()
]
